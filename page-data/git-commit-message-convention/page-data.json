{"componentChunkName":"component---src-templates-post-jsx","path":"/git-commit-message-convention/","result":{"data":{"site":{"siteMetadata":{"title":"east-woo"}},"markdownRemark":{"id":"87ce0363-7809-5fe5-9b25-1ea48dca5ac0","excerpt":"❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.  git flow 전략  1. Git 커밋 메시지란 무엇인가요? Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. \n이는 프로젝트 이력에 대한 문서…","html":"<blockquote>\n<p>❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.</p>\n</blockquote>\n<p> <strong>git flow 전략</strong> </p>\n<ul>\n<li></li>\n</ul>\n<h2>1. Git 커밋 메시지란 무엇인가요?</h2>\n<ul>\n<li>Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. <br>\n이는 프로젝트 이력에 대한 문서 역할을 하며, 특정 변경이 이루어진 이유에 대한 통찰력을 제공하고 공동 작업자가 시간에 따른 코드베이스의 발전을 더 쉽게 이해하고 추적할 수 있도록 해줍니다.</li>\n</ul>\n<h2>2. Git 커밋 메시지 규칙의 중요성</h2>\n<h3>2.1 Git 커밋 메시지 규칙은 무엇인가요?</h3>\n<ul>\n<li>Git 커밋 메시지 규칙은 커밋 메시지를 작성하는 일관되고 표준화된 방법을 정의하는 일련의 지침 또는 규칙입니다. <br>\n여기에는 변경 내용의 성격에 대한 정보를 전달하기 위한 구조화된 형식과 특정 규칙이 포함됩니다.</li>\n</ul>\n<h3>2.2 Git 커밋 규칙을 따라야 하는 이유</h3>\n<ul>\n<li>명확성 및 가독성: 일관된 커밋 메시지를 통해 팀 구성원은 각 커밋의 목적과 영향을 더 쉽게 이해할 수 있습니다.</li>\n<li>검색 및 탐색: 체계적으로 구성된 커밋 메시지는 버전 기록 검색 기능을 향상시켜 특정 변경 사항을 신속하게 식별하는 데 도움이 됩니다.</li>\n<li>\n<p>자동화 및 도구: 많은 개발 도구 및 플랫폼은 변경 로그 생성 또는 CI/CD 파이프라인 트리거와 같은 자동화된 프로세스에 대한 커밋 메시지 규칙을 활용합니다.</p>\n<blockquote>\n<p>⚠️ 커밋 컨벤션을 적용시키지 않아도 겉보기에는 특정 커밋을 보고 충분히 어떤 내용의 커밋인지 충분히 이해할 수 있다고 생각이 들 수 있습니다.<br>\n그러나 Commit Message 가 누적될수록 가독성이 매우 떨어집니다.</p>\n</blockquote>\n</li>\n</ul>\n<h2>3. Git 커밋 메시지 작성 방법</h2>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">type(옵션): [#issueNumber-]Subject   \n\nbody(옵션)                          \n\nfooter(옵션)                        </code></pre></div>\n<h3>3.1 기본 형식(Commit Message 구조)</h3>\n<blockquote>\n<p>기본적으로 커밋 메시지는 <strong>제목/텍스트/바닥글</strong>로 구성합니다.</p>\n</blockquote>\n<h3>3.2 타입, 태그</h3>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">tag(옵션): [#issueNumber-]Subject\n\n---------:> 예시 &lt;:---------\n\nFeat: 이진법 변환 함수 기능 추가 </code></pre></div>\n<ul>\n<li>어떤 의도로 커밋했는지를 type에 명시해야 합니다.</li>\n</ul>\n<blockquote>\n<ul>\n<li>제목은 \" 태그(tag) + 제목(subject) \" 으로 구성되며, 태그는 영어로 쓰되, 첫 문자는 대문자 로 합니다.</li>\n<li>\"tag: subject\" 의 형태이며, \":\" 뒤에 space 가 있음에 유의합니다.</li>\n</ul>\n</blockquote>\n<h5>자주 사용하는 태그 종류</h5>\n<ul>\n<li>Feat : 새로운 기능을 추가하는 경우</li>\n<li>Fix : 버그를 고친경우</li>\n<li>Docs : 문서를 수정한 경우</li>\n<li>Style : 코드 포맷 변경, 세미콜론 누락, 코드 수정이 없는경우</li>\n<li>Refactor : 코드 리펙토링</li>\n<li>Test : 테스트 코드. 리펙토링 테스트 코드를 추가했을 때</li>\n<li>Chore : 빌드 업무 수정, 패키지 매니저 수정</li>\n<li>Design : CSS 등 사용자가 UI 디자인을 변경했을 때</li>\n<li>Rename : 파일명(or 폴더명) 을 수정한 경우</li>\n<li>Remove : 코드(파일) 의 삭제가 있을 때. \"Clean\", \"Eliminate\" 를 사용하기도 함</li>\n</ul>\n<h5>기타 태그 타입들</h5>\n<ul>\n<li>Add : 코드나 테스트, 예제, 문서등의 추가 생성이 있는경우</li>\n<li>Improve : 향상이 있는 경우. 호환성, 검증 기능, 접근성 등이 될수 있습니다.</li>\n<li>Implement : 코드가 추가된 정도보다 더 주목할만한 구현체를 완성시켰을 때</li>\n<li>Move : 코드의 이동이 있는경우</li>\n<li>Updated : 계정이나 버전 업데이트가 있을 때 사용. 주로 코드보다는 문서나, 리소스, 라이브러리등에 사용합니다.</li>\n<li>Comment : 필요한 주석 추가 및 변경</li>\n</ul>\n<h3>3.3 제목</h3>\n<ul>\n<li>제목은 코드의 변경 사항에 대해 짧은 요약을 나타냅니다.<br></li>\n</ul>\n<p><strong>영어로 제목을 작성하는 경우</strong><br></p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token list punctuation\">1.</span> 제목은 50자를 넘기지 않고, 대문자로 작성하며 마침표를 붙이지 않습니다.\n<span class=\"token list punctuation\">2.</span> 제목은 과거형을 사용하지 않고, 명령조로 시작합니다.\n   ex) 제목을 Fixed 가 아닌, Fix 로 작성합시다.\n( 커밋메시지를 예를들어 Fix : \"Modify album buy bug\" 로 작성하기 )</code></pre></div>\n<p><strong>한글로 제목을 작성하는 경우</strong><br></p>\n<ul>\n<li>\"고침\", \"추가\", \"변경\" 등의 명령조 로 시작합니다.<br></li>\n<li>ex) Feat: \"추가 get data api 함수</li>\n</ul>\n<h3>3.4 텍스트(본문)</h3>\n<ul>\n<li>선택사항이지만 복잡한 변경에는 권장됩니다.</li>\n<li>부연 설명이 필요하거나 커밋한 이유를 설명할 경우 작성해주면 됩니다.</li>\n<li>본문 내용은 어떻게 변경했는지 보다, 무엇을 변경했는지 또는 왜 변경했는지를 설명하도록 합시다.</li>\n<li>텍스트는 추가 세부 정보를 제공하고 컨텍스트를 제공하며 변경이 필요한 이유를 설명합니다. </li>\n<li>제목은 변경 사항을 간략하게 요약한 것입니다. 50자 이내로 작성해야 하며 명령형으로 작성해야 합니다.</li>\n</ul>\n<p><strong>예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">Feat: 이진법 변환 함수 기능 추가\n\n외부 API를 통해 받아온 코드를 16진법에서 2진법을 변환하기 위해 유틸 클래스 생성 및 진법 변환 함수 기능 추가 </code></pre></div>\n<h3>3.5 바닥글</h3>\n<ul>\n<li>바닥글에는 문제에 대한 참조나 주요 변경 사항과 같은 모든 메타데이터가 포함됩니다. 또한 선택 사항입니다.<br></li>\n<li>issue tracker id 를 작성할 때 사용합니다.<br></li>\n<li>형식 : 꼬리말은 \"유형: #이슈 번호\" 형식으로 사용합니다.<br></li>\n<li>해결된 이슈도 추가하여 줘야합니다.</li>\n</ul>\n<p><strong>바닥글에 사용되는 태그들</strong><br></p>\n<ul>\n<li>Closes:<br>\nExample: Closes #123 <br>\n커밋이 특정 문제 번호를 종료. <br></li>\n<li>Resolves:<br>\nExample: Resolves #789 <br>\n'Closes' 및 'Fixes'와 마찬가지로 커밋으로 특정 문제가 해결되었음을 나타냅니다.<br></li>\n<li>Fixes:<br>\nExample: Fixes #456<br>\n'Closes'와 유사하며 커밋이 특정 문제를 해결했음을 나타냅니다(아직 해결이 되지 않는 경우)<br></li>\n<li>Breaking Change:<br>\nExample: BREAKING CHANGE: The API endpoint has been deprecated. Update your calls accordingly.<br>\n커밋이 주요 변경 사항을 도입하고 세부 정보를 제공하도록 지정합니다.<br></li>\n<li>Signed-off-by:<br>\nExample: Signed-off-by: John Doe <a href=\"mailto:john@example.com\">john@example.com</a><br>\n작성자가 커밋을 승인했음을 나타냅니다. 이는 오픈 소스 프로젝트에서 기여자 동의를 확인하기 위해 자주 사용됩니다.<br></li>\n<li>Reviewed-by:<br>\nExample: Reviewed-by: Reviewer Name <a href=\"mailto:reviewer@example.com\">reviewer@example.com</a><br>\n특정인이 커밋을 검토했음을 나타냅니다.<br></li>\n<li>See also:<br>\nExample: See also: #987<br>\n관련 문제 또는 풀 요청에 대한 참조를 제공합니다.<br></li>\n<li>Related:<br>\nExample: Related to: #654<br>\n해당 커밋에 관련된 이슈번호 (아직 해결되지 않은 경우)입니다.<br></li>\n</ul>\n<h2>4. Git 커밋 메시지 자동화 방법</h2>\n<h3>4.1. 서버 훅: Git의 push rule 기능 사용하기</h3>\n<blockquote>\n<ul>\n<li>Git 서버 후크는 특정 이벤트에 대한 응답으로 서버에서 실행되는 스크립트입니다. <br></li>\n<li>특히 'pre-receive' 후크는 업데이트가 저장소에 승인되기 전에 호출됩니다. Git의 푸시 규칙 기능을 활용하면 특정 커밋 메시지 규칙을 적용할 수 있습니다.<br></li>\n</ul>\n</blockquote>\n<ul>\n<li>도구: Commitizen, Husky<br></li>\n<li>위치: 이 도구는 개발자의 로컬 컴퓨터(클라이언트 측)에서 작동합니다.<br></li>\n<li>목적: 개발자의 로컬 작업 흐름과 환경을 향상시키는 데 사용됩니다.<br></li>\n<li>예: Commitizen은 개발자가 로컬 컴퓨터에서 표준화된 커밋 메시지를 생성하는 데 도움이 됩니다. Husky는 Git 후크를 로컬에서 관리하는 데 도움을 줍니다.<br></li>\n</ul>\n<h3>4.2. 클라이언트 훅: 푸시하기 전 미리 검사하기</h3>\n<blockquote>\n<ul>\n<li>클라이언트 후크는 개발자가 변경하는 로컬 시스템에서 실행됩니다. <br></li>\n<li>'pre-push' 후크는 'git push' 명령이 실행되기 전에 트리거되어 개발자가 사전 확인을 수행할 수 있도록 합니다.<br></li>\n</ul>\n</blockquote>\n<ul>\n<li>훅: 예에는 'pre-receive', 'update', 'post-receive'이 포함됩니다.<br> </li>\n<li>위치: 이 후크는 Git 서버에 설치됩니다.<br></li>\n<li>목적: 특정 Git 작업(예: 변경 사항 푸시)이 수행될 때 정책을 시행하고, 작업을 수행하거나, 서버에서 이벤트를 트리거하는 데 사용됩니다.<br></li>\n<li>예: '사전 수신' 서버 측 후크는 커밋 메시지 규칙을 적용하거나 푸시를 수락하기 전에 특정 조건을 확인할 수 있습니다.<br></li>\n</ul>\n<h2>5. Git emojis 사용</h2>\n<ul>\n<li>Git emojis는 이모티콘을 사용하여 커밋 메시지를 시각적으로 표현하고 분류하는 방법입니다.<br></li>\n<li><a href=\"https://gitmoji.dev/\">https://gitmoji.dev/</a> 에서 참고하여 작성.<br></li>\n<li>인텔리제이는 Gitmoji, VS CODE는 Gitmoji Plug-in 지원<br></li>\n<li>gitmoji-cli를 활용하여 Gitmoji를 터미널에서 바로 적용가능</li>\n<li>이모티콘은 추가 컨텍스트를 제공하기 위해 기존 커밋 메시지와 함께 사용되는 경우가 많습니다.<br></li>\n</ul>\n<h4>예시</h4>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">   🚀: 새로운 기능\n   🐛: 버그 수정\n   📚: 문서 업데이트\n   ⚙️: 코드 리팩토링\n   🚨: 획기적인 변화</code></pre></div>\n<h2>결론</h2>\n<p>Git 커밋 메시지 규칙을 따르고 자동화를 활용함으로써 팀은 협업을 간소화하고 깨끗한 버전 기록을 유지하며 전체 프로젝트 문서를 향상시킬 수 있습니다.</p>\n<p>참고 문헌</p>\n<ul>\n<li><a href=\"https://velog.io/@msung99/Git-Commit-Message-Convension\">https://velog.io/@msung99/Git-Commit-Message-Convension</a></li>\n</ul>","frontmatter":{"title":"Git Commit Message Convention","date":"January 13, 2024","update":"January 13, 2024","tags":["Convention"],"series":"Convention"},"fields":{"slug":"/git-commit-message-convention/","readingTime":{"minutes":12.7}}},"seriesList":{"edges":[{"node":{"id":"87ce0363-7809-5fe5-9b25-1ea48dca5ac0","fields":{"slug":"/git-commit-message-convention/"},"frontmatter":{"title":"Git Commit Message Convention"}}}]},"previous":{"fields":{"slug":"/critical-sections/"},"frontmatter":{"title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)"}},"next":{"fields":{"slug":"/string-pool/"},"frontmatter":{"title":"Java String VS new String()"}}},"pageContext":{"id":"87ce0363-7809-5fe5-9b25-1ea48dca5ac0","series":"Convention","previousPostId":"5b170048-19c5-52bc-a04f-ee873065efe3","nextPostId":"ecfe87a1-1d8f-5a61-be30-0ad263121710"}},"staticQueryHashes":[]}