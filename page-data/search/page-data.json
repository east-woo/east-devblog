{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"회사 직원과 토이프로젝트를 AWS를 사용하여 배포할려고 하였다. (feat. 프리티어) 하지만 과금되어서 이처럼 글로 적어본다. 1. USD 0.095 per GB-month of backup storage exceeding free allocation ‘GB당 0.095달러의 백업 스토리지가 무료 할당을 초과합니다’라는 말과 함께 과금되었다.  이유 인…","fields":{"slug":"/aws-billing-1/"},"frontmatter":{"date":"February 15, 2024","title":"AWS 과금 (RDS)","tags":["AWS","RDS","프로젝트 삽질"]},"rawMarkdownBody":"\r\n\r\n![AWS 과금 목록표](img.png)\r\n\r\n회사 직원과 토이프로젝트를 AWS를 사용하여 배포할려고 하였다. (feat. 프리티어)\r\n\r\n하지만 과금되어서 이처럼 글로 적어본다.\r\n\r\n## 1. USD 0.095 per GB-month of backup storage exceeding free allocation\r\n\r\n**‘GB당 0.095달러의 백업 스토리지가 무료 할당을 초과합니다’**라는 말과 함께 과금되었다.\r\n\r\n![USD 0.095 per GB-month of backup storage exceeding free allocation](img_1.png)\r\n\r\n### 이유\r\n\r\n인터넷에서 찾아보니\r\n\r\n![백업스토리지 - 스냅샷](img_2.png)\r\n\r\n지금은 지워서 없지만, RDS의 DB인스턴스를 지우고 나서 **스냅샷**인가 남아있어서 과금되었다…. ㅠㅠ (RDS 백업에 대한 요금이라는데,,)\r\n\r\n다음에는 DB인스턴스 지우고나서 스냅샷에 남아있는지 확인 해야할 것 같다.. ㅠㅠ\r\n\r\n## 2. $0.005 per In-use public IPv4 address per hour\r\n\r\n가장 많이 과금된 **‘$0.005 per In-use public IPv4 address per hour’ → ‘사용 중인 공용 IPv4 주소당 시간당 $0.005’** 이라는 항목으로 과금되었다… 😭\r\n\r\n각종 Velog, 블로그들을 찾아가며, DB인스턴스를 구성했는데 과금이라니;;\r\n\r\n사실 얼마 하지도 않지만,, 그냥 궁금한 마음에 AWS고객센터에 메일을 보내서 확인 해보았다.\r\n\r\n![지원센터 -> 영어 질문](img_3.png)\r\n\r\n### 이유\r\n\r\n일단 2024년 2월 1일부로 요금 정책이 바뀐 것을 확인 할 수 있다.\r\n\r\n해당 내용은 **[https://aws.amazon.com/ko/blogs/korea/new-aws-public-ipv4-address-charge-public-ip-insights/](https://aws.amazon.com/ko/blogs/korea/new-aws-public-ipv4-address-charge-public-ip-insights/)** 여기에서 확인 가능하다.\r\n\r\n![Public IPv4](img_4.png)\r\n\r\n![Public IPv4 비용](img_5.png)\r\n\r\n고객센터 문의 결과는 **EC2에 대해선 750시간 ‘Public IPv4’를 지원하지만, RDS는 지원하지 않는다는 답변이였다!!!!**\r\n\r\n원래는 DB를 datagrip를 연결하여, ‘격자-위경도’ 엑셀 데이터를 DB에 import 할 생각에 퍼블릭으로 설정해놨었다. 대략 아래 같은 아키텍쳐이다.\r\n\r\n![기존 아키텍처](img_6.png)\r\n\r\n하지만 EC2 인스턴스에 대해서는 **‘Public IPv4’**를 지원하기 때문에 아래처럼 아키텍처를 변경하였다.!! 🙉\r\n![바뀐 아키텍처](img_7.png)\r\n\r\n### 결론\r\n> - RDS 인스턴스 삭제 후 스냅샷도 남아있는지 확인\r\n> - EC2를  Bastion Host 처럼 활용 <br> (단, 사용시 RDS, EC2는 같은 VPC안에 소속되어 있지만, EC2가 RDS에 접속하려면 security group을 통해 허용되어야 한다!)\r\n"},{"excerpt":"1. String Java의 String은 불변입니다. 즉, 일단 생성된 값은 변경할 수 없습니다.  \n'String'을 수정하는 것처럼 보이는 작업을 수행할 때마다 실제로는 새로운 'String' 개체를 생성하는 것입니다. 특성 Immutable(불변): String 객체가 생성되면 해당 값을 변경할 수 없습니다. Thread-safe(스레드로부터 안전…","fields":{"slug":"/string-stringBuffer-stringBuilder/"},"frontmatter":{"date":"January 14, 2024","title":"String & StringBuffer & StringBuilder 차이","tags":["JAVA"]},"rawMarkdownBody":"\r\n## 1. String\r\n > **Java의 String은 불변입니다. 즉, 일단 생성된 값은 변경할 수 없습니다.** <br> \r\n > 'String'을 수정하는 것처럼 보이는 작업을 수행할 때마다 실제로는 새로운 'String' 개체를 생성하는 것입니다.\r\n\r\n```java\r\npublic class StringExample {\r\n    public static void main(String[] args) {\r\n        String str1 = \"Hello\";\r\n        String str2 = \"World\";\r\n\r\n        // Concatenation creates a new String object\r\n        String result = str1 + \", \" + str2;\r\n\r\n        System.out.println(result); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class StringExample {\r\n    public static void main(String[] args) {\r\n        \r\n        String str1 = \"Hello\";\r\n        System.out.println(\"str1 address: \" + System.identityHashCode(str1));\r\n        //   str1 address: 81628611\r\n        \r\n        str1=\"World\";\r\n        System.out.println(\"str1 address: \" + System.identityHashCode(str1));\r\n        //   str1 address: 1072408673\r\n        \r\n        String str2 = \"Hello\";\r\n        System.out.println(\"str2 address: \" + System.identityHashCode(str2));\r\n        //    str2 address: 81628611\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 특성\r\n- **Immutable(불변)**: String 객체가 생성되면 해당 값을 변경할 수 없습니다.<br>\r\n- **Thread-safe(스레드로부터 안전함)**: String 객체는 불변이기 때문에 데이터 손상 위험 없이 여러 스레드 간에 안전하게 공유될 수 있습니다.<br>\r\n- **Slower Concatenation(느린 연결)**: '+' 연산자를 사용하여 문자열을 연결하는 것은 비효율적일 수 있습니다. 특히 루프에서는 매번 새 개체가 생성되므로 비효율적일 수 있습니다.<br>\r\n- **사용 사례**: <br>\r\n  - 문자열의 값이 자주 변경되지 않을 것으로 예상되는 경우. 스레드 안전성이 중요한 상황.\r\n\r\n## 2. StringBuffer\r\n   > StringBuffer도 시퀀스의 문자를 나타내도록 설계되었지만 String과 달리 변경할 수 있습니다. \r\n   > 즉, 새 개체를 만들지 않고도 StringBuffer 개체의 내용을 수정할 수 있습니다.\r\n\r\n```java\r\npublic class StringBufferExample {\r\n    public static void main(String[] args) {\r\n        StringBuffer buffer = new StringBuffer(\"Hello\");\r\n\r\n        // Modifying StringBuffer\r\n        buffer.append(\", \").append(\"World\");\r\n\r\n        System.out.println(buffer.toString()); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n\r\n### 특성\r\n- **Mutable(변경 가능)**: 새 객체를 생성하지 않고도 StringBuffer의 내용을 수정할 수 있습니다.\r\n- **Thread-safe(스레드로부터 안전함)**: StringBuffer 메소드가 동기화되어 멀티 스레드 환경에서 사용하기에 안전합니다.<br>\r\n- **Slower performance(느린 성능)**: 동기화로 인해 StringBuffer 작업은 StringBuilder 작업보다 느립니다.<br>\r\n- **사용 사례**:<br>\r\n  - 스레드 안전성이 요구되는 멀티스레드 환경에서. 문자열에 대한 동적 수정이 필요한 경우.\r\n\r\n## 3. StringBuilder\r\n   > StringBuilder는 변경 가능한 문자 시퀀스를 나타낸다는 점에서 StringBuffer와 유사합니다. \r\n   > 그러나 StringBuffer와는 달리 동기화되지 않으므로 단일 스레드 환경에서 더 빠릅니다.\r\n\r\n```java\r\npublic class StringBuilderExample {\r\n    public static void main(String[] args) {\r\n        StringBuilder builder = new StringBuilder(\"Hello\");\r\n\r\n        // Modifying StringBuilder\r\n        builder.append(\", \").append(\"World\");\r\n\r\n        System.out.println(builder.toString()); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n### 특성\r\n- **Mutable(변경 가능)**: StringBuffer와 마찬가지로 새 객체를 생성하지 않고도 StringBuilder의 내용을 수정할 수 있습니다.\r\n- **Not thread-safe(스레드 안전하지 않음)**: StringBuffer와 달리 StringBuilder 메서드는 동기화되지 않으므로 멀티 스레드 환경에서 사용하기에 적합하지 않습니다.\r\n- **Faster performance(더 빠른 성능)**: 'StringBuilder'는 동기화 부족으로 인해 'StringBuffer'보다 빠릅니다.\r\n- **사용 사례**:\r\n  - 스레드 안전성이 문제가 되지 않는 단일 스레드 환경에서. 문자열에 대한 동적 수정이 필요하고 성능이 중요한 경우.\r\n\r\n## 결론\r\n![img.png](img.png)\r\n\r\n### String 을 사용해야 할 때 :\r\n- String은 불변성\r\n- 문자열 연산이 적고 변하지 않는 문자열을 자주 사용할 경우\r\n- 멀티쓰레드 환경일 경우 \r\n\r\n\r\n### StringBuilder 를 사용 해야 할 때 :\r\n- StringBuilder는 가변성\r\n- 문자열의 추가, 수정, 삭제 등이 빈번히 발생하는 경우\r\n- 동기화를 지원하지 않아, 단일 쓰레드이거나 동기화를 고려하지 않아도 되는 경우\r\n- 속도면에선 StringBuffer 보다 성능이 좋다.\r\n- 더 나은 성능을 갖춘 단일 스레드 환경에서 변경 가능한 문자열이 필요한 경우 'StringBuilder'를 선택\r\n\r\n### StringBuffer 를 사용해야 할 때 :\r\n- StringBuffer는 가변성\r\n- 문자열의 추가, 수정, 삭제 등이 빈번히 발생하는 경우\r\n-  스레드 안전성이 중요한 경우 'StringBuffer'를 선택\r\n- 동기화를 지원하여, 멀티 스레드 환경에서도 안전하게 동작\r\n<br>\r\n\r\n## 참고사항\r\n![img_1.png](img_1.png)\r\n\r\n 사실 <span style=\"color:orange\"> 자바는 문자열에 + 연산을 사용하면, 컴파일 전 내부적으로 StringBuilder 클래스를 만든 후 다시 문자열로 돌려준다고 한다.</span>\r\n\r\n즉, \"hello\" + \"world\" 문자열 연산이 있다면 이는 new StringBuilder(\"hello\").append(\"world\").toString() 과 같다는 말이다.\r\n\r\n```java\r\n    String a = \"hello\" + \"world\";\r\n\r\n    /* 는 아래와 같다. */\r\n    String a = new StringBuilder(\"hello\").append(\"world\").toString();\r\n// StringBuilder를 통해 \"hello\" 문자열을 생성하고 \"world\"를 추가하고 toString()을 통해 String 객체로 변환하여 반환Copy\r\n```\r\n\r\n이처럼 겉으로는 보기에는 문자열 리터럴로 + 연산하거나, StringBuilder 객체를 사용하거나 어차피 자동 변환해줘서 차이가 없어 보일지도 모른다.<br>\r\n하지만 다음과 같이 문자열을 합치는 일이 많을 경우 단순히 + 연산을 쓰면 성능과 메모리 효율이 떨어지게 된다.\r\n``` java\r\n\r\n    String a = \"\";\r\n    \r\n    for(int i = 0; i < 10000; i++) {\r\n        a = a + i;\r\n    }\r\n    \r\n    /* 위의 문자열 + 연산 식은 결국 아래와 같다. */\r\n    /* 즉, 매번 new StringBuilder() 객체 메모리를 생성하고 다시 변수에 대입하는 멍청한 짓거리를 하고 있는 것이다. */\r\n    \r\n    String a = \"\";\r\n    \r\n    for(int i = 0; i < 10000; i++) {\r\n        a = new StringBuilder(b).append(i).toString();\r\n    }\r\n```\r\n\r\n\r\n#### 📖 참고문헌 📖\r\n- https://inpa.tistory.com/entry/JAVA-☕-String-StringBuffer-StringBuilder-차이점-성능-비교#문자열_자료형_비교_총정리\r\n"},{"excerpt":"REST API란? 💡 REST는 Representational State Transfer의 약자로, 웹에서 데이터를 전송하고 처리하는 방법을 정의한 하나의 인터페이스를 말한다. \nREST API의 개략적인 구조(출처 : cloudinary) REST API 6가지 특징 무상태(Statelessness): 클라이언트에서 서버로의 각 요청은 해당 요청을 이…","fields":{"slug":"/rest-api-url-naming/"},"frontmatter":{"date":"January 14, 2024","title":"REST API 설계 및 명명규칙","tags":["REST API"]},"rawMarkdownBody":"\r\n## REST API란?\r\n\r\n> 💡 REST는 Representational State Transfer의 약자로, 웹에서 데이터를 전송하고 처리하는 방법을 정의한 하나의 인터페이스를 말한다.\r\n\r\n\r\n![img.png](img.png)\r\nREST API의 개략적인 구조(출처 : cloudinary)\r\n\r\n## REST API 6가지 특징\r\n\r\n1. **무상태(Statelessness):** 클라이언트에서 서버로의 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다. 서버는 요청 사이에 클라이언트 상태에 대한 정보를 저장해서는 안 됩니다.\r\n2. **클라이언트-서버 아키텍처:** 클라이언트와 서버는 네트워크를 통해 통신하는 별개의 엔터티입니다. 클라이언트는 사용자 인터페이스와 사용자 경험에 책임을 지고, 서버는 요청을 처리하고 리소스를 관리합니다.\r\n3. **일관된 인터페이스:** 아키텍처를 단순화하고 분리하는 일련의 제약 조건입니다. 일관된 인터페이스는 URI(Uniform Resource Identifier)를 통한 리소스 식별, 표현을 통한 리소스 조작, 표준 HTTP 메서드(GET, POST, PUT, DELETE) 사용 등의 원칙을 포함합니다.\r\n4. **리소스 중심:** 리소스(데이터 객체 또는 서비스와 같은)는 URI에 의해 식별되며 표준 HTTP 메서드를 사용하여 조작됩니다.\r\n5. **표현(Representation):** 리소스는 여러 표현(JSON 또는 XML과 같은)을 가질 수 있으며 클라이언트는 서버와 표현을 협상할 수 있습니다.\r\n6. **무상태 통신(Stateless Communication):** 클라이언트에서 서버로의 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다. 서버는 요청 사이에 클라이언트 상태를 저장하지 않습니다.\r\n7. **무상태 서버(Stateless Server):** 서버는 클라이언트 상태를 저장하지 않습니다. 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함합니다.\r\n8. **캐시 가능성(Cacheability):** 서버에서의 응답은 명시적으로 캐시 가능하거나 캐시 불가능하게 표시될 수 있어 클라이언트가 응답을 캐시하여 성능을 향상시킬 수 있습니다.\r\n9. **계층화된 시스템(Layered System):** 아키텍처는 여러 계층(프록시, 게이트웨이 및 방화벽과 같은)으로 구성될 수 있어 시스템의 확장성과 보안을 향상시킬 수 있습니다.\r\n\r\n## **REST API를 잘 작성하기 위한 15가지 방법**\r\n\r\n### **1. 엔드포인트 경로에는 명사를 사용**\r\n\r\n**검색하거나 조작하는 엔터티를 나타내는 명사를** 항상 경로 이름으로 사용해야 하며 항상 **복수형** 지정을 사용하는 것이 좋다. **HTTP 요청 메서드** 에 이미 동사가 있고 실제로 새 정보를 추가하지 않으므로 엔드포인트 경로에 동사를 지양해야한다.\r\n\r\n작업은 우리가 만들고 있는 HTTP 요청 메서드로 표시되어야 함. \r\n가장 일반적인 방법은 GET, POST, PATCH, PUT 및 DELETE이다.\r\n\r\n![img_1.png](img_1.png)\r\n\r\n\r\n> 💡 **HTTP 요청메소드**\r\n> - GET은 리소스를 검색합니다.\r\n> - POST는 새 데이터를 서버에 제출합니다.\r\n> - PUT/PATCH는 기존 데이터를 업데이트합니다.\r\n> - DELETE는 데이터를 제거합니다.\r\n> - HEAD: GET과 동일하지만 응답 본문이 없습니다. 리소스의 헤더만 검색하는 데 사용됩니다.\r\n> - TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행하는 데 사용됩니다.\r\n> - OPTIONS: 대상 리소스에 대한 통신 옵션을 설명하는 데 사용됩니다.<br/>\r\n>   브라우저는 서버의 CORS 헤더를 확인하기 위해 실행 전 요청\r\n> - CONNECT: 동적으로 터널로 전환할 수 있는 프록시와 함께 사용하도록 예약되어 있습니다. 네트워크 터널을 설정하는 데 사용됩니다.\r\n\r\n\r\n1. GET /members\r\n2. GET /get-members\r\n\r\n위에서 권장한 방법대로라면, 1번이 옳은 것. 이미 GET이라는 HTTP 메소드가 해당 API의 역할을 충분히 설명하고 있기 때문에, 마지막 경로에 동사를 넣게 되면 중복된 설명이 된다.\r\n\r\n해당 방법으로 HTTP 요청 메소드를 보면 아래처럼 예시를 보여줄 수 있다.\r\n\r\n\r\n> 💡 회원 목록 /members -> GET<br/>\r\n> 회원 등록 /members -> POST<br/>\r\n> 회원 조회 /members/{id} -> GET<br/>\r\n> 회원 수정 /members/{id} -> PATCH, PUT, POST<br/>\r\n> 회원 삭제 /members/{id} -> DELETE<br/>\r\n\r\n\r\n\r\n### 2. 데이터 송수신 포멧으로는 JSON을 사용하자.\r\n\r\n예전에는 XML을 이용했지만, 최근에는 JSON(JavaScript Object Notation)가 API 데이터 송수신 표준 형식이 되었다.\r\n\r\nJSON의 장점을 간략하게 설명하면 다음과 같다.\r\n\r\n- 인간이 읽을 수 있는 텍스트로, 사용이 편리함\r\n- 최소한의 정보를 함축적으로 표현(XML에 비해 적은 용량으로 빠르게 통신 가능)\r\n- 언어에 독립적\r\n\r\n일반적으로 제공되는 form-data는 클라이언트가 텍스트 또는 숫자 형식의 데이터를 보낼 때는 적합하지 않고, 어차피 대부분의 프레임워크에서 클라이언트가 데이터를 전송할 때 JSON을 사용할 수 있도록 기능을 제공하고 있다. 간단하게 헤더의 Content-Type 부분을 application/json으로 설정하기만 하면 된다.\r\n\r\n### 3. HTTP 상태코드를 적극적으로 활용하자.\r\n\r\nHTTP에는 이미 수많은 사람들이 사용하고 있는 상태 코드들이 정의되어 있다. API 처리가 정상적으로 이루어졌는지, 혹 아니라면 무슨 이유인지 명확하게 표현하기에 가장 적합하다.\r\n\r\n상태 코드에는 대표적으로 아래와 같은 종류가 있다.\r\n\r\n\r\n> 💡 **대표적인 상태 코드**\r\n> - 200 : 클라이언트의 요청이 정상적으로 수행되었음\r\n> - 201 : 클라이언트가 생성과 관련된 요청을 하였고, 이 요청이 정상적으로 완료됨(POST)\r\n> - 301 : 클라이언트가 요청한 데이터의 URI가 변경되었을 경우\r\n> - 400 : 클라이언트의 요청이 부적절한 경우\r\n> - 401 : 클라이언트가 인증과정(로그인 등)을 거치지 않은 상태에서 보안된 데이터에 접근하려고 하는 경우\r\n> - 403 : 클라이언트가 인증과 관련 없이, 존재는 하지만 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 X)\r\n> - 404 : 클라이언트가 인증과 관련 없이, 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 O)\r\n> - 405 : 클라이언트가 요청한 데이터에 해당 메소드가 존재하지 않거나 사용 불가능 상태인 경우\r\n> - 500 : 서버에 문제가 있을 경우\r\n\r\n\r\n이 외에도 수많은 상태 코드들이 있는데, 중요한 것은 ‘가장 최소한의 개수를 사용’하여 클라이언트가 API 요청 또는 응답에 적절한 상태 코드를 부여할 수 있도록 하는 것이다.\r\n\r\n### 4. 응답 메시지는 표준화 된 내용으로 반환하자.\r\n\r\n어떠한 요청에 대한 데이터라 하더라도, 서버로부터 항상 유사한 형태의 표준화된 응답 구조를 사용해야 한다. 그렇게 해야 클라이언트는 동일한 구조 내에서 원하는 값을 예측해서 가져올 수 있게 된다. 만약 아래와 같은 구조가 존재한다고 하자.\r\n\r\n```json\r\n[\r\n  {\r\n     bookId: 1,\r\n     name: \"The Republic\"\r\n  },\r\n  {\r\n     bookId: 2,\r\n     name: \"Animal Farm\"\r\n  }\r\n]\r\n```\r\n\r\n또는 아래와 같이 조금 더 중첩된 구조를 가질 수도 있다\r\n\r\n```json\r\n{\r\n   \"data\": [ \r\n     {\r\n       \"bookId\": 1,\r\n       \"name\": \"The Republic\"\r\n     },\r\n     {\r\n       \"bookId\": 2,\r\n       \"name\": \"Animal Farm\"\r\n     }\r\n   ],\r\n   \"totalDocs\": 200,\r\n   \"nextPageId\": 3\r\n}\r\n```\r\n\r\n만약 새로운 책을 추가한다고 하자. 성공했을 경우 권장하는 응답 메시지는 아래와 같다.\r\n\r\n```json\r\n// POST /books\r\n{\r\n     \"bookId\": 3,\r\n     \"name\": \"Toy Story\"\r\n}\r\n```\r\n\r\n만약 여기서 ‘책이 성공적으로 등록되었습니다’ 라는 메시지를 추가하면 어떨까? 답은 ‘불필요하다’이다. 우리는 위에서 상태코드를 통해 해당 요청이 정상적으로 완료되었는지 혹은 문제가 생겼는지를 확인하자고 했다. 추가적인 메시지는 중복된 내용을 포함하는 꼴만 만들게 된다.\r\n\r\n오히려 문제가 발생한 경우에 대해서는 무슨 오류가 있었는지에 대한 메시지를 적어주는 것이 좋다. 그렇게 해야 클라이언트가 해당 문제를 빠르게 확인하고 조치를 취할 수 있기 때문이다. 아래와 같은 응답이 적절한 예시가 될 수 있을 것이다.\r\n\r\n```json\r\n{\r\n  \"code\": \"book/not_found\",\r\n  \"message\": \"A book with the ID 6 could not be found\"\r\n}\r\n```\r\n\r\n응답 메시지에 HTTP 상태 코드를 포함할 필요까지는 없지만, 그래도 사용자 또는 클라이언트가 해당 오류에 대해 빠르게 확인할 수 있도록 오류를 매핑한 코드와 이를 간략하게 설명한 메시지 정도는 정의해두는 것이 좋다. 물론 운영환경에서는 불필요한 보안 정보를 노출하게 될 수 있기 때문에, 개발 단계에서만 이를 노출하는 것이 좋다.\r\n\r\n### **5. 페이징 기법을 활용하여 컬렉션으로 받은 많은 데이터를 효율적으로 처리하자.**\r\n\r\n데이터가 많아질수록, 데이터를 어떻게 반환해서 보여줄지가 굉장히 중요해진다. 위에서 정의한 API 중, 등록된 전체 책의 개수를 반환하려고 한다고 가정하자. 책의 개수가 적을 때는 문제가 없겠지만, 수백만권 혹은 수천만권의 책이 있다고 한다면 해당 API를 호출하는 것은 성능이나 대역폭 측면에서 좋지 못한 선택이 될 수 있다.\r\n\r\n페이징 기법(Pagination)을 사용하는 방법으로는 크게 skip, limit 또는 keyset이 있다. 일반적으로 skip, limit을 사용하지만, 페이징 기법을 위해서라도 keyset을 사용하는 것을 권장한다.\r\n\r\n\r\n> - skip : 출력할 데이터의 시작부분을 설정한다. 입력값으로 들어온 값 + 1부터 출력한다.\r\n> - limit : 출력할 데이터의 개수를 제한한다. 입력값으로 들어온 값 만큼만 반환한다.\r\n> - keyset : 식별자 또는 ID를 참조 값으로 받아서 테이블을 별도로 스캔하지 않고 조건에 맞게 페이징하여 반환한다.\r\n\r\n\r\n추가로 API의 결과 값을 필터링 또는 정렬할 수 있는 기능도 필요하다. 성능을 향상시키기 위해 DB 인덱스에 접근(Access) 패턴을 적용하기도 하는데, 결론적으로 API 호출에 필요한 필터와 정렬은 쿼리 파라미터에 정의되어야 한다.\r\n\r\n```json\r\n# romance 범주에 속하는 책 10권을 조회한다고 가정하는 API\r\nGET /books?limit=10&category=romance\r\n```\r\n\r\n### **6. PUT 보다는 PATCH를 사용하자.**\r\n\r\nPUT과 PATCH의 가장 큰 차이는 ‘데이터 내에 변경되는 요소의 범위’이다.\r\n\r\n- PUT : 데이터 내 모든 요소를 수정\r\n- PATCH : 데이터 내 요소 중 일부만 수정\r\n\r\n일반적으로 데이터 내에 있는 모든 요소를 한번에 변경하는 일은 거의 발생하지 않는다. 추가로 의도하지 않게 변경해서는 안되는 요소마저도 변경될 소지가 존재한다. 그렇기 때문에 되도록이면 PATCH를 권장하며, PUT을 절대 사용해서는 안되는 것은 아니다.\r\n\r\n### 7. Extended 옵션을 사용해서 선택적으로 결과 값을 반환하자.\r\n\r\n시스템이 커질수록 데이터 내 요소들도 증가할 수 밖에 없다. 문제는 모든 클라이언트에서도 증가한 요소들을 전부 사용하진 않는다는 것이다.\r\n\r\n이를 해결하기 위해 extended라는 옵션을 사용한다. 아래는 extended 옵션의 유무에 따른 결과 값의 차이를 보여준다.\r\n\r\n```json\r\nGET /books/:id\r\n{\r\n   \"bookId\": 1,\r\n   \"name\": \"Harry Potter\"\r\n}\r\nGET /books/:id?extended=true\r\n{\r\n   \"bookId\": 1,\r\n   \"name\": \"Harry Potter\"\r\n   \"tags\": [\"fantasy\", \"magic\", \"UK\"],\r\n   \"author\": {\r\n      \"id\": 1,\r\n      \"name\": \"J.K.Rowling\"\r\n   }\r\n}\r\n```\r\n\r\n### 8. 적절하게 엔드포인트의 크기를 나눠주자.\r\n\r\nAPI의 기본 사상은 ‘주어진 하나의 일을 잘 수행하자’ 이다. 한번에 여러 작업을 해결할 수 있는 것 보다, 한 눈에 사용 가능한 기능을 확인할 수 있는 작은 단위의 API 설계가 중요하다(어찌보면 books이라는 엔드포인트는 어떻게보면 굉장히 큰 단위일 수 있다). 그리고 이러한 작은 단위의 API를 적절하게 통합하여 클라이언트가 쉽게 기능을 예측하고 이해할 수 있도록 돕는 것이 좋다.\r\n\r\n### 9. 정확한 API 문서를 제공하자.\r\n\r\nAPI의 궁극적인 목적은 ‘클라이언트가 원하는 기능을 한눈에 알아보고 적절하게 프로그램 상에 배치해서 기능을 수행할 수 있도록 하는 것’이다. 이를 위해서는 API에 대해 잘 정리된 문서가 중요하다.\r\n\r\n문서에는 각 엔드포인트의 목적과 이를 실행하기 위한 권한, 호출하였을 때의 응답 예시, 그리고 실패하였을 때의 오류 메시지가 꼭 명시되어야 한다. 그리고 API의 버전이 변경됨에 따라 내부 기능의 변화 과정을 문서에 꼭 작성해야 한다. 기본적으로 Swagger와 같이 API의 개발과 문서 작성을 동시에 해주는 도구가 있다. 혹은 Postman으로 API를 테스트하고, 이를 문서화 된 파일로 저장해주는 도구도 존재한다.\r\n\r\n### 10. 보안을 위한 기능을 꼭 적용하자.\r\n\r\n가장 일반적인 방법으로 SSL을 서버에 적용하면, 클라이언트-서버 간 안전한 통신을 보장하면서 잠재적으로 발생 가능한 공격을 막을 수 있다.\r\n\r\n웹 상에서는 Origin이라는 개념이 존재하는데, 이는 URL 상에서 프로토콜, 도메인, 포트 번호를 합친 부분을 말한다. 접속중인 웹사이트의 Origin은 window.location.origin 명령어를 통해 확인할 수 있다.\r\n\r\n웹 브라우저는 보안 때문에 같은 Origin끼리 통신할 수 있도록 하는 SOP(Same Origin Policy)와 다른 Origin으로도 요청을 보낼 수 있도록 예외를 허용하는 CORS(Cross Origin Resource Sharing) 정책이 존재한다. API의 특성 상 서로 다른 Origin 간 통신은 당연히 발생하기 때문에, CORS를 이용하여 적절하게 HTTP 통신을 제한할 수 있는 기능을 지원해야 한다.\r\n\r\nCORS 프로토콜은 브라우저가 사전 요청(preflight request)을 서버에 보내고, 이를 승인 받은 경우에만 통신할 수 있도록 한다. 이 사전 요청은 HTTP 요청 중 OPTION 메소드를 사용하는데, 이를 위해서는 아래의 사항을 선택적으로 응답 헤더에 넣어야 한다.\r\n\r\n\r\n> 💡 **응답헤더**\r\n>  - Access-Control-Allow-Origin: *\r\n>  - Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE\r\n>  - Access-Control-Allow-Headers: Content-Type, Authorization\r\n\r\n\r\n### 11. API 버전을 명시하자.\r\n\r\n개발 과정이 되었든 운영 중에 API 엔드포인트를 변경하거나 내부 구조를 변경하였든, API와 관련된 어느것이라도 변경이 발생하였다면 이를 버전화해야 한다. 클라이언트가 모르는 상태로 갑자기 API의 엔드포인트를 변경해서는 안된다. API는 어떠한 변경이 발생하더라도, 이전의 통신 상태에까지 영향을 주어서는 안된다. 즉, 기존의 방법대로 통신하는 어플리케이션이 하나라도 존재한다면, 해당 기능을 임의대로 정지해서는 안된다.\r\n\r\n\r\n> 1. 헤더에 추가: \"x-version=v2\"\r\n> 2. 파라미터에 추가: \"?apiVersion=2\"\r\n> 3. URL에 포함:  \"/v2/books/:id\"\r\n\r\n\r\n### 12. 캐시 데이터를 사용해서 성능을 향상시키자.\r\n\r\n빈번하게 사용되면서 동시에 변경이 거의 발생하지 않는 데이터는 캐싱하는 것이 좋다. 인메모리(in-memory) 또는 캐시 데이터베이스(cached-database)를 이용하는 것이 메인 데이터베이스를 접근하는 것보다 훨씬 좋은 성능을 보인다.\r\n\r\n다만 캐싱된 데이터의 경우 만료기간이 존재할 수 있기 때문에, 적절한 시기에 이를 업데이트 할 수 있도록 구현하는 것이 중요하다. 캐시된 데이터를 사용할 때에는 반드시 HTTP 헤더에 Cache-Control를 포함해야 한다.\r\n\r\n### 13. 표준 UTC를 사용하자.\r\n\r\nAPI는 시간 또는 공간에 상관없이 어디에서나 호출될 수 있다. 그렇기 때문에 동일한 날짜 표준 방식을 통해 일관성 있는 출력을 보여줄 필요가 있다. ISO8601은 날짜/시간 데이터의 국제 표준 방식으로, 날짜는 Z 또는 UTC 형식이어야 한다.\r\n\r\n```json\r\n{\r\n    \"createdAt\": \"2022-03-08T19:15:08Z\"\r\n}\r\n```\r\n\r\n### 14. 주기적인 헬스체크를 해주자.\r\n\r\nAPI에 문제가 생겨서 시스템을 정지해야 할 경우, 해당 API는 어쩔 수 없이 복구가 될 때까지는 사용이 불가능하다. 이를 위해 API 호출 시점에 해당 API가 정상적으로 사용 가능한지 확인할 수 있는 헬스체크(Health-check) 시스템이 엔드포인트 상에 적용되어야 한다.\r\n\r\n`GET /health`\r\n\r\n일반적으로 이러한 헬스체크 기능은 로드밸런서 등에서 호출될 수 있으며, API의 동작 여부 뿐만 아니라 유지 보수 기간에 대한 개략적인 기준을 제시할 수도 있다.\r\n\r\n### 15. API Key 인증을 허용하자.\r\n\r\nAPI Key로 인증하게 되면, 3rd party 어플리케이션에서 해당 API를 손쉽게 사용하도록 만들 수 있다. 이를 위해서는 X-Api-Key 또는 Api-Key와 같은 커스텀 HTTP 헤더를 사용해야 한다. 특히 Key의 사용 기한을 정해서 만료일이 있도록 해야 보안상 문제가 발생하였을 경우 이를 무효화할 수 있다는 것을 염두하자.\r\n\r\n\r\n> 💡 참고 문헌\r\n> - https://medium.com/@liams_o/15-fundamental-tips-on-rest-api-design-9a05bcd42920\r\n> - https://restfulapi.net/rest-api-design-tutorial-with-example/\r\n> - https://wnjoon.github.io/2022/11/08/swe-restapi_design/\r\n\r\n"},{"excerpt":"❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.  git flow 전략  1. Git 커밋 메시지란 무엇인가요? Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. \n이는 프로젝트 이력에 대한 문서…","fields":{"slug":"/git-commit-message-convention/"},"frontmatter":{"date":"January 13, 2024","title":"Git Commit Message Convention","tags":["Convention"]},"rawMarkdownBody":"\r\n> ❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.\r\n\r\n **git flow 전략** \r\n - \r\n\r\n## 1. Git 커밋 메시지란 무엇인가요?\r\n   - Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. <br>\r\n   이는 프로젝트 이력에 대한 문서 역할을 하며, 특정 변경이 이루어진 이유에 대한 통찰력을 제공하고 공동 작업자가 시간에 따른 코드베이스의 발전을 더 쉽게 이해하고 추적할 수 있도록 해줍니다.\r\n\r\n## 2. Git 커밋 메시지 규칙의 중요성\r\n### 2.1 Git 커밋 메시지 규칙은 무엇인가요?\r\n   - Git 커밋 메시지 규칙은 커밋 메시지를 작성하는 일관되고 표준화된 방법을 정의하는 일련의 지침 또는 규칙입니다. <br>\r\n   여기에는 변경 내용의 성격에 대한 정보를 전달하기 위한 구조화된 형식과 특정 규칙이 포함됩니다.\r\n\r\n### 2.2 Git 커밋 규칙을 따라야 하는 이유\r\n   - 명확성 및 가독성: 일관된 커밋 메시지를 통해 팀 구성원은 각 커밋의 목적과 영향을 더 쉽게 이해할 수 있습니다.\r\n   - 검색 및 탐색: 체계적으로 구성된 커밋 메시지는 버전 기록 검색 기능을 향상시켜 특정 변경 사항을 신속하게 식별하는 데 도움이 됩니다.\r\n   - 자동화 및 도구: 많은 개발 도구 및 플랫폼은 변경 로그 생성 또는 CI/CD 파이프라인 트리거와 같은 자동화된 프로세스에 대한 커밋 메시지 규칙을 활용합니다.\r\n> ⚠️ 커밋 컨벤션을 적용시키지 않아도 겉보기에는 특정 커밋을 보고 충분히 어떤 내용의 커밋인지 충분히 이해할 수 있다고 생각이 들 수 있습니다.  \r\n>  그러나 Commit Message 가 누적될수록 가독성이 매우 떨어집니다.\r\n\r\n## 3. Git 커밋 메시지 작성 방법\r\n```markdown\r\ntype(옵션): [#issueNumber-]Subject   \r\n\r\nbody(옵션)                          \r\n\r\nfooter(옵션)                        \r\n```\r\n### 3.1 기본 형식(Commit Message 구조)\r\n> 기본적으로 커밋 메시지는 **제목/텍스트/바닥글**로 구성합니다.\r\n\r\n### 3.2 타입, 태그\r\n```markdown\r\ntag(옵션): [#issueNumber-]Subject\r\n\r\n---------:> 예시 <:---------\r\n\r\nFeat: 이진법 변환 함수 기능 추가 \r\n```\r\n\r\n- 어떤 의도로 커밋했는지를 type에 명시해야 합니다.\r\n\r\n> - 제목은 \" 태그(tag) + 제목(subject) \" 으로 구성되며, 태그는 영어로 쓰되, 첫 문자는 대문자 로 합니다.\r\n> - \"tag: subject\" 의 형태이며, \":\" 뒤에 space 가 있음에 유의합니다.\r\n\r\n##### 자주 사용하는 태그 종류\r\n- Feat : 새로운 기능을 추가하는 경우\r\n- Fix : 버그를 고친경우\r\n- Docs : 문서를 수정한 경우\r\n- Style : 코드 포맷 변경, 세미콜론 누락, 코드 수정이 없는경우\r\n- Refactor : 코드 리펙토링\r\n- Test : 테스트 코드. 리펙토링 테스트 코드를 추가했을 때\r\n- Chore : 빌드 업무 수정, 패키지 매니저 수정\r\n- Design : CSS 등 사용자가 UI 디자인을 변경했을 때\r\n- Rename : 파일명(or 폴더명) 을 수정한 경우\r\n- Remove : 코드(파일) 의 삭제가 있을 때. \"Clean\", \"Eliminate\" 를 사용하기도 함\r\n\r\n##### 기타 태그 타입들\r\n- Add : 코드나 테스트, 예제, 문서등의 추가 생성이 있는경우\r\n- Improve : 향상이 있는 경우. 호환성, 검증 기능, 접근성 등이 될수 있습니다.\r\n- Implement : 코드가 추가된 정도보다 더 주목할만한 구현체를 완성시켰을 때\r\n- Move : 코드의 이동이 있는경우\r\n- Updated : 계정이나 버전 업데이트가 있을 때 사용. 주로 코드보다는 문서나, 리소스, 라이브러리등에 사용합니다.\r\n- Comment : 필요한 주석 추가 및 변경\r\n\r\n### 3.3 제목\r\n- 제목은 코드의 변경 사항에 대해 짧은 요약을 나타냅니다.<br>\r\n\r\n**영어로 제목을 작성하는 경우**<br>\r\n\r\n```markdown\r\n1. 제목은 50자를 넘기지 않고, 대문자로 작성하며 마침표를 붙이지 않습니다.\r\n2. 제목은 과거형을 사용하지 않고, 명령조로 시작합니다.\r\n   ex) 제목을 Fixed 가 아닌, Fix 로 작성합시다.\r\n( 커밋메시지를 예를들어 Fix : \"Modify album buy bug\" 로 작성하기 )\r\n```\r\n \r\n**한글로 제목을 작성하는 경우**<br>\r\n- \"고침\", \"추가\", \"변경\" 등의 명령조 로 시작합니다.<br>\r\n- ex) Feat: \"추가 get data api 함수\r\n\r\n### 3.4 텍스트(본문)  \r\n- 선택사항이지만 복잡한 변경에는 권장됩니다.\r\n- 부연 설명이 필요하거나 커밋한 이유를 설명할 경우 작성해주면 됩니다.\r\n- 본문 내용은 어떻게 변경했는지 보다, 무엇을 변경했는지 또는 왜 변경했는지를 설명하도록 합시다.\r\n- 텍스트는 추가 세부 정보를 제공하고 컨텍스트를 제공하며 변경이 필요한 이유를 설명합니다. \r\n- 제목은 변경 사항을 간략하게 요약한 것입니다. 50자 이내로 작성해야 하며 명령형으로 작성해야 합니다.\r\n\r\n**예시**\r\n````markdown\r\nFeat: 이진법 변환 함수 기능 추가\r\n\r\n외부 API를 통해 받아온 코드를 16진법에서 2진법을 변환하기 위해 유틸 클래스 생성 및 진법 변환 함수 기능 추가 \r\n\r\n````\r\n\r\n### 3.5 바닥글\r\n- 바닥글에는 문제에 대한 참조나 주요 변경 사항과 같은 모든 메타데이터가 포함됩니다. 또한 선택 사항입니다.<br>\r\n- issue tracker id 를 작성할 때 사용합니다.<br>\r\n- 형식 : 꼬리말은 \"유형: #이슈 번호\" 형식으로 사용합니다.<br>\r\n- 해결된 이슈도 추가하여 줘야합니다.\r\n\r\n\r\n**바닥글에 사용되는 태그들**<br>\r\n\r\n- Closes:<br>\r\n    Example: Closes #123 <br>\r\n    커밋이 특정 문제 번호를 종료. <br>\r\n\r\n- Resolves:<br>\r\n  Example: Resolves #789 <br>\r\n  'Closes' 및 'Fixes'와 마찬가지로 커밋으로 특정 문제가 해결되었음을 나타냅니다.<br>\r\n  \r\n- Fixes:<br>\r\n    Example: Fixes #456<br>\r\n    'Closes'와 유사하며 커밋이 특정 문제를 해결했음을 나타냅니다(아직 해결이 되지 않는 경우)<br>\r\n  \r\n- Breaking Change:<br>\r\n    Example: BREAKING CHANGE: The API endpoint has been deprecated. Update your calls accordingly.<br>\r\n    커밋이 주요 변경 사항을 도입하고 세부 정보를 제공하도록 지정합니다.<br>\r\n\r\n- Signed-off-by:<br>\r\n    Example: Signed-off-by: John Doe <john@example.com><br>\r\n    작성자가 커밋을 승인했음을 나타냅니다. 이는 오픈 소스 프로젝트에서 기여자 동의를 확인하기 위해 자주 사용됩니다.<br>\r\n  \r\n- Reviewed-by:<br>\r\n    Example: Reviewed-by: Reviewer Name <reviewer@example.com><br>\r\n    특정인이 커밋을 검토했음을 나타냅니다.<br>\r\n  \r\n- See also:<br>\r\n    Example: See also: #987<br>\r\n    관련 문제 또는 풀 요청에 대한 참조를 제공합니다.<br>\r\n\r\n- Related:<br>\r\n    Example: Related to: #654<br>\r\n    해당 커밋에 관련된 이슈번호 (아직 해결되지 않은 경우)입니다.<br>\r\n\r\n\r\n## 4. Git 커밋 메시지 자동화 방법\r\n### 4.1. 서버 훅: Git의 push rule 기능 사용하기\r\n> - Git 서버 후크는 특정 이벤트에 대한 응답으로 서버에서 실행되는 스크립트입니다. <br>\r\n> - 특히 'pre-receive' 후크는 업데이트가 저장소에 승인되기 전에 호출됩니다. Git의 푸시 규칙 기능을 활용하면 특정 커밋 메시지 규칙을 적용할 수 있습니다.<br>\r\n\r\n- 도구: Commitizen, Husky<br>\r\n- 위치: 이 도구는 개발자의 로컬 컴퓨터(클라이언트 측)에서 작동합니다.<br>\r\n- 목적: 개발자의 로컬 작업 흐름과 환경을 향상시키는 데 사용됩니다.<br>\r\n- 예: Commitizen은 개발자가 로컬 컴퓨터에서 표준화된 커밋 메시지를 생성하는 데 도움이 됩니다. Husky는 Git 후크를 로컬에서 관리하는 데 도움을 줍니다.<br>\r\n\r\n### 4.2. 클라이언트 훅: 푸시하기 전 미리 검사하기\r\n> - 클라이언트 후크는 개발자가 변경하는 로컬 시스템에서 실행됩니다. <br>\r\n> - 'pre-push' 후크는 'git push' 명령이 실행되기 전에 트리거되어 개발자가 사전 확인을 수행할 수 있도록 합니다.<br>\r\n\r\n- 훅: 예에는 'pre-receive', 'update', 'post-receive'이 포함됩니다.<br> \r\n- 위치: 이 후크는 Git 서버에 설치됩니다.<br>\r\n- 목적: 특정 Git 작업(예: 변경 사항 푸시)이 수행될 때 정책을 시행하고, 작업을 수행하거나, 서버에서 이벤트를 트리거하는 데 사용됩니다.<br>\r\n- 예: '사전 수신' 서버 측 후크는 커밋 메시지 규칙을 적용하거나 푸시를 수락하기 전에 특정 조건을 확인할 수 있습니다.<br>\r\n\r\n\r\n\r\n## 5. Git emojis 사용\r\n- Git emojis는 이모티콘을 사용하여 커밋 메시지를 시각적으로 표현하고 분류하는 방법입니다.<br>\r\n- https://gitmoji.dev/ 에서 참고하여 작성.<br>\r\n- 인텔리제이는 Gitmoji, VS CODE는 Gitmoji Plug-in 지원<br>\r\n- gitmoji-cli를 활용하여 Gitmoji를 터미널에서 바로 적용가능\r\n- 이모티콘은 추가 컨텍스트를 제공하기 위해 기존 커밋 메시지와 함께 사용되는 경우가 많습니다.<br>\r\n\r\n#### 예시\r\n````markdown\r\n   🚀: 새로운 기능\r\n   🐛: 버그 수정\r\n   📚: 문서 업데이트\r\n   ⚙️: 코드 리팩토링\r\n   🚨: 획기적인 변화\r\n````\r\n\r\n## 결론\r\nGit 커밋 메시지 규칙을 따르고 자동화를 활용함으로써 팀은 협업을 간소화하고 깨끗한 버전 기록을 유지하며 전체 프로젝트 문서를 향상시킬 수 있습니다.\r\n\r\n참고 문헌\r\n- https://velog.io/@msung99/Git-Commit-Message-Convension"},{"excerpt":"String 재사용(Interning) new 연산자를 이용한 방식\nnew를 통해 String을 생성하면 Heap 영역에 존재하게 된다. 리터럴을 이용한 방식\nstring constant pool이라는 영역에 존재하게 된다. 해당 코드를 실행하면 객체가 3개가 아니라 2개가 만들어진다. 왜 2개일까? 이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모…","fields":{"slug":"/string-pool/"},"frontmatter":{"date":"January 13, 2024","title":"Java String VS new String()","tags":["JAVA"]},"rawMarkdownBody":"\r\n## String 재사용(Interning)\r\n\r\n> - **new 연산자를 이용한 방식**<br>\r\nnew를 통해 String을 생성하면 Heap 영역에 존재하게 된다.<br>\r\n> - **리터럴을 이용한 방식**<br>\r\nstring constant pool이라는 영역에 존재하게 된다.\r\n\r\n```java\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"Hi\");\r\n        String str2 = \"Hi\";\r\n        String str3 = \"Hi\";\r\n    }\r\n}\r\n```\r\n\r\n해당 코드를 실행하면 **객체가 3개가 아니라 2개**가 만들어진다.\r\n\r\n왜 2개일까?\r\n\r\n이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모리 구조상에서 차이가 발생한다.\r\n\r\nString은 다른 객체들에 비해 광범위하고, 빈번하게 사용되므로 String을 사용할 때마다 객체를 생성하는 방식으로 사용하게 된다면, 새로운 객체를 계속 만들어내는 것이기 때문에 **메모리 관리 측면에서 비효율적**이다.\r\n이러한 String을 효율적으로 관리하기 위해, Heap 메모리영역 속에 <span style=\"color:blue\"> **String Constant Pool** </span>을 만들었다.\r\n이곳에는 생성된 문자열의 값을 보관하고 있으며, 리터럴””로 생성된 같은 값을 가지는 객체는 같은 레퍼런스(참조값, 주소)를 가지게 된다.\r\n\r\n![img.png](img.png)\r\n\r\n위 코드에서는 new String 연산자로 생성된 객체(Heap 메모리 영역에 저장), 그리고 리터럴로 생성된 객체(String Pool에 저장), 총 2개의 객체가 생성되는 것이다.\r\n\r\nJava에서 String은 불변(immutable) 객체입니다. 이 덕분에 JVM은 String Constant Pool에 각 문자열 리터럴의 복사본을 하나만 저장하여, 문자열에 할당되는 메모리 양을 최적화할 수 있습니다.\r\n그리고 해당 과정을 재사용(Interning)이라고 합니다.\r\n<br>\r\nString 변수를 만들고 값을 할당할 때 JVM은 String Constant Pool에서 동일한 값의 String을 검색합니다.\r\n만약 동일한 값을 가진 String이 발견된다면 자바 컴파일러는 추가 메모리를 할당하는 것이 아니라, 단순히 해당 String의 주소에 대한 참조를 반환합니다.\r\n<br>\r\n만약 존재하지 않는다면 해당 값은 String Constant Pool에 추가되고(인턴) 해당 값에 대한 참조가 반환됩니다.\r\n\r\n## 가비지 컬렉터\r\n\r\nJava 7 이전에는 JVM이 고정된 크기를 가진 PermGen이라는 공간에 String Constant Pool을 배치했습니다.\r\nPermGen이라는 공간은 크기가 고정되어 있어서 런타임 시 확장이 불가능하며 garbage collection에 적합하지 않습니다.\r\n\r\nPermGen에서 너무 많은 문자열을 재사용(interning)하는 경우 JVM에서 OutOfMemory 오류가 발생할 수 있습니다.\r\n<br>\r\nJava7 이후부터 String Constant Pool은 JVM에 의해 Garbage Colleted되는 Heap 메모리 영역에 배치되었습니다.\r\nHeap 영역에 배치되는 것의 장점은, 참조되지 않은 String은 GC에 의해 String Constant Pool에서 제거되어 메모리가 해제되기 때문에 OutOfMemory 오류의 위험이 감소한다는 점입니다.\r\n(참고로 PermGen은 Java8부터 Metaspace로 대체되었습니다.)\r\n\r\n## 참고 - Compact Strings\r\n\r\nJava 8버전까지는 String은 내부적으로 UTF-16으로 인코딩된 문자 배열인 char[]로 표현되어 대부분의 언어가 1바이트로 표현이 가능했음에도 불구하고 2바이트의 메모리를 사용했습니다.\r\n그러나 Java 9에서는 Compact Strings를 제공함으로써, 저장된 문자열의 내용에 따라 char[]과 byte[] 사이에서 적절한 인코딩을 선택하여 사용합니다.\r\n따라서 Heap 메모리 사용양이 상당히 줄어들었고, JVM에서 GC 오버헤드가 줄어들었습니다.\r\n\r\n## 왜 String Constant Pool은 Heap 영역에 존재할까?\r\n\r\n자바에서는 객체를 생성하거나 변수를 선언할 때마다 메모리에 저장됩니다.\r\n자바에서 메모리는 Stack과 Heap영역, 이렇게 두 가지 영역으로 나눕니다.\r\nStack 영역과 Heap 영역은 서로 저장하는 데이터가 다르며, 데이터를 저장하는 방법과 데이터에 접근하는 방식이 다릅니다.\r\n\r\n위에서도 배웠지만 String 리터럴(literal)을 선언할 때, JVM은 해당 String 객체를 이곳(String Constant Pool)에 저장하고, Stack 메모리 영역에서 이를 참조합니다.\r\n<br>\r\n(추가로 지금부터 설명하는 String 생성은 특별한 언급이 없는 이상 모두 리터럴로 생성되는 String입니다.)\r\n<br>\r\n<br>\r\n각각의 String 객체를 메모리에 생성하기 전에, JVM은 메모리의 오버헤드를 줄이기 위해 몇가지 과정을 수행합니다.\r\n<br>\r\nString constant pool은 HashMap으로 구현되어 있습니다. Hashmap 각각의 bucket(저장공간)은 같은 해시코드를 가진 String list를 저장합니다. (옛날 버전의 자바에서는 String constant pool의 저장공간은 고정된 크기였으며, 종종 \"객체 Heap을 저장하기 위한 충반한 공간이 없습니다\"라는 오류를 발생시켰습니다.)\r\n<br>\r\n<br>\r\n시스템이 클래스를 로드할 때(클래스 로더에 의해 로드될 때) 모든 클래스의 문자열 리터럴은 application-level pool(String constant pool)로 이동하는데, 이는 서로 다른 클래스의 String 리터럴들은 동일한 객체여야 하기 때문입니다.\r\n그리고 현재 상황(String 리터럴들이 String constant pool로 이동한 상황)에서, pool속에 들어있는 데이터들은 어떠한 종속성 없이도 각각의 Class들에서 사용이 가능해야 합니다.\r\n<br>\r\n일반적으로 Stack 메모리 영역에는 수명이 짧은 데이터들이 저장됩니다. 지역변수, (Heap에 저장된 실제 객체의 주소값을 참조하는) 참조변수, 그리고 실행중인 메소드들이 Stack 메모리 영역에 저장되는 데이터들입니다.\r\n<br>\r\nHeap 메모리 영역은 동적인 메모리 할당을 허용하며 런타임 시 Java의 객체 및 JRE 클래스를 저장합니다.\r\n\r\n참고\r\n\r\n- https://ttl-blog.tistory.com/388\r\n- https://coding-factory.tistory.com/536"},{"excerpt":"💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야…","fields":{"slug":"/critical-sections/"},"frontmatter":{"date":"January 11, 2024","title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n> 💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \r\n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 한다. \r\n동기화 도구에는 대표적으로 **뮤텍스(Mutex)**와 **세마포어(Semaphore)**가 있다. 이들은 모두 공유된 자원의 데이터를 여러 스레드/프로세스가 접근하는 것을 막는 역할을 함\r\n\r\n\r\n\r\n# 임계영역(**Critical Section**)\r\n\r\n\r\n> 💡 **임계 영역**이란 한 순간 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미한다. 임계 구역은 지정된 시간이 지난 후 종료된다.\r\n\r\n\r\n\r\n## 📌 임계 영역을 해결하기 위한 방법\r\n\r\n- 뮤텍스, 세마포어, 모니터 등이 있다.\r\n- 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.\r\n1. 상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음.\r\n2. 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨.\r\n3. 진행 : 임계 구역에 들어간 프로세스가 없는 상태에서, 들어가려고 하는 프로세스가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해주어야 한다.\r\n\r\n4. 융통성 : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 됨.\r\n\r\n## 특징\r\n\r\n- 커널 객체를 사용하지 않는다.\r\n- 서로 다른 프로세스간에 접근이 불가하다**.**\r\n- 내부적으로 인터락 함수를 사용하고 있다.\r\n- 커널 오브젝트를 사용하지 않기 때문에 핸들을 사용하지 않고, CRITICAL_SECTION 이라는 타입을 정의하여 사용한다.\r\n\r\n# 뮤텍스(mutex)\r\n\r\n> 💡 뮤텍스는 Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나)\r\n\r\n\r\n![img.png](img.png)\r\n\r\n\r\n## 과정\r\n\r\n- 1번 프로세스가 자원을 접근하기 위해 Key를점유한다.\r\n- 1번 프로세스는 키를 점유했기 때문에 공유 자원을 사용한다.\r\n- 2번 프로세스가 공유 자원을 사용하기를 원한다.\r\n- 2번 프로세스는 키를 점유하기 위해 대기한다.\r\n- 3번 프로세스 또한 공유 자원을 사용하기 위해 2번 프로세스 다음 순번으로 대기한다.\r\n- 1번 프로세스가 공유 자원을 다 사용하고 Key를 반환한다.\r\n- 2번 프로세스는 대기하고 있다가 반환된 Key를 점유하고 공유 자원을 사용한다.\r\n\r\n## 예시\r\n\r\n뮤텍스는 화장실이 하나 밖에 없는 식당과 비슷합니다. 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야 하며 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다고 가정합니다.\r\n\r\n![img_1.png](img_1.png)\r\n\r\n카운터에 열쇠가 없기 때문에 화장실에 사람이 있다는 뜻이며 화장실을 사용할 수 없습니다. 여자가 나올 때 까지 기다려야 합니다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n곧이어 다른 사람도 화장실에 가려고 카운터에 대기하고 있습니다. 앞사람이 화장실에서 나와 카운터에 키를 돌려놓았습니다. 이제 기다리던 사람들 중 맨 앞에 있던 사람이 키를 받아 화장실에 갈 수 있습니다.\r\n\r\n이것이 뮤텍스가 동작하는 방식입니다. 화장실을 이용하는 사람은 프로세스 혹은 쓰레드이며 화장실은 공유자원, 화장실 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트입니다. 즉, 뮤텍스는 Key에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있습니다.\r\n\r\n# 세마포어(Semaphore)\r\n\r\n\r\n> 💡 공유 리소스에 접근할 수 있는 최대 허용치 만큼 동시 사용자(쓰레드, 프로세스) 접근을 허용하게 한다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)\r\n\r\n\r\n![img_3.png](img_3.png)\r\n\r\n\r\n## 과정\r\n\r\n- 공유 자원에 대한 최대 허용치를 정의한다. 우선, 3으로 해보겠다.\r\n- 1번 프로세스가 공유 자원에 접근한다. 허용치는 2로 감소하였다.\r\n- 2번 프로세스가 공유 자원에 접근한다. 허용치는 1로 감소하였다.\r\n- 3번 프로세스가 공유 자원에 접근한다. 허용치는 0로 감소하였다.\r\n- 4번 프로세스가 공유 자원에 접근한다. 허용치가 0이므로 대기한다.\r\n- 2번 프로세스가 공유 자원을 다 사용하였다. 허용치는 1로 증가하였다.\r\n- 4번 프로세스는 대기 하다 허용치가 1로 증가되어 공유 자원에 접근한다. 허용치는 다시 0으로 감소하였다.\r\n\r\n## 예시\r\n\r\n세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑입니다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다고 가정합니다.\r\n![img_4.png](img_4.png)\r\n\r\n만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 하며 나올 때 빈 칸의 개수를 하나 더해줍니다.\r\n![img_5.png](img_5.png)\r\n\r\n모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1 혹은 양수로 바뀔 때까지 기다려야 합니다.\r\n\r\n이처럼 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성합니다. 세마포어도 아까와 똑같이 화장실이 공유자원이며 사람들이 쓰레드, 프로세스이다. 그리고 화장실 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드,프로세스의 개수를 나타냅니다.\r\n\r\n# 뮤텍스와 세마포어의 차이\r\n\r\n- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.\r\n- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그에 대한 책임을 가진다.\r\n- 세마포어는 동기화 대상이 여러개 일 때 사용하고, 뮤텍스는 동기화 대상이 오로지 하나 일 때 사용된다\r\n\r\n가장 큰 차이점은 동기화 대상의 개수 즉, 위에서 예시든 화장실의 갯수 입니다.\r\n\r\nMutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.\r\nMutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.\r\nMutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.\r\nSemaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다."},{"excerpt":"1. 교착상태(Dead Lock)란?  두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황 1.1 교착상태 발생 경우 Process1 이 Resource1 을 점유하고 있다. Process2 …","fields":{"slug":"/deadlock/"},"frontmatter":{"date":"January 09, 2024","title":"🤔 교착상태 vs 기아상태 vs 경합상태","tags":["OS"]},"rawMarkdownBody":"\r\n##  1. 교착상태(Dead Lock)란?\r\n\r\n![img.png](img.png)\r\n\r\n> - 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태\r\n> - 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황\r\n\r\n\r\n### 1.1 교착상태 발생 경우\r\n\r\n\r\n\r\n- Process1 이 Resource1 을 점유하고 있다.\r\n- Process2 가 Resource2 를 점유하고 있다.\r\n- 여기까지는 괜찮다.\r\n- Process1 이 Resource2의 자원을 사용하기 위해 기다린다.\r\n- Process2 가 Resource1의 자원을 사용하기 위해 기다린다.\r\n- 이렇게 자원 해제가 안되어있고 무한정 기다리고 있는 상태이다.\r\n\r\n### 1.2 교착상태 발생 조건\r\n\r\n![img_1.png](img_1.png)\r\n\r\n- **상호 배제 :** 하나의 프로세스가 자원을 사용중일 때 다른 프로세스는 그를 사용할 수 없다.\r\n- **점유 대기 :** 최소 하나의 자원을 점유하고 있으면서 다른 프로세스가 사용중인 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다.\r\n- **비선점 :** 다른 프로세스가 자원을 사용중인 경우 그 사용이 끝날 때 까지 강제로 뺏을 수 없다.\r\n- **순환 대기 :** 프로세스의 집합에서 순환형태로 자원을 대기하고 있어야 한다.\r\n\r\n### 1.3 교착상태 해결 방법\r\n\r\n#### **1.3.1 교착 상태 예방 및 회피**\r\n\r\n\r\n> 💡 교착 상태가 되지 않도록 하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법이다.\r\n\r\n\r\n\r\n**예방**\r\n\r\n교착상태의 발생 조건 중 하나를 제거하면서 예방.\r\n\r\n- **상호 배제 부정 :** 여러 프로세스가 공유 자원 사용\r\n- **점유 대기 부정 :** 프로세스 실행 전 모든 자원 할당\r\n- **비선점 부정 :** 점유중인 자원을 다른 프로세스가 요구하는 경우 그를 반납\r\n- **순환 대기 부정 :** 자원에 고유 번호를 할당한 후 순서대로 자원 요구\r\n\r\n**회피**\r\n\r\n**은행원 알고리즘**\r\n\r\n- 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 미리 검사하여 교착 상태를 회피한다. 안정 상태인 경우만 자원을 할당하고 그렇지 않은 경우 다른 프로세스들의 자원 해지시 까지 대기한다.\r\n- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법으로 병렬 수행 프로세스 간의 교착 상태를 방지하기 위한 방법이다. 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후에도 안정한 상태인지 사전에 검사하여 교착 상태를 회피하는 기법이다. 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장한다.\r\n\r\n#### **1.3.2 교착 상태 탐지(발견) 및 회복**\r\n\r\n\r\n> - 교착 상태가 발생했는지 점검하고 교착 상태에 있는 프로세스와 자원을 발견하고 교착 상태를 일으킨 프로세스를 종료하거나 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.\r\n> - **교착 상태 탐지(발견)**에는 **교착 상태 발견 알고리즘**과 **자원 할당 그래프** 등을 사용할 수 있다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n**교착 상태 회복**\r\n\r\n교착 상태 회복 기법에는 프로세스 종료, 자원 선점 방법이 있다.\r\n\r\n- **프로세스 종료 :** 교착 상태에 있는 프로세스를 종료하는 방법으로 교착 상태에 있는 모든 프로세스를 종료하는 방법과 프로세스들을 하나씩 종료하면서 교착 상태를 해결하는 방법이 있다.\r\n- **자원 선점 :** 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당하여 해당 프로세스를 일시적으로 멈추는 방법이다. 우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점한다.\r\n\r\n#### **1.3.3 교착 상태 무시**\r\n\r\n대부분 교착 상태가 잘 발생하지 않기에 교착 상태 예방, 회피, 탐지, 복구는 비용이 많이 든다. 또 예방 또는 회피를 프로그래밍해서 넣으면 성능이 큰 영향을 미칠 수 있다. 때문에 교착 상태의 발생 확률이 비교적 낮으면 별 다른 조치를 취하지 않는다.\r\n\r\n## 2. 기아상태(Starvation)란?\r\n\r\n> 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태를 말함 <br>\r\n> 여러 프로세스가 자원을 점유 할때 특정 프로세스에게 자원이 아예 할당 안되는 경우\r\n\r\n\r\n### 2.1 기아상태 해결 방법\r\n\r\n- 프로세스 우선순위 수시 변경을 통해 각 프로세스 높은 우선순위를 가지도록 기회 부여\r\n- 오래 기다린 프로세스의 우선순위 높이기\r\n- 우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용\r\n\r\n## 3. 경합 조건란?\r\n\r\n\r\n> 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 `공유자원에 동시에 접근`하여 결과값에 영향을 줄 수 있는 상태\r\n\r\n\r\n\r\n### 3.1 경합 조건의 예시\r\n\r\n아들은 은행에 10000원의 잔고가 있었고, 현금 인출기를 통해 잔고 10000원을 출금하고 있다. 그 사이 엄마는 아들에게 용돈을 5000원 입금 해주었다. 그렇다면 잔고는 얼마일까?<br>\r\n아들은 10000원을 인출했기 때문에 잔고는 0원이 되고, 이후 엄마가 5000원을 입금해주신 덕분에 잔고는 5000원이 되리라 기대할 것이다.<br>\r\n하지만 경쟁상태일 때<br>\r\n동시에 출금과 입금이 이루어지는 경우<br>\r\n아들의 입장 : 현재잔고 10000원 – 10000원 출금 = 기대잔고 0원<br>\r\n엄마의 입장 : 현재잔고 10000원 – 5000원 입금 = 기대잔고 15000원<br>\r\n\r\n이처럼 경쟁 조건는 `공유 데이터(잔고)에 최종값을 보장할 수 없는 상황`을 말한다.\r\n\r\n이 경쟁 조건로 생기는 영역이`임계구역(Critical Section)`이다.\r\n\r\n- **정의:** 경쟁 조건은 시스템의 동작이 스레드가 실행되도록 예약된 순서와 같은 이벤트의 상대적 타이밍에 따라 달라질 때 발생\r\n- **원인:** 여러 스레드나 프로세스의 실행 순서가 비결정적이기 때문에 발생\r\n\r\n#### 임계구역(critical section)\r\n\r\n공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역이다.<br>\r\n이 임계구역을 해결하는 방법이 `동기화 메커니즘(ex. 세마포어)`을 사용하는 것이다.<br>\r\n동기화 메커니즘의 근간이 바로 `락(Lock)`을 사용하는 것이다.<br>\r\n\r\n경쟁 조건와 교착상태에서는 다양한 동기화 기술과 알고리즘이 사용됨\r\n\r\n## 4. 기타\r\n\r\n### 4.1 **교착 상태 vs 기아 상태**\r\n\r\n교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태이다. 즉 교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생하고 기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다.\r\n\r\n- **교착상태** : 여러 프로세스가 동일 자원 점유를 요청할 때 발생\r\n- **기아상태** : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생\r\n\r\n### 4.2 교착 상태 vs 경쟁 조건\r\n\r\n교착 상태와 경쟁 조건은 모두 동시성 문제인 반면, 교착 상태는 리소스에 대한 순환 종속성을 포함하여 완전한 정지를 초래하는 반면, 경쟁 조건은 예측할 수 없는 작업 인터리빙과 관련되어 동시 리소스 액세스로 인해 예상치 못한 결과를 초래\r\n\r\n- **교착 상태:** 교착 상태는 두 개 이상의 프로세스가 서로의 리소스 해제를 기다리고 있기 때문에 진행할 수 없는 상황. 이로 인해 순환 대기 시나리오가 발생하고 관련 프로세스가 무기한 차단됨\r\n- **경쟁 조건:** 경쟁 조건은 시스템의 동작이 이벤트의 상대적인 타이밍, 특히 스레드나 프로세스가 실행되도록 예약된 순서에 따라 달라질 때 발생함. 비결정적인 실행 순서로 인해 예측할 수 없는 결과가 발생함\r\n\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}