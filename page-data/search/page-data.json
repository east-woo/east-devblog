{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Chapter 15. JUnit 들여다보기\nChapter 16. SerialDate 리팩터링\npage 323 ~ 366 1. 책 내용 요약 15장 JUnit 들여다 보기 JUnit 프레임워크 JUnit은 자바 테스팅 프레임워크다. 사실상 표준이라고 할만큼 널리 사용되고 있다. 개념은 단순하며 정의는 정밀하고 구현은 우아하다. JUnit은 저자가 많지만 시…","fields":{"slug":"/CleanCode-14/"},"frontmatter":{"date":"July 14, 2024","title":"[클린코드-14] 라이브러리 분석을 통해 코드를 바라보는 시각 기리기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 15. JUnit 들여다보기**<br>\r\n**Chapter 16. SerialDate 리팩터링**<br>\r\n**page 323 ~ 366**<br>\r\n\r\n## 1. 책 내용 요약\r\n\r\n### 15장 JUnit 들여다 보기\r\n\r\n### JUnit 프레임워크 \r\n> JUnit은 자바 테스팅 프레임워크다. 사실상 표준이라고 할만큼 널리 사용되고 있다. 개념은 단순하며 정의는 정밀하고 구현은 우아하다. JUnit은 저자가 많지만 시작은 켄트 벡과 에릭 감마, 두 사람이 비행기를 타고 가다 JUnit을 만들었다.\r\n- 지금부터 살펴볼 예제는 문자열 비교 오류를 파악할 때 유용한 모듈이다. \r\n  - ComparisonCompactor는 두 문자열을 받아 차이를 반환한다. 예를 들어, ABCDE와 ABXDE를 받으면 <…B[X]D…>를 반환한다.\r\n\r\n#### ComparisonCompactorTest.java\r\n```java\r\n// https://github.com/junit-team/junit4/blob/main/src/test/java/junit/tests/framework/ComparisonCompactorTest.java\r\n\r\npackage junit.tests.framework;\r\n\r\nimport junit.framework.ComparisonCompactor;\r\nimport junit.framework.TestCase;\r\n\r\npublic class ComparisonCompactorTest extends TestCase {\r\n\r\n    public void testMessage() {\r\n        String failure = new ComparisonCompactor(0, \"b\", \"c\").compact(\"a\");\r\n        assertTrue(\"a expected:<[b]> but was:<[c]>\".equals(failure));\r\n    }\r\n\r\n    public void testStartSame() {\r\n        String failure = new ComparisonCompactor(1, \"ba\", \"bc\").compact(null);\r\n        assertEquals(\"expected:<b[a]> but was:<b[c]>\", failure);\r\n    }\r\n\r\n    public void testEndSame() {\r\n        String failure = new ComparisonCompactor(1, \"ab\", \"cb\").compact(null);\r\n        assertEquals(\"expected:<[a]b> but was:<[c]b>\", failure);\r\n    }\r\n\r\n    public void testSame() {\r\n        String failure = new ComparisonCompactor(1, \"ab\", \"ab\").compact(null);\r\n        assertEquals(\"expected:<ab> but was:<ab>\", failure);\r\n    }\r\n\r\n    public void testNoContextStartAndEndSame() {\r\n        String failure = new ComparisonCompactor(0, \"abc\", \"adc\").compact(null);\r\n        assertEquals(\"expected:<...[b]...> but was:<...[d]...>\", failure);\r\n    }\r\n\r\n    public void testStartAndEndContext() {\r\n        String failure = new ComparisonCompactor(1, \"abc\", \"adc\").compact(null);\r\n        assertEquals(\"expected:<a[b]c> but was:<a[d]c>\", failure);\r\n    }\r\n\r\n    public void testStartAndEndContextWithEllipses() {\r\n        String failure = new ComparisonCompactor(1, \"abcde\", \"abfde\").compact(null);\r\n        assertEquals(\"expected:<...b[c]d...> but was:<...b[f]d...>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorStartSameComplete() {\r\n        String failure = new ComparisonCompactor(2, \"ab\", \"abc\").compact(null);\r\n        assertEquals(\"expected:<ab[]> but was:<ab[c]>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorEndSameComplete() {\r\n        String failure = new ComparisonCompactor(0, \"bc\", \"abc\").compact(null);\r\n        assertEquals(\"expected:<[]...> but was:<[a]...>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorEndSameCompleteContext() {\r\n        String failure = new ComparisonCompactor(2, \"bc\", \"abc\").compact(null);\r\n        assertEquals(\"expected:<[]bc> but was:<[a]bc>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorOverlappingMatches() {\r\n        String failure = new ComparisonCompactor(0, \"abc\", \"abbc\").compact(null);\r\n        assertEquals(\"expected:<...[]...> but was:<...[b]...>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorOverlappingMatchesContext() {\r\n        String failure = new ComparisonCompactor(2, \"abc\", \"abbc\").compact(null);\r\n        assertEquals(\"expected:<ab[]c> but was:<ab[b]c>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorOverlappingMatches2() {\r\n        String failure = new ComparisonCompactor(0, \"abcdde\", \"abcde\").compact(null);\r\n        assertEquals(\"expected:<...[d]...> but was:<...[]...>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorOverlappingMatches2Context() {\r\n        String failure = new ComparisonCompactor(2, \"abcdde\", \"abcde\").compact(null);\r\n        assertEquals(\"expected:<...cd[d]e> but was:<...cd[]e>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorWithActualNull() {\r\n        String failure = new ComparisonCompactor(0, \"a\", null).compact(null);\r\n        assertEquals(\"expected:<a> but was:<null>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorWithActualNullContext() {\r\n        String failure = new ComparisonCompactor(2, \"a\", null).compact(null);\r\n        assertEquals(\"expected:<a> but was:<null>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorWithExpectedNull() {\r\n        String failure = new ComparisonCompactor(0, null, \"a\").compact(null);\r\n        assertEquals(\"expected:<null> but was:<a>\", failure);\r\n    }\r\n\r\n    public void testComparisonErrorWithExpectedNullContext() {\r\n        String failure = new ComparisonCompactor(2, null, \"a\").compact(null);\r\n        assertEquals(\"expected:<null> but was:<a>\", failure);\r\n    }\r\n\r\n    public void testBug609972() {\r\n        String failure = new ComparisonCompactor(10, \"S&P500\", \"0\").compact(null);\r\n        assertEquals(\"expected:<[S&P50]0> but was:<[]0>\", failure);\r\n    }\r\n}\r\n```\r\n\r\n#### ComparisonCompactor.java    \r\n```java\r\n// https://github.com/junit-team/junit4/blob/main/src/main/java/junit/framework/ComparisonCompactor.java\r\npackage junit.framework;\r\n\r\npublic class ComparisonCompactor {\r\n\r\n    private static final String ELLIPSIS = \"...\";\r\n    private static final String DELTA_END = \"]\";\r\n    private static final String DELTA_START = \"[\";\r\n\r\n    private int fContextLength;\r\n    private String fExpected;\r\n    private String fActual;\r\n    private int fPrefix;\r\n    private int fSuffix;\r\n\r\n    public ComparisonCompactor(int contextLength, String expected, String actual) {\r\n        fContextLength = contextLength;\r\n        fExpected = expected;\r\n        fActual = actual;\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    public String compact(String message) {\r\n        if (fExpected == null || fActual == null || areStringsEqual()) {\r\n            return Assert.format(message, fExpected, fActual);\r\n        }\r\n\r\n        findCommonPrefix();\r\n        findCommonSuffix();\r\n        String expected = compactString(fExpected);\r\n        String actual = compactString(fActual);\r\n        return Assert.format(message, expected, actual);\r\n    }\r\n\r\n    private String compactString(String source) {\r\n        String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;\r\n        if (fPrefix > 0) {\r\n            result = computeCommonPrefix() + result;\r\n        }\r\n        if (fSuffix > 0) {\r\n            result = result + computeCommonSuffix();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private void findCommonPrefix() {\r\n        fPrefix = 0;\r\n        int end = Math.min(fExpected.length(), fActual.length());\r\n        for (; fPrefix < end; fPrefix++) {\r\n            if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void findCommonSuffix() {\r\n        int expectedSuffix = fExpected.length() - 1;\r\n        int actualSuffix = fActual.length() - 1;\r\n        for (; actualSuffix >= fPrefix && expectedSuffix >= fPrefix; actualSuffix--, expectedSuffix--) {\r\n            if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) {\r\n                break;\r\n            }\r\n        }\r\n        fSuffix = fExpected.length() - expectedSuffix;\r\n    }\r\n\r\n    private String computeCommonPrefix() {\r\n        return (fPrefix > fContextLength ? ELLIPSIS : \"\") + fExpected.substring(Math.max(0, fPrefix - fContextLength), fPrefix);\r\n    }\r\n\r\n    private String computeCommonSuffix() {\r\n        int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength, fExpected.length());\r\n        return fExpected.substring(fExpected.length() - fSuffix + 1, end) + (fExpected.length() - fSuffix + 1 < fExpected.length() - fContextLength ? ELLIPSIS : \"\");\r\n    }\r\n\r\n    private boolean areStringsEqual() {\r\n        return fExpected.equals(fActual);\r\n    }\r\n}\r\n```\r\n\r\n#### 세상에 완벽한 코드는 없다\r\n```java\r\n// Original\r\nprivate void compactExpectedAndActual() {\r\n    prefixIndex = findCommonPrefix();\r\n    suffixIndex = findCommonSuffix();\r\n    compactExpected = compactString(expected);\r\n    compactActual = compactString(actual);\r\n}\r\n\r\n//1st Refactoring\r\n// 호출 순서는 정해지지만 prefixIndex가 필요한 이유를 설명하지 못함\r\nprivate void compactExpectedAndActual() {\r\n    prefixIndex = findCommonPrefix();\r\n    suffixIndex = findCommonSuffix(prefixIndex);\r\n    compactExpected = compactString(expected);\r\n    compactActual = compactString(actual);\r\n}\r\n\r\n//2nd Refactoring\r\nprivate void compactExpectedAndActual() {\r\n    findCommonPrefixAndSuffix();\r\n    compactExpected = compactString(expected);\r\n    compactActual = compactString(actual);\r\n}\r\n\r\nprivate void findCommonPrefixAndSuffix() {\r\n    findCommonPrefix();\r\n    // ..\r\n}\r\n```\r\n#### 정리\r\n- 의도를 명확하게 표현하기 위해 조건문을 메서드로 분리\r\n- 전후 단계가 있는 변수들 사이 시간적인 결합(hidden temporal coupling)을 해결하기 위해 리팩터링 (왼쪽 코드)\r\n- 더 적절한 의미로 네이밍 변경\r\n- 불필요한 연산을 하는 코드 제거\r\n\r\n### 16장 SerialDate 리팩터링\r\n\r\n#### 남의 코드를 비판하고, 내 코드의 비판을 듣는 건 편안하게 여겨야 할 활동이다\r\n\r\n**Make it Work**\r\n- 테스트 코드가 모든 경우를 테스트하지 않는다.<br/>\r\n   -> 주석 처리된 테스트 코드들을 모두 동작하도록 손본다.\r\n- 코드의 구조를 개선하기 전에 버그들을 수정한다.<br/> \r\n  경계 조건 오류, 늘 거짓인 조건문\r\n\r\n**Make it Right (실제 개선)**\r\n- 옛날 스타일 코드 제거 (MonthConstants를 상속하는 방식 → enum Month)\r\n- seriaIVersionUID를 컴파일러가 자동 생성하도록 함<br/>\r\n(직접 변경하지 않아 생기는 버그보다 변경된 UID로 발생한 예외를 디버경하는게 낫다)\r\n- DayDate(SeriaIDate) Abstract Factory를 통해 생성하도록 한다.\r\n- 캡슐화를 위해 접근제한자를 수정(public → private)\r\n- 사용되지 않는 변수 제거\r\n- 불필요한 주석 제거\r\n\r\n---\r\n## 2. 오픈 소스 접근법\r\n\r\n### <오픈 소스: 코드 분석 어떻게 하나?> 같이 읽기\r\n\r\n#### [오픈 소스: 코드 분석 어떻게 하나?](https://www.popit.kr/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%82%98/) 김형준 (2016-09-01)\r\n\r\n> MySQL, Apache, Tomcat 등과 같은 오픈 소스는 매뉴얼이나 문서, 책 등도 많이 나와 있으며 오픈 소스이지만 솔루션 자체도 안정적이라서 특별한 이유가 아니면 소스를 분석할 필요는 없습니다.<br>\r\n하지만 Hadoop이나 HBase 등과 같은 솔루션은 문서도 부족하지만 문서로만 설명할 수 없는 복잡한 내용으로 구성되어 있는 솔루션이 않습니다.<br>\r\n따라서 **제대로 솔루션을 사용하거나 운영하기 위해서는 소스 코드를 봐야 하는 경우가 많습니다.**<br>\r\n최근 Presto, Zeppelin, Kafka 등을 사용하면서 필요한 기능을 추가하거나 설치, 운영 중 에러를 해결하기 위해 사용하는 오픈 소스의 코드를 분석하였습니다.<br>\r\n이때 사용되었던 제 나름대로 가지고 있는 오픈소스 코드 분석 방법에 대해 정리해 보았습니다.\r\n\r\n\r\n#### 해당 솔루션에 대한 기본 지식을 먼저 익혀라\r\n\r\n> **하둡을 분석하려면 구글에서 발표한 논문을 읽어 봐야하고, HBase를 분석하기 위해서는 BigTable 논문을 읽어야 합니다.**<br/> 분석하고자 하는 솔루션에 대한 이론적인 배경 지식이 없는 상태에서 소스 코드를 바로 보면 그냥 스파게티처럼 얽혀 있는 코드를 보고 있는 느낌이 듭니다.<br/><br/>\r\n>**복잡한 분산 컴퓨팅 환경에서 운영되는 솔루션인 경우 더욱 더 그 시스템의 기본 개념과 아키텍처를 이해하고 있어야 합니다.**\r\n\r\n\r\n### 본인 PC에 빌드 및 실행 환경을 구축하라\r\n\r\n> 코드 분석을 빨리하기 위해서는 분석에 필요한 로그를 추가하여 재 컴파일한 후 실행하면서 로그를 확인하는 것이 좋습니다.<br/> \r\n> 단순 코드만 보면 특정 연산의 흐름이 어떻게 진행되고 있는지를 파악하기 어려운 경우가 많기 때문입니다. <br/>\r\n> 실제로 필자가 가장 먼저 하는 부분이 바로 이 항목입니다.<br/><br/>\r\n>최근의 오픈소스들은 분산 환경에서 운영되는 경우가 많은데 이 경우라 하더라도 **개발자의 PC(가능하면 노트북)에 빌드와 실행환경을 모두 구성하는 것이 좋습니다. “좋다”라는 정도가 아니라 필수 사항이라 할 수 있습니다.**<br/><br/>\r\n> 빌드 및 실행환경을 구성하는 것만으로 코드 분석의 500/0는 진행되었다고 할 수 있습니다.\r\n\r\n\r\n#### 수정, 실행, 확인 사이클을 짧게 만들어라\r\n\r\n> 코드를 분석하기 위해서는 분석에 필요한 정보를 출력하는 코드나 확인을 위한 코드를 추가한 다음에 기능을 실행해서 확인해야 하는 경우가 많습니다. \r\n> 이 경우 수정, 실행, 확인을 위한 시간이 길어지면 그 만큼 효율이 떨어지게 되고 많은 시간이 소요됨니다.<br/><br/>\r\n> **몇번 반복하다 보면 같은 작업 패턴을 찾게되는데 이때에는 스크립트를 만들어서 반복 작업을 효율적으로 하는 것이 좋습니다.**\r\n\r\n\r\n#### 자신에게 질문을 많이 하라\r\n\r\n> 오픈 소스 개발자라고 해서 하늘에서 떨어진 개발자는 아닙니다. 대부분 비슷한 교육을 받고 비\r\n슷한 경험을 했습니다.<br/><br/>\r\n> **특정 기능에 대해서 \"나라면 어떻게 개발했을까?\" 라고 자신에게 질문을 던지고 머리속에 어떻\r\n게 구현할 것인지를 먼저 그려 봅니다.**<br/><br/>\r\n> 처음에는 자신이 예측했던 부분이 많이 틀리겠지만 코드를 많이 보고 연습을 많이 하면 이것도\r\n얼추 많이 맞추게 됩니다. 유사한 오픈 소스 그름은 유사한 패턴으로 개발하기 때문입니다. 대표\r\n적인 오픈 소스 그룹이 Hadoop 및 그 패밀리들(Base, ZooKeeper, HBase, Hive 등) 입니다.\r\n\r\n#### 분석하면서 문서로 정리하라\r\n\r\n> **분석을 하면서 그림 또는 문서로 정리를 하면 분석하는 그 시점에도 도움이 되지만 나중에도 도움이 됩니다.**<br/>\r\n> 문서는 굳이 UML이 아니더라도 ppt 같은 도구로 정리하면 됩니다. 이렇게 중간 중간에 정리하면 머리속에서만 빙빙 돌던 생각이 정리될때가 많습니다.<br/> \r\n> “분석이 다 된 다음에 깔끔하게 정리해야지” 라는 생각이면 거의 정리는 못한다고 봐야 합니다. 나중에 정리 하려면 정리도 어렵고 생각도 잘 나지 않습니다.\r\n\r\n\r\n#### 디버거 활용하기\r\n\r\n> **LOG level을 DEBUG로 설정하라.**<br/>\r\n> 배포되는 패키지는 대부분 Logger의 설정이 INFO 또는 WARN으로 설정된 경우가 많습니다.<br/> \r\n> 더 많은 정보를 얻기 위해서는 logger의 레벨을 DEBUG로 설정합니다. <br/>\r\n> DEBUG로 설정할 경우 너무 많은 로그 메시지가 나올 수 있는데 패키지 별로 서로 다른 수준의 LOG level을 설정하는것이 좋습니다.<br/><br/>\r\n> **디버거의 breakpoint 기능을 활용하라**<br/>\r\n> 집중적으로 분석하고 싶은 구간은 디버거의 breakpoint 기능을 이용하여 step 단위로 실행하면서 각 변수의 변화 상태를 확인하는 것이 좋습니다.<br/><br/>\r\n> **System.out.println 보다는 Thread.dumpStack()을 활용하라.**<br/>\r\n>최근 오픈 소스는 리플렉션을 적극 활용하거나 미 등을 이용하여 코드 그 자제만으로는 어떤 클래스가 실행중에 바인딩 되는지 찾기 어려운 경우가 많습니다. <br/>\r\n> 그리고 해당 로직이 어떤 경로를 거셔 호출되는지 찾기 어려운 경우가 많습니다.<br/> \r\n> 이 경우 앞에서 설명한 디버거를 이용할 경우에도 어디에 breakpoint를 걸어야 할 지 애매한 경우가 많은데 이 경우 짐작이 가는 부분에 Thread.dumpStack() 코드를 추가하면 전체 호출 흐름 및 실제 바인딩 되는 클래스를 확인할 수 있습니다.\r\n\r\n\r\n#### 코드의 일부를 통해 먼저 파악하기\r\n\r\n> **당장 관심있는 부분부터 집중적으로 파악하라**<br/>\r\n> 방대한 시스템의 경우 전체를 보다 보면 금방 지루하고 갈 곳을 읽어 버리는 수가 많습니다. 당장 필요하거나 관심있는 부분부터 집중해서 보는 것이 좋습니다.<br/><br/>\r\n> **테스트 코드는 좋은 교본이 된다**<br/>\r\n> 좋은 오픈 소스는 좋은 테스트 코드를 가지고 있습니다. <br/>\r\n> 테스트 코드는 실제 운영되는 기능이나 모듈의 동작을 테스트하기 위한 프로그램 코드이기 때문에 특정 기능을 수행하기 위해 어떤 클래스의 어떤 메소드가 호출되는지가 바로 나타나 있는 경우가 않습니다.<br/> \r\n> 그리고 테스트 코드 중 일부는 데몬을 실행하지 않고 바로 실행, 확인할 수 있는 코드가 많기 때문에 이런 테스트 코드와 breakpoint 등을 잘 조합하면 쉽고 빠르게 소스 코드를 분석할 수 있습니다.<br/><br/>\r\n> **그래도 어려우면 초기 버전을 다운로드 받아 분석하라**<br/>\r\n> 복잡해보이는 오픈소스도 초창기 버전은 단순하게 기본 기능만 구현되어 있는 경우가 많습니다.<br/> \r\n> 버전이 올라가면서 개발자들이 많이 참여하 게 되고 코드는 점점 복잡해지고 기능도 많아지게 됩니다. <br/>\r\n> 초창기 버전에서는 핵심 기능에만 집중하는 경우가 많기 때문에 핵심 기능을 분석이기에는 초창기 버전이 좋습니다.<br/>\r\n\r\n---\r\n## 3. Spring 프로젝트 접근법\r\n\r\n<img src=\"img.png\" width=\"50%\" height=\"50%\"/>\r\n\r\n1. repository 이름과 README.md를 보고 프로젝트의 성격을 파악한다\r\n2. 패키지 구조를 살퍼본다- 멀티 모듈 프로젝트?\r\n3. 빌드 설정 파일(build.gradle)을 보고, 어떤 디펜던시(모듈)을 쓰나 살퍼본다\r\n4. config 패키지 하위에 어떤 설정들이 되어있는지 확인한다.<br/>\r\n   - RedisConfig, KafkaProducerConfig, DataSourceConfig, CircuitBreakerConfig, CacheConfig...\r\n5. controller 패키지 하위 코드를 보고 어떤 요청들을 처리하는지 감을 잡는다.\r\n6. service 패키지 하위를 보고 비즈니스 로직을 추측한다.\r\n7. 데이터 구조를 알기 위해 resource 하위의 db 설정 파일을 보고 db에 접근해본다.\r\n   - schema.sql 파일이 있으면 DDL을 읽어본다.\r\n8. 세부적인 비즈니스 로직을 확인할 때는 test 코드와 비교하며 이해한다.\r\n\r\n### IDE Code Analysis 기능\r\n<img src=\"img_1.png\" width=\"50%\" height=\"50%\"/>"},{"excerpt":"Chapter 14. 점진적인 개선\npage 245 ~ 322 1. 책의 예제 명령형 인수 구문 분석기 코드 초안  모든 로직이 하나의 클래스에 들어가있다. 처음부터 지저분한 코드를 짜려는 생각은 없었고, 코드를 어느정도 손 봤지만 새로운 인수 유형이 들어오면서 재앙이 시작됐다. 이제는 개선해야 할 때 라는걸 깨닫고, 변경 전후 시스템이 동일하게 돌아간다…","fields":{"slug":"/CleanCode-13/"},"frontmatter":{"date":"July 10, 2024","title":"[클린코드-13] 코드를 점진적으로 개선하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 14. 점진적인 개선**<br>\r\n**page 245 ~ 322**<br>\r\n\r\n## 1. 책의 예제\r\n### 명령형 인수 구문 분석기\r\n\r\n#### 코드 초안\r\n\r\n![](img.png)\r\n\r\n- 모든 로직이 하나의 클래스에 들어가있다.\r\n- 처음부터 지저분한 코드를 짜려는 생각은 없었고, 코드를 어느정도 손 봤지만 새로운 인수 유형이 들어오면서 재앙이 시작됐다.\r\n- 이제는 개선해야 할 때 라는걸 깨닫고, 변경 전후 시스템이 동일하게 돌아간다는 사실을 확인하기 위해 테스트들을 작성해뒀다.\r\n- 자잘하게 점진적으로 개선해나갔다\r\n\r\n#### 코드 완성본\r\n\r\n![](img_1.png)\r\n\r\n- Args 클래스에서 코드 중복을 최소화하고, ArgsException 클래스를 분리했다. ArgumentMarshaler 클래스를 통해 여러 인수에 대한 추후 확장성을 만들어냈다.\r\n- **코드만 분리해도 설계가 좋아진다.** 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다.\r\n\r\n#### 책의 예제를 통해 배울 점\r\n\r\n- 한번 정도 따라 읽어가며 저자가 '점진적으로' 코드를 개선해나가는 사고 흐름을 따라가면 좋다\r\n- 부담없이 가볍게 읽어본다.\r\n\r\n  **자신이 스스로 점진적으로 코드를 개선해보는 경험을 통해 더 많이 배우게 된다**\r\n\r\n---\r\n## 2. 점진적으로 개선하기\r\n1. 코드가 나빠지고 있음을 느꼈을 때 기능을 추가하지 않고 개선을 시작한다.\r\n2. 테스트 코드를 작성한다.\r\n   - 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다.\r\n   - 테스트 코드가 없다면 작성하고, 코드를 수정하기 전 상태에서 모든 테스트가 통과해야한다.\r\n\r\n3. 점진적으로 개선한다\r\n   - 책임에 따라 클래스를 나누고, 코드를 옮긴다. 테스트가 깨지지 않도록 확인하며 자잘한 변경을 조금씩 진행한다.\r\n\r\n\r\n#### “ 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다 ”\r\n\r\n\r\n---\r\n## 3. IDE를 활용해 점진적으로 개선하기\r\n\r\n- ExtractMethod: 메서드 추출 기능 => 코드 블럭을 메서드로 추출할 수 있다\r\n- Change Signature : 메소드 파라미터 추가, 삭제 및 변경 => 메서드의 파라미터를 추가하거나 변경할 수 있다.\r\n- Rename : 이름 변경 => 메서드나 변수 이름을 변경할 수 있다\r\n- Extract Variable : 변수 추출 기능 => 변수를 추출할 수 있다\r\n- Extract Field : 멤버 변수 추출 기능 => 특정값을 멤버 변수로 설정할 수 있다\r\n- Extract Constant : 상수 추출 기능 => 특정값을 상수로 추출할 수 있다\r\n- Pull Members Up & Pull Members Down => 하위 클래스의 메서드를 상위로 올리거나 & 상위 클래스의 메서드를 하위로 내릴 수 있다\r\n\r\n"},{"excerpt":"Chapter 13. 동시성\npage 225 ~ 244\n부록 407 ~ 466 1. 동시성 프로그래밍이란 어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식 외부 서비스의 응답을 기다리면서 아무일도 하지 않으면 CPU 사이클이 낭비된다 낭비되는 자원을 줄이자 동시성 프로그래밍 이해하기  동시성이 구현되지 않는 경우  서버가 …","fields":{"slug":"/CleanCode-12/"},"frontmatter":{"date":"July 09, 2024","title":"[클린코드-12] 동시성을 구현할 때 명심할 것들","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 13. 동시성**<br>\r\n**page 225 ~ 244**<br>\r\n**부록 407 ~ 466**\r\n\r\n## 1. 동시성 프로그래밍이란\r\n\r\n> **어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식**\r\n- 외부 서비스의 응답을 기다리면서 아무일도 하지 않으면 CPU 사이클이 낭비된다\r\n- 낭비되는 자원을 줄이자\r\n\r\n### 동시성 프로그래밍 이해하기\r\n\r\n![구성](img.png)\r\n\r\n### 동시성이 구현되지 않는 경우\r\n\r\n![](img_1.png)\r\n> 서버가 클라이언트의 요청이 완료되도록 요청이 완료되도록 그저 기다리기 때문에 다른 작업이 실행되지 못한다.\r\n- 서버(코어)를 늘려 처리량을 높여보자!\r\n\r\n### 병렬성을 구현한 경우\r\n\r\n![](img_2.png)\r\n> 서버의 수가 늘어 나아졌지만.. 요청을 처리할 때까지 기다리기 때문에 다른 작업이 수행되지 못한다.\r\n- CPU 클럭 낭비!!\r\n\r\n### 동시성을 구현한 경우\r\n\r\n![](img_3.png)\r\n> 동시성을 구현한다고 해서 클라이언트 입장에서 자신의 요청이 빨리 처리되는게 아니다.<br> **어플리케이션 입장에서는 효율적으로 코어를 사용해 처리량을 높일 수 있다.**\r\n\r\n### 동시성과 병렬성이 구현된 경우\r\n\r\n![](img_4.png)\r\n> 언어 레벨에서 하드웨어의 멀티코어를 적절하게 사용하도록 지원하기 때문에<br>\r\n동시성만 신경써서 개발하면 된다.\r\n\r\n- 서버(코어)를 효율적으로 사용하여 처리량을 최대화했다.\r\n- 클라이언트가 아닌 어플리케이션 관점에서 봐야한다.\r\n- 내 어플리케이션의 효율성을 높여야 한다.\r\n- 더불어 내 어플리케이션이 동작하는 머신의 환경이 효율적으로 돌아가도록\r\n- 내 어플리케이션에 메모리 누수나 자원이 낭비되지 않도록 신경쓴다.\r\n\r\n----\r\n\r\n## 2. 동시성 프로그래밍이 필요한 이유\r\n\r\n### 동시성 프로그래밍의 미신과 오해 (1)\r\n\r\n**동시성은 항상 성능을 높여준다 (X)<br>\r\n동시성은 때로 성능을 높여준다 (O)**\r\n\r\n- 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.\r\n- 예시: 웹 브라우저에서 여러 가지 이미지 리소스들을 불러와 다운로드할때\r\n- 예시 상황: ServIet\r\n\r\n### Java ServIet 동시성 구현\r\n![](img_5.png)\r\n![](img_6.png)\r\n\r\n- 요청이 들어오면 Thread Pool에 있는 Thread가 서블릿의 service() 메서드를 호출한다.\r\n- service의 doGet(), doPost()에서 요청에 대한 처리를 하도록 구현한다.\r\n\r\n![https://www.interviewbit.com/servlet-interview-questions/](img_7.png)\r\n\r\n```java\r\npublic class SimpleHttpServlet extends HttpServlet {\r\n\r\n    // Not thread safe, static.\r\n    protected static List list = new ArrayList();\r\n\r\n    // Not thread safe\r\n    protected Map map = new HashMap();\r\n\r\n    // Thread safe to access object, not thread safe to reassign variable.\r\n    protected Map map = new ConcurrentHashMap();\r\n\r\n    // Thread safe to access object (immutable), not thread safe to reassign variable.\r\n    protected String aString = \"a string value\";\r\n\r\n\r\n    protected void doGet( HttpServletRequest request,\r\n                          HttpServletResponse response)\r\n            throws ServletException, IOException {\r\n\r\n\r\n        // Not thread safe, unless the singleton is 100% thread safe.\r\n        SomeClass.getSomeStaticSingleton();\r\n\r\n\r\n        // Thread safe, locally instantiated, and never escapes method.\r\n        Set set = new HashSet();\r\n\r\n    }\r\n}\r\n```\r\n\r\n1. 해당 서블릿에 여러 쓰레드가 접근할 수 있기 때문에 멤버변수들은 Not Thread Safe 하다.\r\n2. doGet(), doPost()는 하나의 쓰레드 영역에서 실행되기 때문에 로컬 변수들은 Thread Safe 하다\r\n\r\n**ConcurrentHashMap→ 접근에 대해서는 Thread Safe, 하지만 값을 재 할당 하는 경우는 Thread Safe 하지 않음**\r\n\r\n### 동시성 프로그래밍의 미신과 오해 (2)\r\n\r\n**동시성을 구현해도 설계는 변하지 않는다 (X)<br/>\r\n동시성을 구현하면 설계를 바꿔야 한다(O)**\r\n\r\n- 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이 하게 다르다.\r\n- '무엇'과 '언제를 분리하면 시스템의 구조가 크게 달라진다.\r\n\r\n### 동시성 프로그래밍의 미신과 오해 (3)\r\n\r\n**Web나 EJB와 같은 컨테이너를 사용한다면 동시성을 이해할 필요가 없다(X) <br/>\r\n컨테이너를 사용해도 동시성을 이해해야 한다(O)**\r\n\r\n- 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다.\r\n- 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야 한다.\r\n\r\n----\r\n\r\n## 3. 안전한 동시성 프로그래밍 규칙\r\n\r\n### 단일 책임 원칙 설계(SRP)\r\n\r\n#### 동시성 관련 코드는 다른 코드와 분리하라\r\n\r\n- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.\r\n- 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.\r\n- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.<br/>\r\n  주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로도 충분히 어렵다\r\n\r\n### 자료 범위를 제한하라\r\n\r\n#### 공유 자료를 최대한 줄여라\r\n\r\n- 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라\r\n- 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하느라 수고가 드므로 임계 영역의 수를 최소화 해야 한다. (임계영역 작게 만들고, 적게 만들어야 한다.)\r\n\r\n### 자료 사본을 사용하라\r\n\r\n#### 공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다. (각각 로컬변수로 활용)\r\n\r\n- 객체를 복사해 읽기 전용으로 사용한다.\r\n- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다.\r\n- 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이<br/>\r\n  사본 생성과 가비지 컬렉션(GC)에 드는 부하를 상쇄할 가능성이 크다.\r\n\r\n### Thread는 가능한 독립적으로 구현하라\r\n\r\n#### 다른 스레드와 자료를 공유하지 않는다.\r\n\r\n- 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다.\r\n- 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다.\r\n- 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.\r\n\r\n### 라이브러리를 이해하라\r\n\r\n#### Java.util.concurrent 패키지를 익혀라\r\n\r\n- Thread Safe한 컬렉션을 사용한다.<br/>\r\n  ConcurrentHashMap, AtomicLong\r\n- 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.\r\n- 가능하다면 Thread가 Blocking되지 않는 방법을 사용한다\r\n\r\n### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라\r\n\r\n#### 공유 객체 하나에는 메서드 하나만 사용하라\r\n\r\n- 클라이언트에서 잠금 - 클라이언트 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.\r\n- 서버에서 잠금 - 서버에다 \"서버를 잠그고 모든 메서드를 호출한 후 잠금을 해체하는\" 메서드를 구현한다. 클라이언트는 이 메서드를 호출하기만 하면 된다.\r\n- 연결(Adapter) 서버 - 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.\r\n\r\n### 문제상황 : 공유 자원 접근\r\n\r\n#### 서버\r\n```java\r\npublic class IntegerIterator implements Iterator<Integer> {\r\n    private Integer nextValue = 0;\r\n    \r\n    public synchronized boolean hasNext() {\r\n    \treturn nextValue < 100000;\r\n    }\r\n    \r\n    public synchronized Integer next() {\r\n    \tif (nextValue == 100000) \r\n        \tthrow new InteratorPastEndException();\r\n        return nextValue++;\r\n    }\r\n    \r\n    public syncronized Integer getNextValue() {\r\n    \treturn nextValue;\r\n    }\r\n}\r\n```\r\n#### 클라이언트\r\n```java\r\n// 공유 자료\r\nIntegerInterator iterator = new IntegerIterator();\r\n\r\n// Thread에서 호출되는 코드\r\nwhile (iterator.hasNext()) {\r\n    int nextValue = iterator.next();\r\n}\r\n```\r\n\r\n- Thread1이 hasNext()  true를 받았으나 잠시 다른 일에 선점당한다.\r\n- Thread2가 hasNext()  true를 받고 next()를 호출한다.\r\n- Thread1이 실행을 재개하여 next()를 또 호출한다.\r\n\r\n\r\n### Client Based Lock\r\n#### 서버\r\n```java\r\n// 공유 자료\r\nIntegerInterator iterator = new IntegerIterator();\r\n\r\n// Thread에서 호출되는 코드\r\nwhile (true) {\r\n    int nextValue;\r\n    synchronized (iterator) {\r\n    \tif (!iterator.hasNext())\r\n        \tbreak;\r\n        nextValue = iterator.next();\r\n    }\r\n    doSomethingWith(nextValue);\r\n}\r\n```\r\n\r\n#### 클라이언트\r\n```java\r\n// 공유 자료\r\nIntegerInterator iterator = new IntegerIterator();\r\n\r\n// Thread에서 호출되는 코드\r\nwhile (true) {\r\n    int nextValue;\r\n    synchronized (iterator){\r\n        if (!iterator.hasNext())\r\n            break;\r\n        nextValue = iterator.next();\r\n    }\r\n    doSometingWith(nextValue);\r\n}\r\n```\r\n\r\n- 클라이언트에서 락을 걸어 Thread Safe 하게 블록을 보호한다\r\n- 자원을 사용하는 클라이언트마다 위의 처리를 해줘야 한다. 비효율적!\r\n\r\n### Server Based Lock\r\n\r\n#### 서버\r\n```java\r\npublic class IntegerIteratorServerLocked {\r\n    private Integer nextValue = 0;\r\n    \r\n    public syncronized Integer getNextOrNull() {\r\n        if (nextValue < 100000) \r\n            return nextValue++;\r\n        else \r\n            return null;\r\n    }\r\n}\r\n```\r\n#### 클라이언트 \r\n```java\r\n// 공유 자료\r\nIntegerInterator iterator = new IntegerIterator();\r\n\r\n// Thread에서 호출되는 코드\r\nwhile (true) {\r\n    Integer nextValue = iterator.getNextOrNull();\r\n    if (next == null) \r\n    \tbreak;\r\n}\r\n```\r\n- 서버에서 두 개로 나눠졌던 동작을 하나로 합쳐 락을 건다.\r\n- 클라이언트에서는 보호된 메서드를 호출하기만 하면 된다.\r\n\r\n### Adapter Based Lock\r\n\r\n#### 서버\r\n```java\r\npublic class IntegerIterator implements Iterator<Integer> {\r\n    private Integer nextValue = 0;\r\n    \r\n    public synchronized boolean hasNext() {\r\n    \treturn nextValue < 100000;\r\n    }\r\n    \r\n    public synchronized Integer next() {\r\n    \tif (nextValue == 100000) \r\n        \tthrow new InteratorPastEndException();\r\n        return nextValue++;\r\n    }\r\n    \r\n    public syncronized Integer getNextValue() {\r\n    \treturn nextValue;\r\n    }\r\n}\r\n```\r\n#### 어뎁터\r\n```java\r\npublic class ThreadSafeIntegerIterator {\r\n    private IntegerIterator iterator = new IntegerIterator();\r\n    \r\n    public synchronized Integer getNextOrNull() {\r\n    \tif (iterator.hasNext()) \r\n            return iterator.next();\r\n        return null;\r\n    }\r\n}\r\n```\r\n#### 클라이언트\r\n```java\r\n// 공유 자료\r\nThreadSafeIntegerIterator iterator = new ThreadSafeIntegerIterator();\r\n\r\n// Thread에서 호출되는 코드\r\nwhile (true) {\r\n    Integer nextValue = iterator.getNextOrNull();\r\n        if (next == null)\r\n            break;\r\n}\r\n```\r\n- 어댑터에서 서버에서 두 개로 나눠졌던 동작을 하나로 합쳐 락을 건다.\r\n- 클라이언트에서는 보호된 메서드를 호출하기만 하면 된다.\r\n- 서버의 코드가 외부 코드라서 수정할 수 없을 때 우리 코드에서 Adapter를 만들어 사용한다.\r\n----\r\n## 3. 동시성 테스트 방법\r\n\r\n> **테스트를 했다고 동시성 코드가 100% 올바르다고 증명하기는 불가능하다. 하지만 충분한 테스트는 위험을 낮춘다.**\r\n\r\n- 문제를 노출하는 테스트 케이스를 작성하라\r\n- 프로그램의 설정과 시스템 설정과 부하를 바꿔가며 자주 들려라\r\n- 테스트가 실패하면 원인을 추적하라\r\n- 다시 돌렸더니 통과한다는 이유로 그냥 넘어가면 절대로 안된다\r\n\r\n### 코드에 보조 코드를 넣어 돌려라\r\n\r\n> **드물게 발생하는 오류를 자주 발생시키도록 보조 코드를 추가한다**\r\n\r\n- 코드에 wait(), sleep(), yield(), priority() 함수를 추가해 직접 구현한다.\r\n- 보조코드를 넣어주는 도구를 사용해 테스트한다.\r\n  - 다양한 위치에 ThreadJigglePoint.jiggle() 추가해 무작위로 sleep, yield()가 호출되도록 한다.\r\n- 테스트 환경에서 보조 코드를 돌려본다.\r\n\r\n### 동시성 코드를 실제 환경이나 테스트 환경에서 돌려본다\r\n\r\n> 다양한 요청과 상황에 동시성 코드가 정상적으로 동작하는지 확인한다\r\n- 배포하기 전에 테스트 환경에서 충분히 오랜시간 검증한다.\r\n- 동시성 코드를 배포한 후에 모니터링을 통해 문제가 발생하는지 지켜본다.\r\n"},{"excerpt":"Chapter 12. 창발성\npage 215 ~ 224 1. 창발적 설계란 1) 창발성(Emergence) 창발성(創發性)\n명사 남이 모르거나 하지 아니한 것을 처음으로 또는 새롭게 밝혀내거나 이루어 내는 성질. 하위 계층에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출연하는 현상 각각의 개미는 집을 지을 능력이 없지만, 작은 개…","fields":{"slug":"/CleanCode-11/"},"frontmatter":{"date":"July 05, 2024","title":"[클린코드-11] 창발적 설계로 깔끔한 코드 구현하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 12. 창발성**<br>\r\n**page 215 ~ 224**\r\n\r\n## 1. 창발적 설계란\r\n\r\n### 1) 창발성(Emergence)\r\n\r\n>**창발성(創發性)**<br/>\r\n**명사** 남이 모르거나 하지 아니한 것을 처음으로 또는 새롭게 밝혀내거나 이루어 내는 성질.\r\n\r\n- 하위 계층에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출연하는 현상\r\n- 각각의 개미는 집을 지을 능력이 없지만, 작은 개미들의 상호작용을 통해 집이라는 결과물이 나오는 것처럼\r\n- 작은 요소들의 상호작용의 반복이 전체구조에 영향을 미친다.\r\n\r\n### 2) 창발적 설계\r\n#### 단순한 4가지를 반복하다보면 전체적으로 깨끗한 코드가 만들어진다.\r\n1. 모든 테스트를 실행한다.\r\n2. 중복을 없앤다.\r\n3. 프로그래머 의도를 표현한다.\r\n4. 실용적 관점에서 타협 한다.<br/>\r\n-켄트 백-\r\n\r\n---\r\n## 2. 모든 테스트를 실행한다\r\n\r\n### 테스트를 작성할수록 설계 품질이 좋아진다.\r\n- 모든 테스트 케이스를 항상 통과하는 시스템은 '**테스트가 가능한 시스템**'이다. 테스트가 불가능한 시스템은 검증도 불가능하고, 절대 출시하면 안된다. \r\n- 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다.\r\n- 결합도가 높으면 테스트 케이스를 작성하기 어렵기 때문에 결합도를 낮추는 설계를 하게 된다. \r\n- '모든 테스트를 실행한다.'는 규칙을 따르면 시스템은 낮은 결합도와 높은 응집도라는 목표를 저절로 달성할 수 있다.\r\n\r\n---\r\n## 3. 중복을 없앤다\r\n\r\n### 1) 기존의 코드를 최대한 재활용한다.\r\n#### 예제 1. 코드 재활용\r\n```java\r\nint size() {}\r\nboolean isEmpty() {}\r\n\r\n// 각 메서드를 따로 구현하는 방법도 있지만, 중복을 없애기 위해 서로 호출하도록 한다.\r\n\r\nboolean isEmpty() {\r\n    return this.size() == 0;\r\n}\r\n```\r\n### 2) 중복을 없앤다\r\n#### 예제 2. 나쁜 예 👎\r\n```java\r\npublic void scaleToOneDimension(float desiredDimension, float imageDimension) {\r\n  if (Math.abs(desiredDimension - imageDimension) < errorThreshold)\r\n    return;\r\n  float scalingFactor = desiredDimension / imageDimension;\r\n  scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);\r\n  \r\n  RenderedOpnewImage = ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor);\r\n  image.dispose();\r\n  System.gc();\r\n  image = newImage;\r\n}\r\n \r\npublic synchronized void rotate(int degrees) {\r\n  RenderedOpnewImage = ImageUtilities.getRotatedImage(image, degrees);\r\n  image.dispose();\r\n  System.gc();\r\n  image = newImage;\r\n}\r\n```\r\n- 중복된 코드를 별도의 메소드로 분리한다.\r\n\r\n#### 예제 3. 좋은 예 👍\r\n```java\r\npublic void scaleToOneDimension(float desiredDimension, float imageDimension) {\r\n  if (Math.abs(desiredDimension - imageDimension) < errorThreshold)\r\n    return;\r\n  float scalingFactor = desiredDimension / imageDimension;\r\n  scalingFactor = (float) Math.floor(scalingFactor * 10) * 0.01f);\r\n  replaceImage(ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor));\r\n}\r\n \r\npublic synchronized void rotate(int degrees) {\r\n  replaceImage(ImageUtilities.getRotatedImage(image, degrees));\r\n}\r\n \r\nprivate void replaceImage(RenderedOpnewImage) {\r\n  image.dispose();\r\n  System.gc();\r\n  image = newImage;\r\n}\r\n```\r\n- scaleToOneDimension, rotate replaceImage의 목적이 달라졌다.\r\n- 별도의 클래스로 분리하면 추후 재활용성이 높아진다.\r\n\r\n### Template Method 패턴\r\n- 알고리즘의 구조를 상위 클래스의 메소드에서 정의하고, 하위 클래스에서 자신에 맞게 세부 알고리즘을 정의한다.\r\n![](img.png)\r\nDailyRoutine - 알고리즘 <br/>\r\ngetUp 등 메서드 - 알고리즘의 각 단계\r\n\r\n- 구현하려는 알고리즘에 일정한 단계가 있고, 세부 단계마다 조금씩 구현 내용이 다를 때 사용한다.\r\n- 알고리즘의 여러 단계를 각 메서드로 선언하고, 그 알고리즘을 수행할 템플릿 메서드를 만든다.\r\n- 하위 클래스에서는 나눠진 메서드(단계)를 구현한다.\r\n\r\n\r\n#### 예제 4. 나쁜 예 👎\r\n```java\r\npublic class VacationPolicy {\r\n  public void accrueUSDDivisionVacation() {\r\n    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드\r\n    // ...\r\n    // 휴가 일수가 미국 최소 법정 일수를 만족하는지 확인하는 코드\r\n    // ...\r\n    // 휴가 일수를 급여 대장에 적용하는 코드\r\n    // ...\r\n  }\r\n  \r\n  public void accrueEUDivisionVacation() {\r\n    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드\r\n    // ...\r\n    // 휴가 일수가 유럽연합 최소 법정 일수를 만족하는지 확인하는 코드\r\n    // ...\r\n    // 휴가 일수를 급여 대장에 적용하는 코드\r\n    // ...\r\n  }\r\n}\r\n```\r\n- 최소 법정 일수를 계산하는 코드를 제외하면 두 메서드는 거의 동일하다.\r\n- 중복을 줄이기 위해 템플릿 에서드 패턴을 적용한다면?\r\n\r\n#### 예제 5. 좋은 예 👍\r\n```java\r\nabstract public class VacationPolicy {\r\n  public void accrueVacation() {\r\n    caculateBseVacationHours();\r\n    alterForLegalMinimums();\r\n    applyToPayroll();\r\n  }\r\n  \r\n  private void calculateBaseVacationHours() { /* ... */ };\r\n  abstract protected void alterForLegalMinimums();\r\n  private void applyToPayroll() { /* ... */ };\r\n}\r\n \r\npublic class USVacationPolicy extends VacationPolicy {\r\n  @Override protected void alterForLegalMinimums() {\r\n    // 미국 최소 법정 일수를 사용한다.\r\n  }\r\n}\r\n \r\npublic class EUVacationPolicy extends VacationPolicy {\r\n  @Override protected void alterForLegalMinimums() {\r\n    // 유럽연합 최소 법정 일수를 사용한다.\r\n  }\r\n}\r\n```\r\n\r\n- 공통된 알고리즘을 accrueVacation 템플릿 메서드에 담고, 동일한 내용에 대해서는 메서드를 구현하고 다른 내용(미국/유럽연합)은 하위 클래스가 구현하도록 abstract 메서드로 만든다.\r\n- 하위 클래스 UsVacationPolicy, EUVacationPolicy는 각자의 알고리즘을 구현한다.\r\n\r\n---\r\n## 4. 의도를 표현한다\r\n1. 좋은 이름을 선택한다.\r\n2. 함수와 클래스 크기를 가능한 줄인다.\r\n   - 작은 클래스와 작은 함수는 이름 짓기도 쉬우니까!\r\n3. 표준 명칭을 사용한다. 다른 개발자가 보고 바로 이해할 수 있도록\r\n   - 디자인 패턴을 사용했다면 그 이름을 클래스에 넣어준다.\r\n4. 단위 테스트 케이스를 꼼꼼하게 작성한다.\r\n5. 다른 사람을 위해 조금이라도 더 읽기 쉽게 만드려고 노력한다.\r\n\r\n---\r\n## 5. 실용적 관점에서 타협한다\r\n\r\n### 과도한 설계 No\r\n\r\n- 여러가지 규칙에 극단적으로 심취해 클래스와 메서드를 무수하게 만들지 말라.\r\n- 결국 좋은 코드를 만드는 이유는 생산성을 올리기 위한 것이다.\r\n- 실용적인 관점에서 타협해야 한다.\r\n\r\n**“개집 짓는데 사람 집 지으면 안된다”**\r\n\r\n### DIP\r\n\r\n**상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.\r\n추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.**\r\n\r\n- 하위 모텔의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.\r\n- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.\r\n\r\n#### 예제 6. 확장성이 떨어지는 예제\r\n```java\r\nclass PaymentController {\r\n  @RequestMapping(value = \"/api/payment\", method = RequestMethod.POST)\r\n  public void pay(@RequestBody ShinhanCardDto.PaymentRequest req) {\r\n    shinhanCardPaymentService.pay(req);\r\n  }\r\n}\r\n\r\nclass ShinhanCardPaymentService {\r\n  public void payShinhanCardDto.PaymentRquest req) {\r\n    shinhanCardApi.pay(req);\r\n  }\r\n}\r\n```\r\n~~새로운 카드사가 추가된다면~~<br>\r\n카드사 직영 가맹점이라 다른 카드는 절대 쓸 수 없다.\r\n\r\n```java\r\nclass PaymentController {\r\n  @RequestMapping(value = \"/api/payment\", method = RequestMethod.POST)\r\n  public void pay(@RequestBody CardPaymentDto.PaymentRequest req) {\r\n  if (req.getType() == CardType.SHINHAN) {\r\n    shinhanCardPaymentService.pay(req);\r\n  } else if(req.getType() == CardType.WOORI) {\r\n    wooriCardPaymentService.pay(req);\r\n  }\r\n}\r\n```\r\n~~확장에 유연하지 않다..~~<br/>\r\n확장에 유연할 필요가 없어진다..\r\n\r\n![](img_1.png)\r\n~~둘 다 추상화된 인터페이스에 의존하도록 한다.~~<br/>\r\n하나만 있을 클래스에 인터페이스를 만들 필요가 없다.\r\n\r\n### 예상치 못한 변경이 발생한다면?\r\n~~카드사 직영 가맹점이라 다른 카드는 절대 쓸 수 없다.~~<br/>\r\n새로운 카드사와 합병하여. 두 가지 카드를 쓰게 됐다..!\r\n\r\n> 그럼 그때 확장하는 설계를 하면 된다.  \r\n> 거의 발생하지 않을 일에 미리 투자하는 비용이 더 크다."},{"excerpt":"Chapter 11. 시스템\npage 193 ~ 214 “복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.” \n레이 오지(Ray Ozzie) 서론: 도시 만들기 도시를 세운다면? 도시를 세운다면 온갖 세세한 사항을 혼자서 직접 관리할 수는 없다. \n이미 세워진 도시라도 한 사람의 힘으로는 무리다. 그럼에…","fields":{"slug":"/CleanCode-10/"},"frontmatter":{"date":"July 04, 2024","title":"[클린코드-10] 클래스 잘 설계하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 11. 시스템**<br>\r\n**page 193 ~ 214**\r\n\r\n>“복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.”<br> \r\n**레이 오지(Ray Ozzie)**\r\n\r\n## 서론: 도시 만들기\r\n#### 도시를 세운다면?\r\n도시를 세운다면 온갖 세세한 사항을 혼자서 직접 관리할 수는 없다.<br> \r\n이미 세워진 도시라도 한 사람의 힘으로는 무리다. 그럼에도 불구하고 도시는 돌아간다.<br>\r\n도시가 돌아가는 이유에는 수도 관리, 전력 관리, 교통 관리 등 각 분야를 관리하는 팀이 있기 때문이다.<br> \r\n도시에는 큰 그림을 그리는 사람들도 있으며 작은 사항에 집중하는 사람들도 있다.<br>\r\n도시가 돌아가는 또 다른 이유는 적절한 추상화와 모듈화 때문이다.<br> \r\n그래서 큰 그림을 이해하지 못하더라도 개인과 개인이 관리하는 ‘구성요소’는 효율적으로 돌아간다.\r\n<br>\r\n\r\n소프트웨어 팀도 도시처럼 구성한다. 그런데 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다.<br> \r\n깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.<br> \r\n이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.\r\n\r\n\r\n## 1. 관심사 분리\r\n#### construction(생성)과 use(사용)은 아주 다르다\r\n- 소프트웨어 시스템은 (어플리케이션 객체를 제작하고 의존성을 서로 '연결’하는) **준비 과정**과 (준비 과정 이후에 이어지는) **런타임 로직**을 분리해야 한다.\r\n- **객체의 생성과 객체를 사용하는 부분을 분리한다**\r\n\r\n### 1) 시작에 대한 관심사 분리\r\n![](img.png)\r\n#### 객체의 생성은 시작단계에서, 비즈니스 로직은 객체를 사용하는데 집중한다\r\n- 시작 단계는 모든 어플리케이션이 풀어야할 관심사이다.\r\n- main 함수에서 시스템에 필요한 객체를 생성한 후 어플리케이션에 넘긴다.\r\n- 어플리케이션은 그저 만들어진 객체를 사용한다.\r\n- 모든 객체가 잘 생성되었다고 가정하고, 객체를 이용한 개발에 집중할 수 있다.\r\n\r\n### 2) 요청에 대한 관심사 분리\r\n#### spring 프레임 워크를 통해 요청에 대한 관심사를 분리해 요청 처리에 대한 비즈니스 로직에 집중할 수 있다\r\n![](img_1.png)\r\n\r\n**Filter, lntercepter, AOP**\r\n- 서블릿 필터는 Dispatcher Servlet 이전에 실행이 되는데, 요청 내용을 변경하거나 요청을 처리하기 전에 작업을 수행할 수 있다.\r\n- Filter와 Interceptor는 Servlet 단위에서 실행된다. 반면 AOP 는 메소드 앞에서 Proxy 패턴으로 실행된다.\r\n- 인터셉터는 여러 개를 사용할 수 있고 로그인 처리, 권한 체크, 프로그램 실행시간 계산작업, 로그 확인 등의 업무 처리에 활용된다.\r\n- AOP는 메서드 앞에서 Proxy 패턴으로 실행된다. 주로 '로깅', '트랜잭션', '에러처리' 등 비즈니스 단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용한다. AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.\r\n\r\n---\r\n\r\n## 2. Dependency Injection(의존성 주입)\r\n\r\n#### 객체 의존성을 DI 컨테이너에 맡긴다\r\n![](img_2.png)\r\n- Setter 메소드 or 생성자 인수를 통해 의존성을 주입한다.\r\n- DI 컨테이너는 요청이 들어올 때 필요한 객체의 인스턴스를 만든 후 의존성을 설정한다.\r\n- 예 : Spring IOC Container\r\n\r\n### Spring IoC Container\r\n\r\n![img_3.png](img_3.png)\r\n\r\n- DI 컨테이너가 객체를 알아서 wiring 해준다.\r\n\r\n---\r\n\r\n## 3. Cross Cutting Concerns(횡단 관심 분리)\r\n\r\n![Cross Cutting Concerns](img_4.png)\r\n#### 어플리케이션 전반에서 가지는 공통적인 관심사 분리한다.\r\n- 비즈니스 로직 외에 Logging, Transaction 관리, Security 등 신경써야할 관심사들이 많다.\r\n- 관심사들은 많은 어플리케이션 레이어에 퍼져있는데, 이 관심사들을 분리해 처리하는 것이 효율적이다.\r\n\r\n### 횡단 관심사 분리의 필요성\r\n#### 예제 1. before\r\n```java\r\npublic Response executeBusinessLogic(Request request) {\r\n  // 공통 기능\r\n  checkAuth(request);\r\n\r\n  // 비즈니스 로직\r\n  Response response = businesslogic(userName, message);\r\n\r\n  // 공통 기능\r\n  logging(response);\r\n}\r\n```\r\n\r\n#### 예제 2. after\r\n```java\r\npublic Response executeBusinessLogic(Request request) {\r\n  // 비즈니스 로직\r\n  Response response = businesslogic(userName, message);\r\n}\r\n\r\n// 공통 기능은 별도의 코드에서 관리한다.\r\n```\r\n- 비즈니스 로직에 집중할 수 있다\r\n\r\n### (Step.1) Java Proxy API\r\n- 자바에서 사용하는 관점 혹은 관점과 유사한 매커니즘들을 알아보자.\r\n- 자바 프록시는 단순한 상황에 적합한다.\r\n- 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예시이다.\r\n- 하지만 JDK에서 제공하는 동적 프록시는 인터페이스만 지원하며, 클래스 프록시를 사용하려면 CGLIB, ASM, Javassist 등과 같은 바이트 코드 처리를 위한 라이브러리가 필요하다.\r\n>참고<br/>\r\n**CGLIB** : Code Generator Library의 약자로 런타임에 동적으로 자바 클래스의 프록시를 생성해준다.<br/>\r\n**ASM** : 자바 바이트 코드 조직 및 분석 프레임워크<br/>\r\n**Javassist** : 동적으로 자바 클래스로 변경하는 바이트 코드 라이브러리<br/>\r\n\r\n\r\n#### Bank 객체에 Proxy API를 통해 영속성을 추가하는 과정\r\n이해를 위해 계좌 목록을 가져오는 설정하는 메서드만 살펴보자.<br/>\r\n먼저 프록시로 감쌀 Bank 인터페이스를 작성한다.\r\n```java\r\n// Bank.java\r\n// 은행 추상화\r\nimport java.util.*;\r\n\r\npublic interface Bank {\r\n    Collection<Account> getAccounts();\r\n    void setAccounts(Collection<Account> accounts);\r\n}\r\n```\r\n이후 비즈니스 로직을 구현하는 POJO인 BankImpl을 작성한다.\r\n```java\r\n// BankImpl.java\r\nimport java.util.*;\r\n\r\n// 추상화를 위한 POJO 구현\r\npublic class BankImpl implements Bank {\r\n    private List<Account> accounts;\r\n    \r\n    public Collectioin<Account> getAccounts() {\r\n        return accounts;\r\n    }\r\n    public void setAccounts(Collection<Account> accounts) {\r\n        this.accounts = new ArrayList<Account>();\r\n        for (Account account: accounts) {\r\n            this.accounts.add(account);\r\n        }\r\n    }\r\n}\r\n```\r\n프록시를 구현하려면 InvocationHandler 를 구현해야 한다.<br/>\r\n구현한 InvocationHandler는 프록시에 호출되는 Bank의 메서드를 구현하는데 사용한다.<br/>\r\nBankProxyHandler는 리플렉션을 이용해 제네릭스 메서드를 이에 상응하는 BankImpl 메서드로 매핑한다.<br/>\r\n\r\n```java\r\n// BankProxyHandler.java\r\n\r\n// 프록시 API가 필요한 \"InvocationHandler\"\r\npublic class BankProxyHandler implements InvocationHandler {\r\n    private Bank bank;\r\n\r\n    public BankProxyHandler(Bank bank) {\r\n        this.bank = bank;\r\n    }\r\n\r\n    // InvocationHandler에 정의된 메서드\r\n    public Object invoke(Object proxy, Method method, Object[] args) throw Throwable {\r\n        String methodName = method.getName();\r\n        if (methodName.equals(\"getAccounts\")) {\r\n          bank.setAccounts(getAccountsFromDatabase());\r\n          return bank.getAccounts();\r\n        } else if (methodName.equals(\"setAccounts\")) {\r\n          bank.setAccounts((Collection<Account>) args[0]);\r\n          setAccountsToDatabase(bank.getAccounts());\r\n          return null;\r\n        } else {\r\n          // ...\r\n        }\r\n    }\r\n\r\n    // 세부사항은 여기에 이어진다.\r\n    protected Collection<Account> getAccountsFromDatabase() {\r\n        // ...\r\n    }\r\n    protected void setAccountsToDatabase(Collection<Account> accounts) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n```java\r\n// 자바 Proxy API를 통해 호출\r\nBank bank = (Bank) Proxy.newProxyInstance(\r\n    Bank.class.getClassLoader(),\r\n    new Class[] { Bank.class }, \r\n    new BankProxyHandler(new BankImpl())\r\n);\r\n```\r\n\r\n- lnvocationHandler를 구현하는 BankProxyHandler를 생성한다. Java Reflection API를 이용해 Bank 인터페이스를 구현하는 객체의 메서드 호출을 가져온다. 데이터 베이스에서 데이터를 가져오는 과정을 추가한다.\r\n- ProxyAPI를 호출할 때 BankImpl 객체를 통해 생성한 BankProxyHandler와 Bank 인터페이스를 사용해 프록시된 인터페이스를 사용해 모델과 로직이 분리된 코드를 작성할 수 있다.<br/>\r\n  ⇒ 보시다시피 장점대비, 코드의 복잡성이 아직도 있음\r\n- 예제에서 알 수 있다시피, 자바 프록시는 코드의 양이 매우 커지는 것이 단점이다.\r\n\r\n> **참고** <br> \r\n동적 프록시가 아닌 일반 프록시는 대상 클래스 수만큼 프록시 클래스를 만들어야하며, 비슷한 코드의 중복이 발생하기 쉽다.\r\n\r\n### (Step.2) 순수 Java AOP Framework\r\n\r\n#### 스프링 2.5 설정 파일의 일부\r\n```xml\r\n<beans>\r\n    ...\r\n    <bean id=\"appDataSource\"\r\n        class=\"org.apache.commons.dbcp.BasicDataSource\"\r\n        destroy-method=\"close\"\r\n        p:driverClassName=\"com.mysql.jdbc.Driver\"\r\n        p:url=\"jdbc:mysql://localhost:3306/mydb\"\r\n        p:username=\"me\"/>\r\n    \r\n    <bean id=\"bankDataAccessObject\"\r\n        class=\"com.example.banking.persistence.BankDataAccessObject\"\r\n        p:dataSource-ref=\"appDataSource\"/>\r\n    \r\n    <bean id=\"bank\"\r\n        class=\"com.example.banking.model.Bank\"\r\n        p:dataAccessObject-ref=\"bankDataAccessObject\"/>\r\n    ...\r\n</beans>\r\n```\r\n- 각 bean은 러시아 인형의 일부분과 같다.\r\n- Bank 도메인 객체는 bankDataAccessObject(DAO)로 감싸며, DAO는 JDBC 드라이버 데이터 소스로 감싸진 형태로 구성된다.\r\n\r\n![](img_5.png)\r\n- 클라이언트는 Bank 객체에서 getAccount()를 호출한다고 믿지만 실제로는 Bank POJO의 기본 동작을 확장한 중첩 Decorator 객체 집합의 가장 외곽과 통신한다.\r\n- 필요에 따라 트랜잭션, 캐싱 등에도 Decorator를 추가할 수 있다.\r\n\r\n애플리케이션에서 DI 컨테이너에게 프록시 객체를 요청하려면 다음 코드가 필요하다\r\n```java\r\n  XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"app.xml\", getClass()));\r\n  Bank bank = (Bank) bf.getBean(\"bank\");\r\n```\r\n스프링 관련 자바 코드가 거의 필요 없으므로 애플리케이션은 **사실상 스프링과 독립적이다.**\r\n- EJB2 시스템이 가졌던 강한 결합이라는 문제가 모두 사라진다.\r\n- 이런 아키텍처를 통해 스프링 프레임워크는 EJB 버전 3을 완전히 뜯어고치는 계기를 제공했다.\r\n<br/>\r\n<br/>\r\n- 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP 프레임워크는 내부적으로 프록시를 사용한다.\r\n- 설정 파일이나 API를 사용해 객체의 역할을 설정한다\r\n- Bank 객체는 DAO로 프록시되었다.\r\n- 객체를 얻어올 때는 (XML 파일에 설정했던) DI 컨테이너에게 객체를 요청(getBean) 한다.\r\n  <br/>\r\n  <br/>\r\n- 대부분의 프록시 코드는 비슷한 코드로 구성되어 있어 자동화가 가능하다.\r\n- 스프링의 경우 비즈니스 로직을 POJO로 구현한다.\r\n- POJO는 순수하게 도메인에 초점을 맞추기 때문에 엔터프라이즈 프레임워크에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단한다. \r\n- 자바 프레임워크를 통해 영속성, 트랜잭션, 보안, 캐시, 예외 처리 등과 같은 횡단 관심사를 구현할 수 있다.\r\n\r\n### (Step.3) EJB3 - JPA같은 객체 영속성 관리 표준 API\r\n\r\n```java\r\n@Entity\r\n@Table(name = \"BANKS\")\r\npublic class Bank implements java.io.Serializable {\r\n    @Id \r\n    @GeneratedValue(strategy=GenerationType.AUTO)\r\n    private int id;\r\n    \r\n    @Embeddable // Bank의 데이터베이스 행에 '인라인으로 포함된' 객체\r\n    public class Address {\r\n        protected String streetAddr1;\r\n        protected String streetAddr2;\r\n        protected String city;\r\n        protected String state;\r\n        protected String zipCode;\r\n    }\r\n    \r\n    @Embedded\r\n    private Address address;\r\n\r\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy=\"bank\")\r\n    private Collection<Account> accounts = new ArrayList<Account>();\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n    \r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n    \r\n    public void addAccount(Account account) {\r\n        account.setBank(this);\r\n        accounts.add(account);\r\n    }\r\n    \r\n    public Collection<Account> getAccounts() {\r\n        return accounts;\r\n    }\r\n    \r\n    public void setAccounts(Collection<Account> accounts) {\r\n        this.accounts = accounts;\r\n    }\r\n}\r\n```\r\n- EJB2 코드보다 훨씬 깔끔해졌다.\r\n  - 모든 정보가 어노테이션 내부로 갈무리되어 코드가 깔끔해진 것이고, 그만큼 코드를 테스트하거나 유지보수하기 쉬워졌다.\r\n- annotation에 있는 영속성 정보 전부 또는 일부를 XML 설정으로 옮겨도 된다.\r\n  (실무에서는 annotation 사용을 선호한다)\r\n\r\n\r\n### AspectJ 관점\r\n![](img_6.png)\r\n\r\n관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어이다.\r\n\r\nAspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어의 확장이다.\r\n\r\n스프링 AOP와 JBoss AOP가 제공하는 순수 자바 방식은 관점이 필요한 상황의 80~90% 정도를 충족해준다.\r\n\r\nAspectJ는 나머지 10%를 채워주는 좋은 도구이지만, 새로운 도구이니만큼 사용법과 언어 문법을 익혀야할 필요성은 있다.\r\n\r\nAspectJ의 어노테이션 폼(annotation form)은 이 부담감을 경감시켜주긴 한다.\r\n\r\n어노테이션 폼은 순수한 자바 코드에 자바 5 어노테이션을 사용해 관점을 정의하기에 AspectJ에 대해 미숙한 상태여도 쉽게 사용할 수 있도록 해준다.\r\n\r\n"},{"excerpt":"Chapter 10. 클래스\npage 171 ~ 192 1.캡슐화되어야 한다  캡술화 : 객체의 실제 구현을 외부로부터 감추는 방식 클래스를 개발할 때 기본적으로 구현을 감추고, 외부 객체와 상호작용하는 부분만 노출한다 외부의 잘못된 사용을 방지한다 경계에서 배웠던 Map 과 동일한 개념 Stack 예제 필드를 private로 제한, get으로 읽기 수정…","fields":{"slug":"/CleanCode-9/"},"frontmatter":{"date":"July 02, 2024","title":"[클린코드-9] 클래스 잘 설계하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 10. 클래스**<br>\r\n**page 171 ~ 192**\r\n\r\n## 1.캡슐화되어야 한다\r\n\r\n![](img.png)\r\n\r\n### 캡술화\r\n: 객체의 실제 구현을 외부로부터 감추는 방식\r\n\r\n- 클래스를 개발할 때 기본적으로 구현을 감추고, 외부 객체와 상호작용하는 부분만 노출한다\r\n- 외부의 잘못된 사용을 방지한다\r\n- 경계에서 배웠던 Map 과 동일한 개념\r\n\r\n#### Stack 예제\r\n```java\r\npublic class Stack {\r\n        private int topOfStack = 0;\r\n        private List<Integer> element = new LinkedList<Integer>();\r\n\r\n        public List<Integer> getElements() {\r\n                return elements;\r\n        }\r\n\r\n        public int size() {\r\n                return topOfStack;\r\n        }\r\n\r\n        public void push() throws PoppedWhenEmpty {\r\n                if (topOfStack == 0) {\r\n                        throw new PoppedWhenEmpty();\r\n                }\r\n                int element = elements.get(--topOfStack);\r\n                elements.remove(topOfStack);\r\n                return element;\r\n        }\r\n}\r\n```\r\n- 필드를 private로 제한, get으로 읽기\r\n- 수정은 push, pop 메서드를 통해서 일어나도록 제한\r\n\r\n---\r\n\r\n## 2. 단일 책임 원칙(SRP)\r\n\r\n### 클래스는 작아야한다.\r\n\r\n#### 예제 1. 나쁜 코드👎\r\n```java\r\npublic class SuperDashboard extends JFrame implements MetaDataUser {\r\n    public Component getLastFocusedComponent()\r\n    public void setLastFocused(Component lastFocused)\r\n    public int getMajorVersionNumber()\r\n    public int getMinorVersionNumber()\r\n    public int getBuildNumber() \r\n}\r\n```\r\n-> \"focus, version 두 가지 책임이 보인다.\"\r\n\r\n#### 예제 2. 좋은 코드 👍\r\n```java\r\npublic Version {\r\n    public int getMajorVersionNumber()\r\n    public int getMinorVersionNumber()\r\n    public int getBuildNumber() \r\n}\r\n```\r\n-> 다른 곳에서도 재활용 할 수 있다.\r\n\r\n#### 클래스가 맡은 책임이 한 개인가\r\n\r\n- 함수와 마찬가지로 클래스도 작아야 한다.\r\n- 함수는 라인 수로 크기를 측정했는데, 클래스는 맡은 **책임**의 수로 크기를 측정한다.\r\n- 클래스 설명은 만일(if), 그리고(and), 하며 (or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다. → 책임이 한 가지여야 한다.\r\n\r\n<br/>\r\n\r\n- SRP 해야한다. 자잘한 단일 클래스가 많아지면 큰 그림을 이해하기 어렵다고 우려한다. <br>\r\n  하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하다.\r\n- \"도구상자를 어떻게 관리하고 싶은가?<br>\r\n작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가?<br> \r\n아니면 큰 서 몇 개를 두고 모두를 던져 넣고 싶은가?\"\r\n- 큼직한 다목적 클래스 및 개로 이뤼진 시스템은 (변경을 가할 때) 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.\r\n- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.\r\n\r\n### 단일 책임 원칙 중요성\r\n\r\n> 자잘한 단일 클래스가 많아지면 큰 그림을 이해하기 어렵다고 우려한다. <br>\r\n하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇개뿐인 시스템이든 돌아가는 부붐은 그 수가 비슷하다\r\n\r\n> 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 (변경을 가할 때)\r\n당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.\r\n\r\n```java\r\nclass PaymentService {\r\n    public void pay();\r\n    public void cancel();\r\n    public void getAccount();\r\n    public void getAccountHistory();\r\n}\r\n```\r\n\r\n**요구사항: 환불 기능을 추가하라**\r\n\r\n클래스가 많은 기능을 가진 만큼 모든 기능을 이해하고 추가 기능을 구현할 수 있다. <br>\r\n그리고 클래스는 더 많은 기능을 가지게 된다..\r\n\r\n> 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며,\r\n다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.\r\n\r\n#### 변경 전\r\n```java\r\nclass PaymentService {\r\n    public void pay();\r\n    public void cancel();\r\n    public void getAccount();\r\n    public void getAccountHistory();\r\n}\r\n```\r\n\r\n#### 변경 후\r\n```markdown\r\nPaymentService::pay\r\n (accountService.getAccount)\r\nPaymentCancelService::cancel\r\n (paymentService.getPay , accountService.getAccount)\r\nAccountService::getAccount\r\nAccountHistoryService::getAccountHistory\r\n```\r\n\r\n---\r\n\r\n## 3. 낮은 결합도, 높은 응집도\r\n\r\n**결합도**\r\n\r\n: 다른 모듈간의 의존도\r\n\r\n**응집도**\r\n\r\n: 모듈 내분의 기능 집중도\r\n\r\n### 결합도는 낮을 수록, 응집도는 높을 수록 유지보수성이 좋다.\r\n\r\n![](img_1.png)\r\n- 결합도란 다른 모듈간의 의존도를 말한다.\r\n- 응집도란 모듈 내부의 기능 집중도를 말한다.\r\n- 결합도는 낮을 수록, 응집도는 높을 수록 유지보수성이 좋다.\r\n\r\n### 1) 문제점\r\n- 결합도가 높은 클래스의 문제점\r\n  - 연관된 클래스가 변경되면 수정이 필요하다.\r\n  - 결합도가 높으면 연관된 클래스들을 모두 이해해야한다.\r\n- 응집도가 낮은 클래스의 문제점\r\n  - 여러 기능이 있으므로 이해하기 어렵다.\r\n  - 재사용하기 어렵다.\r\n\r\n### 2) 낮은 결합도\r\n\r\n#### 결합도는 낮아야한다\r\n\r\n- 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱높아진다.\r\n- DIP - 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다.\r\n- **추상화를 이용하면 테스트 코드 짜기에 용이하다.**\r\n\r\n#### 예제 3. 나쁜 예 👎\r\n```java\r\npublic class TokyoStockExchange {\r\n  public Money currentPrice(String symbol);\r\n}\r\n\r\npublic Protfolio {\r\n    private TokyoStockExchange tokyoStockExchange;\r\n    \r\n    public Portfolio(TokyoStockExchange exchange){\r\n        this.tokyoStockExchange = tokyoStockExchange;\r\n    }\r\n}\r\n```\r\n- TokyoStockExchange 함수의 API가 5분마다 값이 달라지는 상황이다.\r\n  - Portfolio 클래스 테스트 코드를 짜기 어렵다.\r\n\r\n#### 예제 4. 좋은 예 👍\r\n  \r\n```java\r\npublic interface StockExchange {\r\n  Money currentPrice(String symbol);\r\n}\r\n\r\npublic class TokyoStockExchange implements StockExchange {\r\n  public Money currentPrice(String symbol) {\r\n    // call API ...\r\n  }\r\n}\r\n\r\npublic Portfolio {\r\n  private stockExchange exchange;\r\n  public Portfolio(StockExchange exchange) {\r\n    this.exchange = exchange;\r\n  }\r\n}\r\n```\r\n- StockExchange 인터페이스를 통해 Portfolio와 tokyoStockExchange의 결합도를 끊어준다.\r\n\r\n#### 예제 5. 예제 4의 테스트코드\r\n```java\r\npublic class PortfolioTest {\r\n  private FixedStockExchangeStub exchange;\r\n  private Portfolio portfolio;\r\n  \r\n  @Before\r\n  protected void setUp() throws Exception {\r\n    exchange = new FixedStockExchangeStub();\r\n    exchange.fix(\"MSFT\", 100);\r\n    portfolio = new Portfolio(exchange);\r\n  }\r\n  \r\n  @Test\r\n  public void GivenFiveMSFTTotalShouldBe500() throws Exception {\r\n    portfolio.add(5, \"MSFT\");\r\n    AssertEquals(500, portfolio.value());\r\n  }\r\n}\r\n```\r\n- 테스트 결과가 늘 같도록 한다.\r\n- 객체를 Mocking하면 변경되는 클래스도 테스트할 수 있다.\r\n- **확장될 가능성이 적다면 일단 결합하고, 나중에 추상화해도 좋다.**\r\n\r\n### 3) 높은 응집도\r\n\r\n#### 응집도는 높아야한다.\r\n- 클래스는 인스턴스 변수 수가 적어야 한다.\r\n- 메서드는 인스턴스 변수를 하나 이상 사용해야 한다.\r\n- 메서드가 인스턴스 변수를 많이 사용할수록 응집도가 높다\r\n- 응집도가 높다= 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다 = 서로 관계있는 애들만 모여있다.\r\n- 클래스가 응집도를 잃어간다면 함수를 쪼개야 한다.\r\n\r\n#### 예제 6. 좋은 예 👍\r\n```java\r\npublic class Stack {\r\n    private int topOfStack = 0;\r\n    List<Integer> elements = new LinkedList<Integer>();\r\n\r\n    public int size() {\r\n        return topOfStack;\r\n    }\r\n\r\n    public void push(int element) {\r\n        topOfStack++;\r\n        elements.add(element);\r\n    }\r\n\r\n    public int pop() throws PoppedWhenEmpty {\r\n        if (topOfStack == 0)\r\n            throw new PoppedWhenEmpty();\r\n        int element = elements.get(--topOfStack);\r\n        elements.remove(topOfStack);\r\n        return element;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. 변경하기 쉬워야 한다.\r\n\r\n#### 예제 7. 나쁜 예 👎\r\n```java\r\npublic class Sql {\r\n    public Sql(String table, Column[] columns)\r\n    public String create()\r\n    public String insert(Object[] fields)\r\n    public String selectAll()\r\n    public String findByKey(String keyColumn, String keyValue)\r\n    public String select(Column column, String pattern)\r\n    public String select(Criteria criteria)\r\n    public String preparedInsert()\r\n    private String columnList(Column[] columns)\r\n    private String valuesList(Object[] fields, final Column[] columns) \r\n    private String selectWithCriteria(String criteria)\r\n    private String placeholderList(Column[] columns)\r\n}\r\n```\r\n- Update문을 추가해야 한다면?\r\n- 새로운 SQL을 추가할 때도 수정이 발생하고, 기존 SQL문을 수정할 때도 수정이 발생하므로 OCP가 위반된다.\r\n\r\n#### 예제 8. 좋은 예 👍\r\n```java\r\n    abstract public class Sql {\r\n  public Sql(String table, Column[] columns)\r\n  abstract public String generate();\r\n}\r\n\r\npublic class CreateSql extends Sql {\r\n  public CreateSql(String table, Column[] columns)\r\n  @Override public String generate()\r\n}\r\n\r\npublic class SelectSql extends Sql {\r\n  public SelectSql(String table, Column[] columns)\r\n  @Override public String generate()\r\n}\r\n\r\npublic class InsertSql extends Sql {\r\n  public InsertSql(String table, Column[] columns, Object[] fields)\r\n  @Override public String generate()\r\n  private String valuesList(Object[] fields, final Column[] columns)\r\n}\r\n\r\npublic class SelectWithCriteriaSql extends Sql {\r\n  public SelectWithCriteriaSql(\r\n          String table, Column[] columns, Criteria criteria)\r\n  @Override public String generate()\r\n}\r\n\r\npublic class SelectWithMatchSql extends Sql {\r\n  public SelectWithMatchSql(String table, Column[] columns, Column column, String pattern)\r\n  @Override public String generate()\r\n}\r\n\r\npublic class FindByKeySql extends Sql public FindByKeySql(\r\n        String table, Column[] columns, String keyColumn, String keyValue)\r\n        @Override public String generate()\r\n    }\r\n\r\npublic class PreparedInsertSql extends Sql {\r\n  public PreparedInsertSql(String table, Column[] columns)\r\n  @Override public String generate() {\r\n    private String placeholderList(Column[] columns)\r\n  }\r\n\r\n  public class Where {\r\n    public Where(String criteria) public String generate()\r\n  }\r\n\r\n  public class ColumnList {\r\n    public ColumnList(Column[] columns) public String generate()\r\n  }\r\n```\r\n- 공개 인터페이스를 전부 SQL 클래스에서 파생하는 클래스로 만들고, 비공개 메서드는 해당 클래스로 옮기고, 공통된 인터페이스는 따로 클래스로 했다.\r\n- 기존의 클래스를 건드리지 않아도 된다."},{"excerpt":"Chapter 09. 단위 테스트\npage 153 ~ 170 1. 테스트 코드의 중요성 테스트 코드는 중요하다 테스트 코드는 실수를 바로잡아준다. 테스트 코드는 반드시 존재해야하며, 실제 코드 못지 않게 중요하다. 테스트 케이스는 변경이 쉽도록 한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. \n테스트 케이스가 있으면 변…","fields":{"slug":"/CleanCode-8/"},"frontmatter":{"date":"July 01, 2024","title":"[클린코드-8] 깨끗한 테스트 코드","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 09. 단위 테스트**<br>\r\n**page 153 ~ 170**\r\n\r\n## 1. 테스트 코드의 중요성\r\n### 테스트 코드는 중요하다\r\n\r\n- 테스트 코드는 실수를 바로잡아준다.\r\n- 테스트 코드는 반드시 존재해야하며, 실제 코드 못지 않게 중요하다.\r\n- **테스트 케이스는 변경이 쉽도록 한다.** 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. <br>\r\n  테스트 케이스가 있으면 변경이 두렵지 않다. <br>\r\n  테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 커버리지가 높을수록 버그에 대한 공포가 줄어든다.\r\n- 지저분한 테스트 코드는 테스트를 안하니만 못하다.\r\n\r\n### 책에서 나온 [Effective unit testing] 테스트의 중요성\r\n\r\n> “\r\n테스트는 실사용에 적합한 설계를 끌어내준다.\r\n”\r\n>\r\n\r\n> “\r\n테스트를 작성해서 얻게 되는 가장 큰 수확은 테스트 자체가 아니다.\r\n작성 과정에서 얻는 **깨달음**이다.\r\n”\r\n>\r\n\r\n### 테스트는 자동화되어야한다\r\n\r\n![](img.png)\r\n\r\n개발자가 코드를 작성하고 테스트 코드를 양심껏 작성하는 것이 아니라 배포하기전에 테스트가 자동화가 되어야 한다.\r\n\r\n---\r\n\r\n## 2. 테스트의 종류\r\n\r\n### Test Pyramid\r\n\r\n![](img_1.png)\r\n#### 구글의 제안 : 70% unit tests, 20% integratoin tests, 10% end-to-end tests\r\n\r\n### 1) Unit Test\r\n- 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다.\r\n- 배포하기 전에 자동으로 실행되도록 많이 사용한다.\r\n\r\n### 2) Integration Test\r\n- 프로그램 내부의 개별 컴포넌트들을 합쳐서 동작을 테스트한다.\r\n- Unit Test는 각 컴포넌트를 고립시켜 테스트하기 때문에 컴포넌트의 interaction을 확인하는 integration Test가 필요하다.\r\n\r\n### 3) E2E Test\r\n- End to End test\r\n- 실제 유저의 시나리오대로 네트워크를 통해 서버의 Endpoint를 호출해 테스트한다.\r\n\r\n---\r\n\r\n## 3. Unit Test 작성\r\n\r\n### 1) 테스트 라이브러리를 사용하자\r\n\r\n**실무에서는 JUnit 5 + mockito를 많이 사용한다.**\r\n\r\n- JUnit : for unit test\r\n- Mockito : for mocking dependencies\r\n- Wiremock : for stubbing out external services\r\n- Pack : for writing CDC tests\r\n- Selenium : for writing UI-driven end-to-end tests\r\n- REST-assured : for writing REST API-driven end-to-end tests\r\n\r\n### 2) Test Double\r\n#### 테스트에서 원본 객체를 대신하는 객체\r\n**1. Stub**\r\n- 원래의 구현을 단순한 것으로 대체한다.\r\n- 테스트를 위해 프로그래밍된 항목에만 응답한다.\r\n\r\n**2. Spy**\r\n- Stub의 역할을 하면서 호출에 대한 정보를 기록한다.\r\n- 이메일 서비스에서 메시지가 몇 번 전송되었는지 확인할 때\r\n\r\n**3. Mock**\r\n- 행위를 검증하기 위해 가짜 객체를 만들어 테스트하는 방법\r\n- 호출에 대한 동작을 프로그래밍 할 수 있다.\r\n- Stub은 상태를 검증하고 Mock을 행위를 검증한다.\r\n\r\n#### given-when-then 패턴을 사용하자\r\n\r\n```java\r\npublic testGetPageHierarchyAsxml() throws Exception {\r\n  givenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\");\r\n\r\n  whenRequestIsIssued(\"root\", \"type:pages\");\r\n\r\n  thenResponseShouldBeXML();\r\n}\r\n\r\npublic void testGetPageHierarchyHasRightTags() throws Exception {\r\n  givenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\");\r\n\r\n  whenRequestIsIssued(\"root\", \"type:pages\");\r\n\r\n  thenResponseShouldContain(\"<name>PageOne</name>\", \"<name>ChildOne</name>\", \"<name>PageTwo</name>\");\r\n}\r\n```\r\n\r\n- given: 테스트에 대한 pre-condition\r\n- when: 테스트하고 싶은 동작 호출\r\n- then 테스트 결과 확인\r\n\r\n### 4) Spring Boot Application Test 예제\r\n\r\n![https://martinfowler.com/articles/practical-test-pyramid.html](img_2.png)\r\n\r\n#### (1) 테스트 대상 ExampleController - main코드\r\n\r\n```java\r\n@RestController\r\npublic class ExampleController {\r\n\r\n    private final PersonRepository personRepo;\r\n\r\n    @Autowired\r\n    public ExampleController(final PersonRepository personRepo) {\r\n        this.personRepo = personRepo;\r\n    }\r\n\r\n    @GetMapping(\"/hello/{lastName}\")\r\n    public String hello(@PathVariable final String lastName) {\r\n        Optional<Person> foundPerson = personRepo.findByLastName(lastName);\r\n\r\n        return foundPerson\r\n                .map(person -> String.format(\"Hello %s %s!\",\r\n                        person.getFirstName(),\r\n                        person.getLastName()))\r\n                .orElse(String.format(\"Cannot hello to unknown\")); // 이부분 테스트\r\n    }\r\n}\r\n```\r\n\r\n해당 부분을 어떻게 테스트 해야하는지 보자\r\n\r\n#### (2) Unit Test - Controller\r\n\r\n```java\r\npublic class ExampleControllerTest {\r\n\t\r\n    // 테스트 대상\r\n    private ExampleController subject;\r\n\r\n    @Mock\r\n    private PersonRepository personRepo;\r\n\r\n    @Before\r\n    public void setUp() throws Exception {\r\n        initMocks(this);\r\n        subject = new ExampleController(personRepo);\r\n    }\r\n\r\n    @Test\r\n    public void shouldReturnFullNameOfAPerson() throws Exception {\r\n    \t// given\r\n        Person peter = new Person(\"Peter\", \"Pan\");\r\n        given(personRepo.findByLastName(\"Pan\"))\r\n            .willReturn(Optional.of(peter));\r\n\r\n\t// when\r\n        String greeting = subject.hello(\"Pan\");\r\n\r\n\t// then\r\n        assertThat(greeting, is(\"Hello Peter Pan!\"));\r\n    }\r\n\r\n    @Test\r\n    public void shouldTellIfPersonIsUnknown() throws Exception {\r\n    \t// given\r\n        given(personRepo.findByLastName(anyString()))\r\n            .willReturn(Optional.empty());\r\n\r\n\t// when\r\n        String greeting = subject.hello(\"Pan\");\r\n\r\n\t// then\r\n        assertThat(greeting, is(\"Cannot hello to unknown\"));\r\n    }\r\n}\r\n```\r\n![](img_3.png)\r\n\r\n- PersonRepository mock 사용\r\n  - 테스트하고자 하는 Controller는 Repository에서 데이터를 가져와야 한다.\r\n  - 독립성을 유지하기 위해 실제 Repositiory에서 데이터를 가져오지 않고 mocking하여 사용한다.\r\n- given-when-then 구조\r\n- repository에서 값을 읽어왔을 때와 읽어오지 못했을 때 2가지 경우를 테스트\r\n\r\n#### (3) Integration Test(Database)\r\n\r\n```java\r\n@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\npublic class PersonRepositoryIntegrationTest {\r\n    @Autowired\r\n    private PersonRepository subject;\r\n\r\n    @After\r\n    public void tearDown() throws Exception {\r\n        subject.deleteAll();\r\n    }\r\n\r\n    @Test\r\n    public void shouldSaveAndFetchPerson() throws Exception {\r\n    \t// given\r\n        Person peter = new Person(\"Peter\", \"Pan\");\r\n        subject.save(peter);\r\n\r\n\t// when\r\n        Optional<Person> maybePeter = subject.findByLastName(\"Pan\");\r\n\r\n\t// then\r\n        assertThat(maybePeter, is(Optional.of(peter)));\r\n    }\r\n}\r\n```\r\n\r\n![](img_4.png)\r\n\r\n- PersonRepository가 데이터베이스와 연결될 수 있는지 확인\r\n- in-memory DB인 h2로 테스트\r\n  - 실제 Database를 사용하지 않고, MySQL 등을 사용하여 내 서버(내 컴퓨터)에서 동일한 형태의 database를 구축하여 사용한다.\r\n- @After 부분의 tearDown 메서드는 독립성을 유지하기 위해 테스트 후 데이터 리셋 용도이다.\r\n- firstByLastName가 정상적으로 동작하는지 확인\r\n\r\n#### (4) Integration Test(Service)\r\n\r\n```java\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class WeatherClientIntegrationTest {\r\n\r\n    @Autowired\r\n    private WeatherClient subject;\r\n\r\n    @Rule\r\n    public WireMockRule wireMockRule = new WireMockRule(8089); // mock 서버를 띄운다.\r\n\r\n    @Test\r\n    public void shouldCallWeatherService() throws Exception {\r\n    \t// given : mock 서버에 응답을 설정한다.\r\n        wireMockRule.stubFor(get(urlPathEqualTo(\"/some-test-api-key/53.5511,9.9937\"))\r\n                .willReturn(aResponse()\r\n                        .withBody(FileLoader.read(\"classpath:weatherApiResponse.json\"))\r\n                        .withHeader(CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\r\n                        .withStatus(200)));\r\n\r\n\t// when : weatherClient가 mock 서버로부터 응답을 받는다.\r\n        Optional<WeatherResponse> weatherResponse = subject.fetchWeather();\r\n\r\n\t// then : 받아온 응답이 기대값과 일치하는 지 확인한다.\r\n        Optional<WeatherResponse> expectedResponse = Optional.of(new WeatherResponse(\"Rain\"));\r\n        assertThat(weatherResponse, is(expectedResponse));\r\n    }\r\n}\r\n```\r\n\r\n![](img_5.png)\r\n- WireMock을 이용해 mock 서버를 띄운다.\r\n- client가 실제 서버가 아닌 mock 서버로 요청하게 해서 client의 동작을 테스트한다.\r\n- \r\n---\r\n\r\n## 4. FIRST 원칙 - 유닛테스트를 잘 작성하기 위한 방법\r\n\r\n### 1) Fast \r\n: 빠르게 테스트는 빨리 돌아야 한다. 자주 돌려야 하기 때문이다.\r\n\r\n### 2) lndependent\r\n: 독립적으로 각 테스트를 독립적으로 작성한다. 서로에게 의존하면 실패한 원인을 찾기 어려워진다. (다른 테스트의 실패로 인한건지, 코드 오류인지)\r\n\r\n### 3) RepeatabIe\r\n: 반복가능하게 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 모든 환경에서 돌아가야 한다.\r\n\r\n### 4) Self-Validating\r\n: 자가검증하는 테스트는 bool 값으로 결과를 내야 한다.\r\n\r\n### 5) Timely\r\n: 적시에 테스트하려는 실제 코드를 구현하기 직전에 구현한다.\r\n\r\n---\r\n\r\n## 5. 오픈소스 속 Unit Test\r\n\r\n### Trino (PrestoSQL)\r\n\r\n```java\r\npublic class TestTypeCalculation\r\n{\r\n    @Test\r\n    public void testBasicUsage()\r\n    {\r\n        assertEquals(Long.valueOf(42), calculateLiteralValue(\"42\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(0), calculateLiteralValue(\"NULL\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(0), calculateLiteralValue(\"null\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(42), calculateLiteralValue(\"x\", ImmutableMap.of(\"x\", 42L)));\r\n        assertEquals(Long.valueOf(42), calculateLiteralValue(\"(42)\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(0), calculateLiteralValue(\"(NULL)\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(42), calculateLiteralValue(\"(x)\", ImmutableMap.of(\"x\", 42L)));\r\n\r\n        assertEquals(Long.valueOf(42 + 55), calculateLiteralValue(\"42 + 55\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(42 - 55), calculateLiteralValue(\"42 - 55\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(42 * 55), calculateLiteralValue(\"42 * 55\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(42 / 6), calculateLiteralValue(\"42 / 6\", ImmutableMap.of()));\r\n\r\n        assertEquals(Long.valueOf(42 + 55 * 6), calculateLiteralValue(\"42 + 55 * 6\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf((42 + 55) * 6), calculateLiteralValue(\"(42 + 55) * 6\", ImmutableMap.of()));\r\n\r\n        assertEquals(Long.valueOf(2), calculateLiteralValue(\"min(10,2)\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(10), calculateLiteralValue(\"min(10,2*10)\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(20), calculateLiteralValue(\"max(10,2*10)\", ImmutableMap.of()));\r\n        assertEquals(Long.valueOf(10), calculateLiteralValue(\"max(10,2)\", ImmutableMap.of()));\r\n\r\n        assertEquals(Long.valueOf(42 + 55), calculateLiteralValue(\"x + y\", ImmutableMap.of(\"x\", 42L, \"y\", 55L)));\r\n    }\r\n}\r\n```\r\nhttps://github.com/trinodb/trino/blob/master/core/trino-parser/src/test/java/io/trino/type/TestTypeCalculation.java\r\n\r\n- calculateLiteralValue를 테스트하고 있다.\r\n- 호출과 동시에 assert로 결과값을 검증한다.\r\n- 테스트 하나에 여러 assert가 사용된다.<br>\r\n  책에서 권장하는 방식이 아니지만, '조건’을 달리하며 테스트하는 경우 많이 사용된다.\r\n- 테스트 클래스명이 Test로 시작한다. 원래 ~Test로 끝나는게 일반적이지만 이 프로젝트의 컨벤션이다.<br>\r\n  팀 간의 협의(컨벤션)이 일반적인 컨벤션보다 우선이다.\r\n\r\n### Junit5 Samples\r\n```java\r\nclass CalculatorTests {\r\n\r\n\t@Test\r\n\t@DisplayName(\"1 + 1 = 2\")\r\n\tvoid addsTwoNumbers() {\r\n\t\tCalculator calculator = new Calculator();\r\n\t\tassertEquals(2, calculator.add(1, 1), \"1 + 1 should equal 2\");\r\n\t}\r\n\r\n\t@ParameterizedTest(name = \"{0} + {1} = {2}\")\r\n\t@CsvSource({\r\n\t\t\t\"0,    1,   1\",\r\n\t\t\t\"1,    2,   3\",\r\n\t\t\t\"49,  51, 100\",\r\n\t\t\t\"1,  100, 101\"\r\n\t})\r\n\tvoid add(int first, int second, int expectedResult) {\r\n\t\tCalculator calculator = new Calculator();\r\n\t\tassertEquals(expectedResult, calculator.add(first, second),\r\n\t\t\t\t() -> first + \" + \" + second + \" should equal \" + expectedResult);\r\n\t}\r\n}\r\n```\r\nhttps://github.com/junit-team/junit5-samples/blob/main/junit5-jupiter-starter-ant/src/test/java/com/example/project/CalculatorTests.java\r\n\r\n- @DisplayName은 테스트 클래스나 메서드에 보여질 이름을 입력하는 것이다. 테스트의 목적을 명확하게 작정할수 있다.\r\n- @ParameterizedTest는 하나의 테스트 메서드로 여러 가지 paramter를 테스트할 수 있다. @CsvSource의 값을 parameter로 넘긴다.\r\n- JUnit5가 테스트에 관한 유용한 기능을 많이 가지고 있기 때문에 실무에서 많이 사용한다."},{"excerpt":"Chapter 08. 경계\npage 143 ~ 152 1. 경계란  오픈소스, 라이브러리를 안쓰는 프로젝트는 없다. 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다. 외부 코드는 외부에서 만든 코드인데, 외부 시스템과 호출하거나 단순히 외부에서 만들어진 코드일 수 있다. 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야 한다. …","fields":{"slug":"/CleanCode-7/"},"frontmatter":{"date":"June 30, 2024","title":"[클린코드-7] 모호한 경계를 적당히 구분짓기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 08. 경계**<br>\r\n**page 143 ~ 152**\r\n\r\n## 1. 경계란\r\n\r\n![](img.png)\r\n\r\n- 오픈소스, 라이브러리를 안쓰는 프로젝트는 없다.\r\n- 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다.\r\n- 외부 코드는 외부에서 만든 코드인데, 외부 시스템과 호출하거나 단순히 외부에서 만들어진 코드일 수 있다.\r\n- 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야 한다.\r\n\r\n--- \r\n\r\n## 2. 경계 짓기(1) 우리코드를 보호하기\r\n\r\n### 캡슐화\r\n\r\n![](img_1.png)\r\n- 객체의 실제 구현을 외부로부터 감추는 방식(TMI를 하지 않아야 함)\r\n\r\n```java\r\n👎 Bad\r\n\r\nmap<Sensor> sensors = new hashMap<sensor>();\r\nSensor s = sensors.get(sensorId);\r\n```\r\n\r\n- Map 인터페이스가 제공하는 clear등 불필요한 기능이 노출된다.\r\n- 외부 코드가 함부로 호출하면 sensor 데이터가 손상될 수 있고, 이는 의도와 벗어난다.\r\n\r\n```java\r\n👍 Good\r\n\r\npublic class Sensors {\r\n    private Map sensors = new HashMap();\r\n \r\n    public Sensor getById(String id) {\r\n        return (Sensor) sensors.get(id);\r\n    }\r\n    // ..\r\n}\r\n```\r\n- 캡슐화를 통해 Map을 감춘다.\r\n- 원하는 기능만 공개할 수 있다.\r\n- 적절한 경계로 우리 코드를 보호할 수 있다.\r\n\r\n#### **Sensor를 관리해야 한다. Sensor는 외부에서 사용된다.**\r\n\r\n- Sensor id와 Sensor 객체로 저장하고 싶어서, Map을 사용한다.\r\n- 하지만 Map을 그대로 사용하면 Map이 가진 clear()가 외부로 노출된다.\r\n- Sensor의 '외부' 코드 관점에서 Sensor 객체의 값들만 가저오고 싶다.\r\n- 캡슐화를 한다!\r\n\r\n----\r\n\r\n## 3. 경계 짓기(2) 외부 코드와 호환하기\r\n\r\n: 외부 코드를 호출할 때 우리가 원하는 방식으로 사용하고 싶다!\r\n\r\n\r\n![어뎁터 패턴](img_2.png)\r\n### 어뎁터패턴 (Adapter Pattern)\r\n\r\n**📍 외부 코드를 호출 할 때, 우리가 정의한 인터페이스 대로 호출하기 위해 사용하는 패턴**\r\n\r\n### 🤚 Adapter 패턴 in Elastic Search\r\n: elastic search 에서 이러한 외부 라이브러리를 Adapter pattern 를 통해 사용하였는지 알아보자!\r\n\r\n#### NettyAdapter\r\n```java\r\npackage org.elasticsearch.http.nio;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.channel.ChannelHandler;\r\nimport io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\r\nimport io.netty.channel.ChannelPromise;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n\r\nimport org.elasticsearch.ExceptionsHelper;\r\nimport org.elasticsearch.nio.FlushOperation;\r\nimport org.elasticsearch.nio.Page;\r\nimport org.elasticsearch.nio.WriteOperation;\r\n\r\nimport java.nio.ByteBuffer;\r\nimport java.util.LinkedList;\r\nimport java.util.function.BiConsumer;\r\n\r\nclass NettyAdaptor {\r\n\r\n    private final EmbeddedChannel nettyChannel;\r\n    private final LinkedList<FlushOperation> flushOperations = new LinkedList<>();\r\n\r\n    NettyAdaptor(ChannelHandler... handlers) {\r\n        nettyChannel = new EmbeddedChannel();\r\n        nettyChannel.pipeline().addLast(\"write_captor\", new ChannelOutboundHandlerAdapter() {\r\n\r\n            @Override\r\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\r\n                // This is a little tricky. The embedded channel will complete the promise once it writes the message\r\n                // to its outbound buffer. We do not want to complete the promise until the message is sent. So we\r\n                // intercept the promise and pass a different promise back to the rest of the pipeline.\r\n\r\n                try {\r\n                    ByteBuf message = (ByteBuf) msg;\r\n                    promise.addListener((f) -> message.release());\r\n                    NettyListener listener = NettyListener.fromChannelPromise(promise);\r\n                    flushOperations.add(new FlushOperation(message.nioBuffers(), listener));\r\n                } catch (Exception e) {\r\n                    promise.setFailure(e);\r\n                }\r\n            }\r\n        });\r\n        nettyChannel.pipeline().addLast(handlers);\r\n    }\r\n\r\n    public void close() throws Exception {\r\n        assert flushOperations.isEmpty() : \"Should close outbound operations before calling close\";\r\n\r\n        ChannelFuture closeFuture = nettyChannel.close();\r\n        // This should be safe as we are not a real network channel\r\n        closeFuture.await();\r\n        if (closeFuture.isSuccess() == false) {\r\n            Throwable cause = closeFuture.cause();\r\n            ExceptionsHelper.maybeDieOnAnotherThread(cause);\r\n            throw (Exception) cause;\r\n        }\r\n    }\r\n\r\n    public void addCloseListener(BiConsumer<Void, Exception> listener) {\r\n        nettyChannel.closeFuture().addListener(f -> {\r\n            if (f.isSuccess()) {\r\n                listener.accept(null, null);\r\n            } else {\r\n                final Throwable cause = f.cause();\r\n                ExceptionsHelper.maybeDieOnAnotherThread(cause);\r\n                assert cause instanceof Exception;\r\n                listener.accept(null, (Exception) cause);\r\n            }\r\n        });\r\n    }\r\n\r\n    public int read(ByteBuffer[] buffers) {\r\n        ByteBuf byteBuf = Unpooled.wrappedBuffer(buffers);\r\n        int initialReaderIndex = byteBuf.readerIndex();\r\n        nettyChannel.writeInbound(byteBuf);\r\n        return byteBuf.readerIndex() - initialReaderIndex;\r\n    }\r\n\r\n    public int read(Page[] pages) {\r\n        ByteBuf byteBuf = PagedByteBuf.byteBufFromPages(pages);\r\n        int readableBytes = byteBuf.readableBytes();\r\n        nettyChannel.writeInbound(byteBuf);\r\n        return readableBytes;\r\n    }\r\n\r\n    public Object pollInboundMessage() {\r\n        return nettyChannel.readInbound();\r\n    }\r\n\r\n    public void write(WriteOperation writeOperation) {\r\n        nettyChannel.writeAndFlush(writeOperation.getObject(), NettyListener.fromBiConsumer(writeOperation.getListener(), nettyChannel));\r\n    }\r\n\r\n    public FlushOperation pollOutboundOperation() {\r\n        return flushOperations.pollFirst();\r\n    }\r\n\r\n    public int getOutboundCount() {\r\n        return flushOperations.size();\r\n    }\r\n}\r\n```\r\n\r\n- 위 코드에서 처럼 엘라스틱서치 NettyAdapter.class 를 보면 (11~18) 라인에서 Netty라는 외부 코드를 사용하는것을(import) 볼 수 있다.\r\n- NettyAdapter 은 외부코드인 NettyChannel을 감싸고 있다.\r\n- 이렇게 되면 NettyChannel 을 사용하기 위해선 NettyAdapter을 통해서 사용을 해야한다\r\n\r\n```java\r\n// HttpReadWriteHandler \r\npublic class HttpReadWriteHandler implements ReadWriteHandler {\r\n\r\n    private final NettyAdaptor adaptor;\r\n    \r\n    ...\r\n    \r\n    @Override\r\n    public int consumeReads(InboundChannelBuffer channelBuffer) throws IOException {\r\n        int bytesConsumed = adaptor.read(channelBuffer.sliceAndRetainPagesTo(channelBuffer.getIndex()));\r\n        Object message;\r\n        while ((message = adaptor.pollInboundMessage()) != null) {\r\n            handleRequest(message);\r\n        }\r\n\r\n        return bytesConsumed;\r\n    }\r\n```\r\n이렇게 하면 아래와 같은 **장점**들이 생기게된다.\r\n\r\n- 우리가 원하는 방식인 read할 때 ByteBuffer[]로 parameter를 보내면, 외부 코드인 nettyChannel에 ByteBuf 타입으로 parameter를 변환하여 전달한다.\r\n- Page[]타입 parameter로도 전달할 수 있다. Adapter에 메서드를 추가해 우리가 원하는 타입의 파라미터를 전달할 수 있다.\r\n- 만약 adapter를 통한 변환을 거치지 않았다면 nettyChannel에 데이터를 전달할 때마다 타입을 변환하는 과정이 필요했고, 이는 중복을 발생시켰을 것이다.\r\n\r\n---\r\n## 4. 외부 라이브러리 테스트하기 - Learning Test\r\n\r\n**📍 Learning Test를 작성해 라이브러리를 테스트한다.**\r\n\r\n**🤚이미 거기서 테스트를 하지 않았을까? 근데 라이브러리를 '사용'하는 내가 테스트를?**\r\n\r\n![](img_3.png)\r\n- 학습 테스트는 이해도를 높인다.\r\n- 학습 테스트 : 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 태신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방식\r\n- 외부 코드의 버전이 변경됐을 때, **우리 코드와 호환되는지 확인할 수 있다.**\r\n- API, 라이브러리, 프레임워크가 어떻게 동작하는 지 검증하기 위한 테스트\r\n- 기능 검증을 위한 테스트가 아님\r\n"},{"excerpt":"Chapter 07. 오류 처리\npage 129 ~ 142 1. 예외 처리 방식 1) 오류 코드를 리턴하지 말고, 예외를 던져라 옛날에는 오류를 나타낼 때 에러코드를 던졌다. 하지만 예외를 던지는 것이 명확하고, 처리 흐름이 깔끔해진다. 2) 예외를 던지고, 처리하는 방식 1번 구역. 오류가 발생한 부분에서 예외를 던진다.\n(별도의 처리가 필요한 예외라면…","fields":{"slug":"/CleanCode-6/"},"frontmatter":{"date":"June 29, 2024","title":"[클린코드-6] 우아하게 예외 처리하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 07. 오류 처리**<br>\r\n**page 129 ~ 142**\r\n\r\n\r\n## 1. 예외 처리 방식\r\n### 1) 오류 코드를 리턴하지 말고, 예외를 던져라\r\n\r\n```java\r\n👎 Bad\r\npublic class DeviceController {\r\n...\r\n   public void sendShutDown( ) {\r\n        DeviceHandle handle = getHandle(DEV1);\r\n        // Check the state of the device\r\n        if ( handle != DeviceHandle.INVALID ) {\r\n            // Save the device status to the record field\r\n            retrieveDeviceRecord(handle);\r\n            // If not suspended, shut down\r\n            if ( record.getStatus( ) != DEVICE_SUSPENDED ) {\r\n                pauseDevice(handle);\r\n                clearDeviceWorkQueue(handle);\r\n                closeDevice(handle);\r\n            } else {\r\n                logger.log(\"Device suspended. Unable to shut down\");\r\n            }\r\n        } else {\r\n          logger.log(\"Invalid handle for : \" + DEV1.toString( )); \r\n       }\r\n   }\r\n...\r\n}\r\n```\r\n- 옛날에는 오류를 나타낼 때 에러코드를 던졌다.\r\n- 하지만 예외를 던지는 것이 명확하고, 처리 흐름이 깔끔해진다.\r\n\r\n### 2) 예외를 던지고, 처리하는 방식\r\n```java\r\npublic class DeviceController {\r\n...\r\n  3번구역 \r\n   public void sendShutDown( ) {\r\n        try {\r\n            tryToShutDown( );\r\n        }  catch (DeviceShutDownError e) {\r\n            logger.log(e);\r\n        }\r\n   }\r\n\r\n 2번구역 \r\n   public void tryToShutDown( ) throws DeviceShutDownError {\r\n        DeviceHandle handle = getHandle(DEV1);\r\n        DeviceRecord record = retrieveDeviceRecord(handle);\r\n        pauseDevice(handle);\r\n        clearDeviceWorkQueue(handle);\r\n        closeDevice(handle);\r\n   }\r\n        \r\n1번구역\r\n   private DeviceHandle getHandle(DeviceId id) {\r\n     ...\r\n     throw new DeviceShutDownError (\"Invalid handle for : \" + id.toString( ));\r\n     ...\r\n   }\r\n...\r\n} \r\n```\r\n\r\n- 1번 구역. 오류가 발생한 부분에서 예외를 던진다.<br>\r\n  (별도의 처리가 필요한 예외라면 checked exception으로 던진다)\r\n- 2번 구역. checked exception에 대한 예외처리를 하지 않는다면 메서드 선언부에 throws를 명시해야한다.\r\n- 3번 구역. 예외를 처리할 수 있는 곳에서 catch 하여 처리한다.\r\n\r\n\r\n----\r\n## 2. Unchecked Exception을 사용하라\r\n\r\n### 1) Checked vs Unchecked Exception\r\n#### Exception 가계도\r\n![https://www.nextree.co.kr/p3239/](img.png)\r\n\r\n• **Exception**을 상속하면 **Checked Exception** 명시적인 예외처리가 필요하다.<br>\r\n(예) lOException, SQLException<br>\r\n• **RuntimeException**을 상속하면 **Unchekced Exception** 명시적인 예외처리가 필요하지 않다.<br>\r\n(예) NullPointerException, lllegalArgumentException, IndexOutOfBoundException\r\n\r\n### 2) <Effective Java> Exception에 관한 규약\r\n\r\n> 자바 언어 명세가 요구하는 것은 아니지만, 업계에 널리 퍼진 규약으로<br>\r\n**Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하자.**<br>\r\n즉, 사용자가 직접 구현하는 uncheked throwable은 모두 <span style=\"color:red\">**RuntimeException의 하위 클래스**</span> 여야 한다.<br>\r\nException, RuntimeException, Error를 상속하지 않는 throwable을 만들 수도 있지만, 이러한 throwable은 정상적인 사항보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐이므로 절대로 사용하지 말자.\r\n\r\n\r\n### 3) Checked Exception이 나쁜 이유\r\n```java\r\n👍 Good 코드를 다시보자\r\n\r\npublic class DeviceController {\r\n...\r\n  3번구역 \r\n   public void sendShutDown( ) {\r\n        try {\r\n            tryToShutDown( );\r\n        }  catch (DeviceShutDownError e) {\r\n            logger.log(e);\r\n        }\r\n   }\r\n\r\n 2번구역 \r\n   public void tryToShutDown( ) throws DeviceShutDownError {\r\n        DeviceHandle handle = getHandle(DEV1);\r\n        DeviceRecord record = retrieveDeviceRecord(handle);\r\n        pauseDevice(handle);\r\n        clearDeviceWorkQueue(handle);\r\n        closeDevice(handle);\r\n   }\r\n        \r\n1번구역\r\n   private DeviceHandle getHandle(DeviceId id) {\r\n     ...\r\n     throw new DeviceShutDownError (\"Invalid handle for : \" + id.toString( ));\r\n     ...\r\n   }\r\n...\r\n} \r\n```\r\n\r\n1. 특정 메소드에서 checked exception을 throw하고 상위 메소드에서 그 exception을 catch한다면 모든 중간단계 메소드에 exception을 throws 해야한다.<br>\r\n2. OCP(개방 폐쇄 원칙) 위배<br>\r\n   상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 OCP 원칙에 위배된다.<br>\r\n3. 필요한 경우 checked exception을 사용해야 되지만 일반적인 경우 득보다 실이 많다.<br>\r\n\r\n### 4) Unchecked Exception을 사용하자\r\n\r\n> 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다는 사실이 분명해졌다. <br>\r\nC#은 확인된 예외를 지원하지 않는다.<br> \r\n> 영웅적인 시도에도 불구하고 C++ 역시 확인된 예외를 지원하지 않는다.<br> \r\n> 파이썬이나 루비도 마찬가지다. 그럼에도 불구하고 **C#, C++, 파이썬, 루비는 안정적인 소프트웨어를 구현하기에 무리가 없다.** \r\n>\r\n\r\n----\r\n\r\n## 3. Exception 잘 쓰기\r\n\r\n### 1) 예외에 메시지를 담아라\r\n\r\n```java\r\n👍 Good 코드를 다시보자\r\n\r\n.... \r\n1번구역\r\n   private DeviceHandle getHandle(DeviceId id) {\r\n     ...\r\n     throw new DeviceShutDownError (\"Invalid handle for : \" + id.toString( ));\r\n     ...\r\n   }\r\n```\r\n- 예외에 의미있는 정보가 담겨있다.\r\n- 오류가 발생한 원인과 위치를 찾기 쉽도록, 예외를 던질 때는 전후 상황을 충분히 덧붙인다.\r\n- 실패한 연산 이름과 유형 등 정보를 담아 예외를 던진다.\r\n\r\n### 2) exception wrapper\r\n\r\n```java\r\n👎 로그를 찍을 뿐 하는 일이 없는 코드 \r\n\r\nACMEPort port = new ACMEPort(12);\r\n   try {\r\n       port.open( );\r\n   } catch (DeviceResponseException e) {\r\n       reportPortError(e);\r\n       logger.log(\"Device response exception\", e);\r\n   } catch (ATM1212UnlockedException e) {\r\n       reportPortError(e);\r\n       logger.log(\"Unlock exception\", e);\r\n   } catch (GMXError e) {\r\n       reportPortError(e);\r\n       logger.log(\"Device response exception\");\r\n  } finally {\r\n       . . .\r\n  }\r\n```\r\n- 로그를 찍을 뿐 할 수 있는 일이 없다.\r\n\r\n\r\n\r\n#### 예외를 감싸는 클래스를 만든다\r\n```java\r\n👍 예외를 감싸는 클래스\r\n \r\n   LocalPort port = new LocalPort(12);\r\n   try {\r\n       port.open( );\r\n   } catch (PortDeviceFilure e) {\r\n       reportError(e);\r\n       logger.log(e.getMessage( ), e);\r\n  } finally {\r\n       . . .\r\n  }\r\n\r\n   public class LocalPort {\r\n      private ACMEPort innerPort;\r\n      public LocalPort(int portNumber) {\r\n            innerPort = new ACMEPort(portNumber);\r\n      }\r\n   }\r\n\r\n   public void open( ) {\r\n      try {\r\n          innerPort.open( );\r\n      } catch (DeviceResponseException e) {\r\n         throw new PortDeviceFailure(e);\r\n     } catch (ATM1212UnlockedException e) {\r\n          throw new PortDeviceFailure(e);\r\n      } catch (GMXError e) {\r\n          throw new PortDeviceFailure(e);\r\n     } \r\n   }\r\n ...\r\n}\r\n```\r\n- port.open( )시 발생하는 checked exception들을 감싸도록 port를 가지는 LocalPort 클래스를 만든다.\r\n- port.open( )이 던지는 checked exception들을 하나의 PortDeviceFailure exception으로 감싸서 던진다.\r\n- 호출부에서 더 깔끔하게 호출할 수 있다.\r\n\r\n----\r\n\r\n## 4. 실무 예외 처리 패턴\r\n\r\n### 1) getOrElse\r\n: **예외 대신 기본 값을 리턴한다**\r\n\r\n#### (1) null이 아닌 기본값\r\n\r\n```java\r\n👎 Bad\r\n\r\nList<Employee> employees = getEmployees( );\r\nif ( employees != null ) {\r\n    for ( Employee e : employees ) {\r\n        totalPay += e.getPay( );\r\n    }\r\n}\r\n```\r\n\r\n- getEmployees를 설계할 때, 데이터가 없는 경우를 null로 표현했는데, 다른 방법이 없을까?\r\n- null을 리턴한다면 이후 코드에서 모두 null 체크가 있어야한다.\r\n\r\n\r\n```java\r\n👍 Good\r\n\r\nList<Employee> employees = getEmployees( );\r\nif ( employees != null ) {\r\n    for ( Employee e : employees ) {\r\n        totalPay += e.getPay( );\r\n    }\r\n}\r\n\r\npublic List<Employee> getEmployees( ) {\r\n  if (  .. there are no employees .. ) {\r\n      return Collections.emptyList( );\r\n   }\r\n}\r\n```\r\n- 복수형의 데이터를 가져올 때는 데이터의 없음을 의미하는 컬렉션을 리턴하면 된다.\r\n- null 보다 size가 0인 컬렉션이 훨씬 안전하다.\r\n\r\n##### 🤚 BUT! 빈 컬렉션, 빈 문자열을 적용할 수 없는 경우라면?\r\n\r\n#### (2) 도메인에 맞는 기본 값 \r\n\r\n```java\r\n👎 Bad\r\n\r\nUserLevel userLevel = null;\r\ntry {\r\n     User user = userRepository.findByUserId(userId);\r\n     userLevel = user.getUserLevel( );\r\n } catch (UserNotFoundException e) {\r\n     userLevel = UserLevel.BASIC;\r\n}\r\n// userLevel을 이용한 처리 \r\n```\r\n- 호출부에서 예외 처리를 통해 userLevel 값을 처리한다.\r\n- 코드를 계속 읽어나가면서 논리적인 흐름이 끊긴다.\r\n\r\n```java\r\n👍 Good\r\n\r\npublic class UserService {\r\n     private static final UserLevel USER_BASIC_LEVEL = UserLevel.BASIC;\r\n\r\n     public UserLevel getUserLevelOrDefault(Long userId) {\r\n        try {\r\n            User user = userRepository.findByUserId(userId);\r\n            return user.getUserLevel( ); \r\n        } catch (UserNotFoundException e) {\r\n            return USER_BASIC_LEVEL;\r\n        }\r\n     }\r\n}\r\n\r\n\r\n// 호출부 코드 \r\nUserLevel userLevel = userService.getUserLevelOrDefault(userId);\r\n```\r\n- 예외 처리를 **데이터를 제공하는 쪽에서 처리해** 호출부 코드가 심플해진다. 재활용성이 높아진다.\r\n- 코드를 읽어가며 논리적인 흐름이 끊기지 않는다.\r\n- 도메인에 맞는 기본값을 도메인 서비스에서 관리한다.\r\n\r\n##### 🤚 도메인에 맞는 기본값이 없다면???!!!\r\n\r\n### 2) getOrElseThrow : null 대신 예외를 던진다\r\n\r\n#### (1) null 체크 지옥에서 벗어나자\r\n\r\n```java\r\n👎 Bad\r\n\r\npublic void registerItem(Item item) {\r\n    if (item != null) {\r\n        ItemRegistry registry = peristentStore.getItemRegistry( );\r\n        if (registry ! = null) {\r\n             Item existing = registry.getItem(item.getID());\r\n             if (existing.getBillingPeriod( ).hasRetailOwner( )) {\r\n                 existing.register(item);\r\n             }\r\n         }\r\n     }\r\n}\r\n```\r\n- null 체크가 빠진 부분이 발생할 수 있다.\r\n- peristentStore에 대한 null 체크가 빠져있지만 알아챌 수 없다.!\r\n- 코드 가독성이 현저히 떨어진다.\r\n\r\n#### (2) 기본 값이 없을 때 null 대신 예외를 던진다\r\n```java\r\n👎 Bad\r\n\r\nUser user = userRepository.findByUserId(userId);\r\nif ( user != null ) {\r\n      // user를 이용한 처리 \r\n}\r\n```\r\n- user를 사용하는 쪽에서 매번 null 체크를 해야한다.\r\n- 가독성뿐 아니라 안정성도 떨어진다.\r\n\r\n```java\r\n👍 Good\r\n\r\npublic class UserService {\r\n     private static final UserLevel USER_BASIC_LEVEL = UserLevel.BASIC;\r\n\r\n     public UserLevel getUserOrElseThrow(Long userId) {\r\n            User user = userRepository.findByUserId(userId);\r\n           if ( user == null ) {\r\n                 throw new IllegalArgumentException(\"User is not found. userId = \" + userId);\r\n            }\r\n             return user;\r\n     }\r\n}\r\n```\r\n- 데이터를 제공하는 쪽에서 null 체크를 하여, 데이터가 없는 경우엔 예외를 던진다.\r\n- 호출부에서 매번 null 체크를 할 필요 없이 안전하게 데이터를 사용할 수 있다.\r\n- 호출부의 가독성이 올라간다.\r\n\r\n#### (3) 파라미터의 null을 점검해라\r\n\r\n```java\r\n👎 Bad \r\n\r\npublic class MetricsCalculator {\r\n     public double xProjection(Point p1, Point p2) {\r\n           return (p2.x - p1.x) * 1.5;\r\n     }\r\n}\r\n\r\n// calculator.xProjection(null, new Point(12, 13));\r\n// NullPointerException 발생한다.\r\n```\r\n- null을 리턴하는 것도 나쁘지만 null을 메서드로 넘기는 것은 더 나쁘다.\r\n- null을 메서드의 파라미터로 넣어야 하는  API를 사용하는 경우가 아니면 null을 메서드로 넘기지 마라.\r\n\r\n\r\n```java\r\n👍 Good \r\n\r\npublic class MetricsCalculator {\r\n     public double xProjection(Point p1, Point p2) {\r\n         if ( p1 == null || p2 == null ) {\r\n              throw InvalidArgumentException(\"Invalid argument for MetricsCalculator.xProjection\");\r\n         }\r\n         return (p2.x - p1.x) * 1.5\r\n     }\r\n}\r\n```\r\n- null을 파라미터로 받지 못하게 한다.\r\n- null이 들어오면 unchecked exception을 발생시킨다.\r\n\r\n```java\r\n👍 Good\r\n\r\npublic class MetricsCalculator {\r\n     public double xProjection(Point p1, Point p2) {\r\n        assert p1 !=  null : \"p1 should not be null\" ;\r\n        assert p2 !=  null : \"p2 should not be null\" ;\r\n        \r\n        return (p2.x - p1.x) * 1.5\r\n     }\r\n}\r\n```\r\n- assert를 통해 null이 들어오면 에러를 발생시킨다.\r\n\r\n----\r\n\r\n## 5. 실무에서는 보통 자신의 예외를 정의한다.\r\n\r\n```java\r\npublic class MyProjectException extends RuntimeException {\r\n     private MyErrorCode errorCode;\r\n     private String errorMessage;\r\n\r\n     public MyProjectException(MyErrorCode errorCode) { ... }\r\n\r\n     public MyProjectException(MyErrorCode errorCode, String errorMessage) { ... }\r\n\r\n}\r\n\r\n     public enum MyErrorCode {\r\n          private String defaultErrorMessage;        \r\n   \r\n          INVALID_REQUEST(\"잘못된 요청입니다.\");\r\n          DUPLICATED_REQUEST(\"기존 요청과 중복되어 처리할 수 없습니다.\");\r\n          // ..\r\n          INTERNAL_SERVER_ERROR(\"처리 중 에러가 발생했습니다.\");\r\n    }\r\n\r\n  // 호출부 \r\n     if ( request.getUserName( ) == null ) {\r\n        throw new MyProjectException(ErrorCode.INVALID_REQUEST, \"userName is null );\r\n     }\r\n```\r\n\r\n**장점**\r\n- 에러 로그에서 stacktrace 해봤을 때 우리가 발생시킨 예외라는 것을 바로 인지할 수 있다.\r\n- 다른 라이브러리에서 발생한 에러와 섞이지 않는다.<br> \r\n  우리도 IllegalArgumentException을 던지는 것보다 우리 예외로 던지는 게 어느 부분에서 에러가 났는지 파악하기에 용이하다.\r\n- 우리 시스템에서 발생한 에러의 종류를 나열할 수 있다.\r\n\r\n----\r\n\r\n## 오픈소스 속 Exception 살펴보기\r\n\r\n### apps-android-commons\r\n\r\n![https://github.com/commons-app/apps-android-commons/blob/main/app/src/main/java/fr/free/nrw/commons/bookmarks/pictures/BookmarkPicturesDao.java](img_1.png)\r\n\r\n**① 125 - 127 라인**<br>\r\nparameter인 bookmark가 null이면 예외를 던지지않고 false를 리턴한다.<br>\r\n-> Bookmark 존재여부에 대한 메서드의 목적에 부합한다.<br>\r\n\r\n**② 131  - 143 라인**<br>\r\ndb 리소스를 처리할 때 checked exception인 RemoteException을 별도로 처리하지 않고<br>\r\nRuntimeException으로 바꿔서 던졌다.<br>\r\n\r\n**③ 144 - 149 라인**<br>\r\nfianally 블록에서 리소스를 close 처리한다. (리소스를 사용했다면 반드시 finally 블록에서 닫아줘야한다.)<br>\r\n\r\n"},{"excerpt":"Chapter 06. 객체와 자료구조\npage 117 ~ 128 자료구조 vs 객체 자료구조 객체 데이터 그 자체 비즈니스 로직과 관련 자료를 공개한다. 자료를 숨기고,  추상화한다.자료를 다루는 함수만 공개한다. 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않는다(getter, setter) 추상 인터페이스를 제공해 사용자가 구현을…","fields":{"slug":"/CleanCode-5/"},"frontmatter":{"date":"June 20, 2024","title":"[클린코드-5] 객체와 자료구조로 데이터 표현하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 06. 객체와 자료구조**<br>\r\n**page 117 ~ 128**\r\n\r\n\r\n## 자료구조 vs 객체\r\n\r\n| 자료구조 | 객체                                            |\r\n| --- |-----------------------------------------------|\r\n| 데이터 그 자체 | 비즈니스 로직과 관련                                   |\r\n| 자료를 공개한다. | 자료를 숨기고, <br> 추상화한다.자료를 다루는 함수만 공개한다.         |\r\n| 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않는다(getter, setter) | 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있다. |\r\n\r\n### 예시(1) Vehicle\r\n#### 자료구조\r\n- 단순히 getter, setter가 있다고 객체가 되지 않는다. (위에 내용 있음)\r\n```java\r\npublic interface Vehicle {\r\n        double getfuelTankCapacityInGallons(); // 연료탱트 용량(갤런 단위)\r\n        double getGallonsOfGasoline(); // 가솔린 (갤런 단위)\r\n}\r\npublic class Car implements Vehicle {\r\n        double fuelTankCapacityInGallons;\r\n        double gallonsOfGasoline;\r\n\r\n        public double getFuealTankCapacityInGallons() {\r\n            return this.fualTankCapacityInGallons;\r\n        }\r\n\r\n        public double getGallonsOfGasoline() {\r\n            return this.gallonsOfGasoline;\r\n        }\r\n}\r\n```\r\n\r\n\r\n#### 객체\r\n- 자신이 가진 값을 그대로 주는 것이 아닌, 연료를 퍼센트로 변환하는 로직이 들어있다.\r\n```java\r\npublic interface Vehicle {\r\n      double getPercentFuelRemain();\r\n}\r\npublic class Car implements Vehicle {\r\n        double fuelTankCapacityInGallons;\r\n        double gallonsOfGasoline;\r\n  \r\n      public Car(double fuelTankCapacityInGallons, double gallonsOfGasoline) {\r\n            if (fuelTankcapacityInGalons <= 0) {\r\n                  throw new IllegalArgumentException(\"fuelTankCapacityInGallons은 0보다 커야한다.\");\r\n                  this.fuelTankCapacityInGallons = fuelTankCapacityInGallons;\r\n                  this.gallonsOfGasoline = gallonsOfGasoline;\r\n            }\r\n        \r\n            public double getPercentFuelRemain() {\r\n                 return this.gallonsOfGasoline / this.fuelTankCapacityInGallons * 100;\r\n            }\r\n      }\r\n}\r\n```\r\n- getPercentFuelRemain( ) : 자신이 가진 값을 바로 주는 것이 아니라 나름대로 값을 다뤄서 넘겨주게된다<br>\r\n- Car() : 어떤 숫자를 0으로 나오면 무한대이기 때문에 error가 발생할 수 있다. Car의 인스턴스를 만들 때 이를 다룰 수 있는 예외를 설정해둔다.<br>\r\n**=> 어떤 메소드를 구현할 때 수학적 오류는 없는지, 버그 발생 가능성은 없는지 확인하고 적절한 제어를 해주어야 한다.**<br>\r\n\r\n🤚 휴대폰 배터리처럼 실제 수치는 중요하지 않고, 퍼센트만 중요하다면?<br>\r\n-> data로 어떤 비즈니스로직을 다루어 필요한 값만 넘기는 방식인 '객체' 로 사용하는 것이 더 적절하다.<br>\r\n\r\n### 예시(2) Shape\r\n\r\n#### 자료구조\r\n\r\n```java\r\npublic class Square {\r\n        public Point topLeft;\r\n        public double side;\r\n}\r\n\r\npublic class Rectangle {\r\n        public Point topLeft;\r\n        public double height;\r\n        public double width;\r\n}\r\n\r\npublic class Circle {\r\n        public Point center;\r\n        public double radius;\r\n}\r\n\r\npublic class Geometry { // * geometry : 기하학 \r\n        public final double PI = 3.141592653589793;\r\n \r\n        public double area(Object shape) throws NoSuchShapeException {\r\n               if (shape instanceof Square){\r\n                   Square s = (Square) shape;\r\n                   return s.side * s.side;\r\n               } else if (shape instanceof Rectangle) {\r\n                   Rectangle r = (Rectangle) shape;\r\n                   return r.height * r.width;\r\n               } else if (shape instanceof Circle) {\r\n                   Circle c = (Circle) shape;\r\n                   return PI * c.radius * c.radius;\r\n               }\r\n               throw new NoSuchShapeException( );\r\n        }\r\n}\r\n```\r\n\r\n👌 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 함수를 고쳐야 한다.<br>\r\n-> else if ~~ 를 추가하며 함수를 고쳐야 한다.<br>\r\n\r\n#### 객체\r\n\r\n```java\r\npublic class Square implements Shape {\r\n        private Point topLeft;\r\n        private double side;\r\n        \r\n        public double area( ) {\r\n           return side * side;\r\n        }\r\n}\r\n\r\npublic class Rectangle implements Shape {\r\n        private Point topLeft;\r\n        private double height;\r\n        private double width;\r\n\r\n       public double area( ) {\r\n         return height * width;\r\n       }\r\n}\r\n\r\npublic class Circle implements Shape {\r\n        private Point center;\r\n        private double radius;\r\n        private final double PI = 3.141592653589793;\r\n\r\n       public double area( ) {\r\n         return PI * radius * radius;\r\n       }\r\n}\r\n```\r\n\r\n👌 객체지향 코드는 새로운 클래스를 추가하기 쉽다. 하지만 함수를 추가해야한다. <br>\r\n-> area() 라는 공통함수가 있다.<br>\r\n\r\n#### 객체지향 vs 절차지향 : 상황에 맞는 선택을 하면 된다.<br>\r\n\r\n• 자료구조를 사용하는 **절차적인 코드**는 기본 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.<br>\r\n• **절차적인 코드**는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다.<br>\r\n\r\n• **객체지향 코드**는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.<br>\r\n• **객체 지향 코드**는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.<br>\r\n\r\n## 객체 - 디미터 법칙\r\n\r\n![디미터 법칙](img_1.png)\r\n\r\n#### 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다<br>\r\n\r\n• 클래스 C<br>\r\n• 자신이 생성한 객체<br>\r\n• 자신의 인수로 넘어온 객체<br>\r\n• C 인스턴스 변수에 저장된 객체<br>\r\n#### 휴리스틱 : 경험에 기반하여 문제를 해결하기 위해 발견한 방법. 의사 결정을 단순화하기 위한 법칙들\r\n\r\n### 기차 충돌\r\n\r\n#### 디미터의 법칙에 어긋나는 상황\r\n\r\n연쇄 작용으로 인한 충돌\r\n\r\n```java\r\n// 객체 - 기차 충돌. 디미터의 법칙 위배 : 내가 가진 것이 가진 것을 가져오는 연쇄 작용(depth가 깊게 들어감)\r\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();\r\n\r\n// 자료구조 - OK\r\nfinal String outputDir = ctxt.options().scratchDir().absolutePath;\r\n\r\n// 객체에 대한 해결책이 아니다. getter를 통했을 뿐, 값을 가져오는 것은 자료구조처럼 구현한 것이다.\r\nctxt.getAbsolutePathOfScratchDirectoryOption();\r\nctxt.getOptions().getScratchDir().getAbsolutePath();\r\n\r\n// 왜 절대 경로를 가져올까.. 근본 원인을 생각해보자! 파일을 생성하기위해!\r\n// 객체는 자료를 숨기고 자료를 다루는 함수만 공개한다. \r\nBufferedOutputStream bos = ctxt.createScratchFileStreamFileStream(classFileName); // 해당 코드는 객체로서 옳은 방법\r\n-> 인자(classFileName)만 넘기고 내부적인 코드들은 안에서 생성하여 묶어서 처리하는 방식으로 구현해 디미터의 법칙을 지키도록!\r\n```\r\n\r\n## DTO ; Data Transfer Object = 자료구조 = 데이터를 전달할 때 사용하는 객체\r\n\r\n```java\r\npublic class AddressDto {\r\n        private String street;\r\n        private String zip;\r\n        \r\n        public AddressDto (String street, String zip ) {\r\n           this.street = street;\r\n           this.zip = zip ;\r\n        } \r\n\r\n        public String getStreet( ) {\r\n            return street;\r\n        }\r\n\r\n        public String setStreet(String street) {\r\n            this.street = street;\r\n        }\r\n\r\n        public String getZip( ) {\r\n            return zip;\r\n        }\r\n\r\n        public String setZip(String zip) {\r\n            this.zip= zip;\r\n        }\r\n}\r\n```\r\n\r\n#### 다른 계층 간 데이터를 교환할 때 사용\r\n\r\n• 로직 없이 필드만 갖는다.<br>\r\n• 일반적으로 클래스명이 Dto(or DTO)로 끝난다.<br>\r\n• getter/setter를 갖기도 한다.<br>\r\n\r\n#### Beans\r\n\r\nJava Beans: 데이터 표현이 목적인 자바 객체<br>\r\n• 멤버 변수는 private 속성이다.<br>\r\n• getter와 setter를 가진다.<br>\r\n\r\n## Active Record\r\n\r\n```java\r\npublic class Employee extends ActiveRecord{\r\n        private String name;\r\n        private String address;\r\n        . . . . .\r\n}\r\n        \r\n  Employee bob = Employee.findByName(\"Bob Martin\");\r\n  bob.setName(\"Robert C. Martin\");\r\n  bob.save( );\r\n}\r\n```\r\n\r\n### Database row를 객체에 맵평하는 패턴\r\n: 현업에서의 Repository, Entity와 유사\r\n\r\n• 비즈니스 로직 에서드를 추가해 객체로 취급하는 건 바람직하지 않다.<br>\r\n• 비즈니스 로직을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.<br>\r\n• 하지만.. 객체가 많아지면 복잡하고, 가까운 곳에 관련 로직이 있는 것이 좋으므로 현업에서는 Entity에 간단한 메서드를 추가해 사용한다.<br>\r\n• 예제에서는 db에 직접 접근해 값을 가져오기도하고 가져온 것을 바탕으로 세팅해주기도한다.<br>\r\n\r\n### Active Record vs Data Mapper\r\n\r\n![Active Record](img_4.png)\r\n\r\n### Active Record\r\n\r\n: insert, update등 한 객체 안에서 사용함 (자바 개발하면서 보기 힘든 패턴) <br>\r\n• 객체가 row를 담을 뿐 아니라 database에 대한 접근을 포함한다.<br>\r\n\r\n• Person의 속성을 담을 뿐 아니라, 생성 수정도 객체 안에서 수행할 수 있다. <br>\r\n\r\n• 사례 - Ruby on rails<br>\r\n\r\n![Data Mapper](img_3.png)\r\n\r\n### Data Mapper\r\n\r\n• row를 담는 객체와 database에 접근할 수 있는 객체가 분리되어 있다.<br>\r\n\r\n• Person은 값만 담고 있고, 생성, 수정 등 액션은 Person Mapper에서 담당한다.<br>\r\n\r\n• 사례 - Hibernate<br>"},{"excerpt":"Chapter 05. 형식 맞추기\npage 95 ~ 116 포멧팅이 중요한 이유 가독성이 필수적이다. 코드를 수월하게 읽어나갈 수 있다. 아마추어처럼 보이지 않는다. 포맷팅으로 인해 코드를 잘못해석해 버그를 발생할 위험을 줄인다! 클린코드 포맷팅 적절한 길이 유지 👍~200 lines < 500 lines 200라인 “코드 길이를 200줄 정도로 제한하는…","fields":{"slug":"/CleanCode-4/"},"frontmatter":{"date":"June 14, 2024","title":"[클린코드-4] 코드의 가독성에 필수적인 포맷팅","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 05. 형식 맞추기**<br>\r\n**page 95 ~ 116**\r\n\r\n## 포멧팅이 중요한 이유\r\n\r\n```java\r\npublic void horriblyFormattedMethod() {\r\n\tSystem.out.println(\"First line\");\r\n\t\t\tSystem.out.println(\"Second line\");\r\n\t\tSystem.out.println(\"Third line\");\r\n\tfor (int i = 0; i < 3; i++)\r\n\tSystem.out.println(\"number \" + i);\r\n}\r\n```\r\n```java\r\npublic void horriblyFormattedMethod() {\r\n\tSystem.out.println(\"First line\");\r\n\tSystem.out.println(\"Second line\");\r\n\tSystem.out.println(\"Third line\");\r\n\tfor (int i = 0; i < 3; i++) {\r\n\t\tSystem.out.println(\"number \" + i);\r\n\t}\r\n}\r\n```\r\n### 가독성이 필수적이다.\r\n- 코드를 수월하게 읽어나갈 수 있다.\r\n- 아마추어처럼 보이지 않는다.\r\n- 포맷팅으로 인해 코드를 잘못해석해 버그를 발생할 위험을 줄인다!\r\n\r\n\r\n---\r\n## 클린코드 포맷팅\r\n\r\n### 적절한 길이 유지\r\n👍~200 lines < 500 lines\r\n#### 200라인\r\n\r\n- “코드 길이를 200줄 정도로 제한하는 것은 반드시 지길 엄격한 규칙은 아니지만, 일반적으로 큰 파일 보다는 작은 파일이 이해하기 쉽다\"<br>\r\n\r\n  → 현업에서의 대부분의 코드들도 200라인 정도를 유지한다.\r\n\r\n\r\n• 코드 길이가 200라인을 넘어간다면, 클래스가 여러 개의 일을 하고 있을 수 있다. ~> SRP 위배!\r\n\r\n### 밀접한 개념은 가까이\r\n\r\n#### 밀접한 개념은 서로 가까이 둔다.\r\n• 행 묶음은 완결된 생각 하나를 표현하기 때문에 개념은 빈 행으로 분리한다.\r\n• 변수는 사용되는 위치에서 최대한 가까이 선언한다.\r\n\r\n-----\r\n\r\n## Java Class Declearations\r\n\r\n![https://www.oracle.com/java/technologies/javase/codeconventions-fileorganization.html](img.png)\r\n\r\n\r\n### Class 내부 코드 순서\r\n**Class 내부 코드 순서를 맞추어 개발해야 한다.**\r\n\r\n**1. static 변수<br>**\r\n- public -> protected -> package -> private 순서<br>\r\n  **2. instance 변수<br>**\r\n- public -> protected -> package -> private<br>\r\n  **3. 생성자<br>**\r\n  **4. 메서드<br>**\r\n- public 메서드에서 호출되는 private 메서드는 그아래에 둔다. **가독성** 위주로 그룹핑한다.<br>\r\n\r\n\r\n```java\r\n/*\r\n * @(#)Blah.java            1.82 99/03/18\r\n *\r\n * Copyright (C) 1994-1998 Sun Microsystems, Inc.\r\n * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.\r\n * All rights reserved.\r\n *\r\n * This software is the confidential and proprietary information of Sun\r\n * Microsystems, Inc. (*Confidential Information\"). You shall not\r\n * disclose such Confidential Information and shall use it only in\r\n * accordance with the terms of the license agreement you entered into\r\n * with Sun.\r\n */\r\n\r\npackage java.blah;\r\n\r\nimport java.blah.blahdy.BlahBlah;\r\n\r\n/**\r\n *\r\n * Class description goes here.\r\n *\r\n * @version 1.82 18 Mar 1999\r\n * @author Firstname Lastname\r\n */\r\npublic class Blah extends SomeClass {\r\n    public static int classVar1;\r\n    private static Object classVar2;  // static 변수\r\n    public Object instanceVar1;\r\n    protected int instanceVar2;\r\n    private Object[] instanceVar3;  // instance 변수\r\n    public Blah() {  // 생성자\r\n        // ...implementation goes here...\r\n    }\r\n    public void doSomething() {  // 메서드\r\n        // ...implementation goes here...\r\n    }\r\n    public void doSomethingElse(Object someParam) {\r\n        // ...implementation goes here...\r\n    }\r\n}\r\n```\r\n\r\n### Team Coding Convention(참고)\r\n\r\n코딩 스타일에 관한 약속 👨🏻‍💻\r\n> 팀의 코딩 스타일에 관한 약속이다.<br>\r\n> 개발 언어의 컨벤션이 우선이지만, 애매한 부분은 팀 컨벤션을 따른다. <br>\r\n> 없다면 제안하는 것도 리뷰 시 언쟁이 길어지지 않는 하나의 방법이다.\r\n\r\n**Google Java StyIe Guide**\r\n\r\nhttps://google.github.io/styleguide/javaguide.html\r\n\r\n**Naver Hackday Java Convention**\r\n\r\nhttps://naver.github.io/hackday-conventions-java/"},{"excerpt":"Chapter 04. 주석\npage 67 ~ 94 주석을 최대한 쓰지 말자 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.\n자신이 저지른 난장판을 주석으로 설명하지 말고 개선하는데 시간을 보내야 한다.\n코드로도 의도를 표현할 수 있다! 주석은 방치된다. 코드의 변화에 따라가지 못하고, 주석은 방지…","fields":{"slug":"/CleanCode-3/"},"frontmatter":{"date":"June 13, 2024","title":"[클린코드-3] 코드를 보조하는 주석","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 04. 주석**<br>\r\n**page 67 ~ 94**\r\n\r\n## 주석을 최대한 쓰지 말자\r\n\r\n### 주석은 나쁜 코드를 보완하지 못한다.\r\n\r\n```java\r\n// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.\r\nif((employee.flags && HOURLY_FLAG) && employee.age > 65)\r\n\r\n// 의미있는 이름을 지으면 해결된다.\r\nif(employee.isEligibleForFullBenefits())\r\n```\r\n\r\n코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.\r\n자신이 저지른 난장판을 주석으로 설명하지 말고 개선하는데 시간을 보내야 한다.\r\n**코드로도 의도를 표현할 수 있다!**\r\n\r\n### 주석은 방치된다.\r\n\r\n코드의 변화에 따라가지 못하고, 주석은 방지된다.\r\n\r\n코드는 컴파일되어 호출되지만, 주석은 그저 주석이기 때문에 그 자리에 방치되고 결국 의미없는 텍스트가 되어버린다.\r\n\r\n## 좋은 주석\r\n\r\n#### 구현에 대한 정보를 제공한다.\r\n\r\n```java\r\n// kk:mm:ss EEE, MMM DD, yyyy 형식\r\nPattern timeFormat = Pattern.comfile(\"\\\\d*:\\\\d:\\\\d* \\\\w*, \\\\w* \\\\d* \\\\d*\");\r\n```\r\n\r\n#### 의도와 중요성을 설명한다.\r\n\r\n```java\r\n// 스레드를 많이 생성하여 시스템에 영향을 끼쳐 테스트를 만들도록 함\r\nfor(int i = 0; i < 25000; i++) {\r\n\tSomeThread someThread = ThreadBuilder.builder().build();\r\n}\r\n\r\n// 유저로부터 입력받을 값을 저장할 때 trim으로 공백제거 필요\r\nString userName = userNameInput.trim();\r\n```\r\n\r\n#### //TODO //FIXME\r\n\r\n- TODO : 앞으로 할일. 지금은 해결하지 않지만 나중에 해야할 일을 적어둘 때.\r\n\r\n- FIXME : 문제가 있지만, 당장 수정할 필요는 없을때. 가능한 빨리 수정하는게 좋다.\r\n\r\n## 주석보다 annotation\r\n\r\n#### java.lang.annotation\r\n\r\nannotation = 코드에 대한 메타 데이터\r\n\r\n- 코드의 실행 흐름에 간섭을 주기도 하고, 주석처럼 코드에 대\r\n  한 정보를 수 있다.\r\n\r\n@Deprecated: 컴파일러가 warning을 발생시김. IDE에서 사용시 표시됨<br>\r\n@NotThreadSafe: Thread Safe하지 않음을 나타냄<br> (책에서는 주석으로 표현했지만 어노테이션을 많이 사용)\r\n\r\n@Immutable, @Nullable 등 java.lang.annotation 패키지의 어노테이션들을 사용하면\r\n간단하면서 명료하게 주석보다 큰 효과를 얻을 수 있다.\r\n## JavaDoc\r\n**:Java 코드에서 API 문서를 HTML 형식으로 생성해 주는 도구<br>\r\nIDE에서 Reader Mode로 주석 기호를 삭제하고 텍스트만 확인할 수 있다.**\r\n![](img.png)\r\n#### Class level\r\n![](img_1.png)\r\n#### Field level\r\n![](img_2.png)\r\n#### Method level\r\n![](img_3.png)"},{"excerpt":"Chapter 03. 함수\npage 39 ~ 66 SOLID원칙 (객체지향 설계의 5가지 원칙)  SRP( Single Responsibility Principle ), 단일 책임 원칙  객체는 단 하나의 책임만 가져야 한다는 원칙. 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경 해야 하는 이유는 오직 하나뿐이어야 한다. SRP 책임이 …","fields":{"slug":"/CleanCode-2/"},"frontmatter":{"date":"June 11, 2024","title":"[클린코드-2] 함수를 안전하고 간결하게 작성하기","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 03. 함수**<br>\r\n**page 39 ~ 66**\r\n\r\n## SOLID원칙 (객체지향 설계의 5가지 원칙)\r\n\r\n![SOLID원칙](img.png)\r\n\r\n### **SRP( Single Responsibility Principle ), 단일 책임 원칙**\r\n\r\n![SRP](img_1.png)\r\n\r\n**객체는 단 하나의 책임만 가져야 한다는 원칙**.\r\n\r\n- 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경 해야 하는 이유는 오직 하나뿐이어야 한다.\r\n- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.\r\n- 가독성 향상과 유지보수가 용이해진다.\r\n- 실전에서는 쉽지 않지만 늘 상기해야 한다!\r\n\r\n### **OCP ( Open-Closed Principle ), 개방-폐쇄 원칙**\r\n\r\n**기존의 코드를 변경하지 않으면서( closed ), 기능을 추가할 수 있도록( open ) 설계가 되어야 한다는 원칙**.\r\n\r\n![OCP](img_2.png)\r\n\r\n- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.\r\n- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.\r\n- 객체지향의 추상화와 다형성을 활용한다.\r\n\r\n### **LSP ( Liskov Substitution Principle ), 리스코프 치환 원칙**\r\n\r\n![LSP](img_3.png)\r\n\r\n**자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙**.\r\n\r\n**서브 타입 언제나 기반 타입으로 교체할 수 있어야 한다.**\r\n\r\n- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.\r\n- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.\r\n- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.\r\n- 합성(composition)을 이용할 수도 있다.\r\n\r\n### **ISP ( Interface Segregation Principle ), 인터페이스 분리 원칙**\r\n\r\n![ISP](img_4.png)\r\n\r\n**자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 설계 원칙**.\r\n\r\n- 가능한 최소한의 인터페이스만 구현한다.\r\n- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.\r\n- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임\r\n\r\n### **DIP ( Dependency Inversion Principle ), 의존 역전 원칙**\r\n\r\n![DIP](img_5.png)\r\n\r\n객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, **이 때** **객체들은** **나름대로의 원칙을 갖고 정보를 주고 받아야 한다는 설계 원칙**.\r\n\r\n**상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.\r\n추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.**\r\n\r\n- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.\r\n- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.\r\n\r\n**DIP 예제**\r\n\r\n```java\r\nclass PaymentController {\r\n    \r\n    @GetMapping(\"/api/payment\")\r\n    public void pay(@RequestBody ShinhanCardDto.paymentRequest req) {\r\n        shinhanCardPaymentService.pay(req);\r\n    }\r\n}\r\n\r\nclass ShinhanCardPaymentService {\r\n    public void pay(ShinhanCardDto.paymentRequest req) {\r\n        shinhanCardApi.pay(req);\r\n    }\r\n}\r\n```\r\n\r\n새로운 카드사가 추가된다면?\r\n\r\n```java\r\n@GetMapping(\"/api/payment\")\r\npublic void pay(@RequestBody CardPaymentDto.paymentRequest req) {\r\n    if(req.getType() == CardType.SHINHAN) {\r\n        shinhanCardPaymentService.pay(req);\r\n    } else if(req.getType == CardType.WOORI) {\r\n        wooriCardPaymentService.pay(req);\r\n    }\r\n}\r\n```\r\n**해결방법!**\r\n\r\n![둘 다 추상화된 인터페이스에 의존하도록 한다.](img_6.png)\r\n\r\n```java\r\nclass PaymentController {\r\n\r\n    @GetMapping(\"/api/payment\")\r\n    public void pay(@RequestBody CardPaymentDto.paymentRequest req) {\r\n        final CardPaymentService cardPaymentService = cardPaymentFactory.getType(req.getType());\r\n        cardPaymentService.pay(req);\r\n    }\r\n}\r\n\r\npublic interface CardPaymentService {\r\n    void pay(CardPaymentDto.paymentRequest req);\r\n}\r\n\r\npublic class ShinhanCardPaymentService implements CardPaymentService {\r\n    @Override\r\n    public void pay(ShinhanCardDto.paymentRequest req) {\r\n        shinhanCardApi.pay(req);\r\n    }\r\n}\r\n```\r\n## 간결한 함수 작성하기\r\n\r\n\r\n\r\n```java\r\npublic class String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throw Exception {\r\n    boolean isTestPage = pageData.hasAttribute(\"Test\");\r\n    if(isTestPage) {\r\n    \tWikiPage testPage = pageData.getWikiPage();\r\n        StringBuffer newPageContent = new StringBuffer();\r\n        includeSetupPages(testPage, newPageContent, isSuite);\r\n        newPageContent.append(pageData, getContent());\r\n        includeTeardownPages(testPagem newPageContent, isSuite);\r\n        pageData.setContent(newPageContent.toString());\r\n    }\r\n    \r\n    return pageData.getHtml();\r\n}\r\n```\r\n‘함수가 길고, 여러가지 기능이 섞여있다..’\r\n\r\n```java\r\npublic static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {\r\n    if(isTestPage(pageData))\r\n        includeSetupAndTeardownPages(pageData, isSuite);\r\n    return pageData.getHtml();\r\n}\r\n```\r\n작게 쪼갠다.\r\n\r\n함수 내 추상화 수준을 동일하게 맞춘다.<br>\r\n\r\n#### 한 가지만 하기(SRP), 변경에 닫게 만들기(OCP)\r\n\r\n\r\n```java\r\npublic Money calculatePay(Employee e) throws InvalidEmployeeType {\r\n\tswitch(e.type) {\r\n    \tcase COMMISSIONED :\r\n        \treturn calculateCommisstionedPay(e);\r\n        case HOURLY :\r\n        \treturn calculateHourlyPay(e);\r\n        case SALARIED :\r\n        \treturn calulatedSalariedPay(e);\r\n        default :\r\n        \tthrow new InvalidEmployeeType(e.type)\r\n    }\r\n}\r\n```\r\n\r\n‘계산도 하고, 돈도 생성한다.. 두 가지 기능이 보인다’\r\n\r\n‘새로운 직원 타입이 추가된다면?’\r\n\r\n```java\r\npublic abstract class Employee {\r\n    public abstract boolean isPayday();\r\n    public abstract Money calculatePay();\r\n    public abstract void deliveryPay(Money pay);\r\n}\r\n\r\npublic interface EmployeeFactory {\r\n\tpublic Employee makeEmployee(EmployeeRecode r) throw InvalidEmployeeType;\r\n}\r\n\r\npublic class EmployeeFactoryImpl implements EmployeeFactory {\r\n    public Employee makeEmployee(EmployeeRecode r) throw InvalidEmployeeType {\r\n      switch(e.type) {\r\n        case COMMISSIONED :\r\n        \treturn new CommissionEmployee(e);\r\n        case HOURLY :\r\n        \treturn new HourlyEmployee(e);\r\n        case SALARIED :\r\n        \treturn new SalariedEmployee(e);\r\n        default :\r\n        \tthrow new InvalidEmployeeType(e.type)\r\n      }\r\n   }\r\n}\r\n```\r\n\r\n계산과 타입관리를 분리\r\n\r\n타입에 대한 처리는 최대한 Factory에서만 진행\r\n\r\n#### 함수 인수\r\n\r\n인수의 갯수는 0~2개가 적당하다.\r\n\r\n3개 이상인 경우는?\r\n\r\n```java\r\n// 객체를 인자로 넘기기 👍\r\nCircle makeCircle(double x, double y, double radius); //👎\r\nCircle makeCircle(Point center, double radius); // 👍\r\n\r\n// 가변 인자를 넘기기 -> 특별한 경우가 아니면 잘..\r\nString.format(String format, Object... args) :\r\n```\r\n\r\n## 안전한 함수 작성하기\r\n\r\n### 부수 효과(Side Effect) 없는 함수\r\n\r\n**부수효과란?**\r\n\r\n- 값을 반환하는 함수가 외부 상태를 변경하는 경우\r\n- 함수와 관계없는 외부 상태를 변경시킨다\r\n\r\n```java\r\npublic class UserValidator {\r\n    \r\n    private Crytographer crytographer;\r\n    \r\n    public boolean checkPassword(String username, String password) {\r\n        User user = UserGateway.findByName(username);\r\n        if(user != User.NULL) {\r\n            String codedPhrase = user.getPhraseEncodedByPassword();\r\n            String phrase = crytographer.decrpt(codedPhrase, password);\r\n            if(\"Valid Password\".equals(phrase)) {\r\n                Session.initialize();\t// 문제코드!!\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n## 함수 리펙토링\r\n\r\n#### 1. 기능을 구현하는 서투른 함수를 작성한다.\r\n- 길고, 복잡하고, 중복도 있다.\r\n\r\n#### 2. 테스트 코드를 작성한다\r\n- 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다.\r\n\r\n#### 3. 리펙토링 한다\r\n- 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다."},{"excerpt":"Chapter 01. 깨끗한 코드 & Chapter 02. 의미 있는 이름\npage 1 ~ 38 나쁜 코드 성능이 나쁜 코드 불필요한 연산이 들어가서\n개선의 여지가 있는 코드 의미가 모호한 코드 이해하기 어려운 코드 네이밍과 그 내용이 다른 코드 중복된 코드 비슷한 내용인데 중복되는 코드들은\n버그를 남는다. 나쁜 코드가 나쁜이유  깨진 유리창 법칙 나쁜 …","fields":{"slug":"/CleanCode-1/"},"frontmatter":{"date":"June 10, 2024","title":"[클린코드-1] 클린 코드와 그 첫걸음","tags":["독서","Clean Code"]},"rawMarkdownBody":"\r\n**Chapter 01. 깨끗한 코드 & Chapter 02. 의미 있는 이름**<br>\r\n**page 1 ~ 38**\r\n\r\n\r\n## 나쁜 코드\r\n\r\n**성능이 나쁜 코드**\r\n\r\n> 불필요한 연산이 들어가서\r\n개선의 여지가 있는 코드\r\n>\r\n\r\n**의미가 모호한 코드**\r\n\r\n> 이해하기 어려운 코드 네이밍과 그 내용이 다른 코드\r\n>\r\n\r\n**중복된 코드**\r\n\r\n> 비슷한 내용인데 중복되는 코드들은\r\n버그를 남는다.\r\n>\r\n\r\n### 나쁜 코드가 나쁜이유\r\n\r\n![꺠진 유리창](img.png)\r\n\r\n**깨진 유리창 법칙**\r\n\r\n> 나쁜 코드는 깨진 유리창처럼\r\n계속 나쁜 코드가 만들어지도록 한다.\r\n>\r\n\r\n![생산성 저하](img_1.png)\r\n\r\n**생산성 저하**\r\n\r\n> 나쁜 코드는 팀 생산성을 저하시킨다.\r\n기술부채를 만들어 수정을 더 어렵게 한다.\r\n>\r\n\r\n![새로운 시스템을 만들어야 한다](img_2.png)\r\n\r\n**새로운 시스템을 만들어야 한다.**\r\n\r\n> 현시스템을 유지보수하며\r\n대처할 새로운 시스템 개발은 현실적으로 매우 어렵다.\r\n>\r\n\r\n![일정이 촉박](img_3.png)\r\n\r\n**일정이 촉박해서**\r\n\r\n> 일정 안에 새로운 기능을 완성해야 한다.\r\n하지만..\r\n나쁜 코드는 생산성을 저하하기 때문에\r\n오히려 일정을 못맞춘다.\r\n>\r\n\r\n![Side Effect](img_4.png)\r\n\r\n**영향 범위가 넓어서**\r\n\r\n> 생각보다 영향 범위가 넘어서 건드렸다가 다른 부분에 버그가 발생할까봐\r\n하지만..\r\n기술부채는 부메랑처럼 우리에게 돌아온다.\r\n>\r\n\r\n## 클린 코드란?\r\n\r\n![비야네 스트롭스트룹](img_5.png)\r\n\r\n> “\r\n나는 우아하고 효율적인 코드를 좋아한다.<br>\r\n논리가 간단해야 버그가 숨어들지 못한다.<br>\r\n의존성을 최대한 줄여야 유지보수가 쉬워진다.<br>\r\n오류는 명백한 전략에 의거해 철저히 처리한다.<br>\r\n성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로\r\n코드를 망치려는 유혹에 빠지지 않는다.<br>\r\n<span style=\"color:red\">**깨끗한 코드는 한 가지를 제대로 한다.**</span>\"<br>\r\n> _**비야네 스트롭스트룹**_\r\n\r\n![그래디 부치](img_6.png)\r\n\r\n> “\r\n깨끗한 코드는 단순하고 직접적이다.<br>\r\n<span style=\"color:red\">**깨끗한 코드는 잘 쓴 문장처럼 읽힌다.**</span><br>\r\n깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.<br>\r\n오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.\"<br>\r\n> _**그래디 부치**_\r\n\r\n\r\n**요약**\r\n\r\n\r\n💡 성능이 좋은 코드<br>\r\n💡 의미가 **명확한** 코드 = **가독성**이 좋은 코드<br>\r\n💡 **중복이 제거**된 코드<br>\r\n\r\n\r\n\r\n![보이스카우트 룰](img_7.png)\r\n\r\n### 보이스카우트 룰\r\n\r\n> **“전보다 더 깨끗한 코드를 만든다”**\r\n>\r\n\r\n## 의미 있는 이름 짓기\r\n\r\n### 의미가 분명한 이름 짓기\r\n\r\n- **잘못된 예**\r\n\r\n```java\r\nint a;\r\nString b;\r\n\r\n// ..\r\n\r\nSystem.out.printf(\"User Requested %s. count = %d\", b, a);\r\n// Console Output\r\n// User Requested book count = 3\r\n\r\n```\r\n\r\n```java\r\nint itemCount;\r\nString itemName;\r\n\r\n// ..\r\n\r\nSystem.out.printf(\"User Requested %s. count = %d\", b, a);\r\n// Console Output\r\n// User Requested book count = 3\r\n\r\n```\r\n\r\n```java\r\n//클래스를 활용해서 더 명확하게 변신\r\n\r\nclass SalesItem {\r\n\tItemCode code;\r\n\tString name;\r\n\tint count;\r\n\t}\r\n\t\r\n// ..\r\nSalesItem selectedItem = salesItemRepository.getItemByCode(purchaseRequest.getItemCode())\r\nSystem.out.printf(\"User Requested %s. count = %d\", \r\n\t\t\t\t\t\t\t\t\t\tselectedItem.getName(), selectedItem.getName());\r\n\r\n// ConsoIe Output\r\n// User Requested book. count = 3\r\n```\r\n\r\n### 루프 속에 ijk 사용하지 않기\r\n\r\n배열을 순회할 때 index를 의미하는 i사용하지 않고 advanced for문으로 대체한 수 있다.\r\n\r\n![](img_10.png)\r\n\r\n자바 8에서는 **lamda**를 사용 할 수도 있다.\r\n\r\n![](img_9.png)\r\n\r\n최대한 의미를 찾을 수 있다.\r\n\r\n![](img_8.png)\r\n\r\n- i, j, k 대신 맥락에 맞는 이름이 있다.<br>\r\n- i, j -> row, col / width, height<br>\r\n- i, j, k -> row, col, depth<br>\r\n\r\n### 통일성 있는 단어 사용하기\r\n\r\n- Member / Customer / User <br>\r\n- Service / Manager <br>\r\n- Repository / Dao <br>\r\n\r\n### 변수명에 타입 넣지 않기\r\n\r\n```java\r\nString nameString(👎) -> name\r\nlnt itemPriceAmount(👎) -> itemPrice\r\n\r\nAccount[] accountArray(👎)-> accounts\r\nList<Account> accountList(👌) -> accounts, accountList\r\nMap<Account> accountMap(👌) => 대체 불가능해서 가능\r\n\r\npublic interface IShapeFactory(👎) -> ShapeFactory\r\npublic class ShapeFactoryImpl(👍) -> CircleFactory\r\n```\r\n\r\n## Google Java Naming Guide\r\n\r\n[Google Java Style Guide](https://google.github.io/styleguide/javaguide.html#s5-naming)\r\n\r\n![](img_11.png)\r\n\r\n### Package Naming Guide\r\n\r\n- All lower case, no underscores\r\n\r\n```java\r\ncom.example.deepspace(👍)\r\ncom.example.deepSpace(👎)\r\ncom.example.deep_space(👎)\r\n```\r\n\r\n### Class Naming Guide\r\n\r\n- UpperCamelCase (대문자로 시작)\r\n\r\n```java\r\n// 클래스는 명사. 명사구\r\nCharacter, ImmutableList\r\n\r\n// 인터페이스는 명사. 명사구. (형용사)\r\nList, Readable\r\n\r\n// 테스트클래스는 Test로 끝나기\r\nHashTest, HashIntegrationTest\r\n```\r\n\r\n### Method Naming Guide\r\n\r\n- LowerCameICase (소문자로 시작)\r\n```java\r\nsendMessage, stop // 메서드는 동사, 동사구\r\n```"},{"excerpt":"상황   자바로 프로그램을 짜고 있었다. lombok 추가해야하는데,, 나는 스프링만 개발하다 보니 버전을 굳이 입력하지 않아도 버전들이 알아서 맞춰질 줄 알았다. 하지만 버전을 입력하지 않았다라는 오류가 발생… BOM이란? Bill Of Materials(자재 명세서)의 약자로 산업분야에 사용되는 용어이다. 스프링부트 공식 문서에서 \"io.spring.…","fields":{"slug":"/Spring-boot-bom/"},"frontmatter":{"date":"June 07, 2024","title":"Spring boot BOM이란?","tags":["Spring boot","프로젝트 삽질"]},"rawMarkdownBody":"\r\n## 상황\r\n![스프링 부트](img_8.png)\r\n\r\n![자바](img_9.png)\r\n\r\n\r\n자바로 프로그램을 짜고 있었다. lombok 추가해야하는데,, 나는 스프링만 개발하다 보니 버전을 굳이 입력하지 않아도 버전들이 알아서 맞춰질 줄 알았다.\r\n\r\n하지만 버전을 입력하지 않았다라는 오류가 발생…\r\n\r\n## BOM이란?\r\n\r\nBill Of Materials(자재 명세서)의 약자로 산업분야에 사용되는 용어이다. 스프링부트 공식 문서에서 \"**io.spring.dependency-management 플러그인을 적용하면 spring-boot-dependencies bom을 자동으로 가져온다.**\"고 명시하고 있기 때문에 spring-boot-dependencies를 bom이라 명명할 수 있겠다. \r\n\r\n## Spring boot BOM이란?\r\n![Spring boot BOM](img_10.png)\r\n\r\n자재 명세서라는 명칭 그대로 bom(**spring-boot-dependencies**)은 스프링이 사용하는 여러 의존성 라이브러리의 버전이 명시되어 있다. [[메이븐 레파지토리](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies/3.1.0)]에서 bom을 다운받아보면, 라이브러리 버전들이 명시된 **pom파일**인 것을 확인할 수 있다.\r\n\r\n## 정리\r\n\r\n- io.spring.dependency-management는 플러그인이다.\r\n- bom은 pom파일이다. 그러므로 bom 또는 bom 파일로 부를 수 있다.\r\n- spring-boot-dependencies는 bom 파일이다.\r\n\r\n## 참고문헌\r\n> 💡 - https://onestone-dev.tistory.com/70"},{"excerpt":"회사 직원과 토이프로젝트를 AWS를 사용하여 배포할려고 하였다. (feat. 프리티어) 하지만 과금되어서 이처럼 글로 적어본다. 1. USD 0.095 per GB-month of backup storage exceeding free allocation ‘GB당 0.095달러의 백업 스토리지가 무료 할당을 초과합니다’라는 말과 함께 과금되었다.  이유 인…","fields":{"slug":"/aws-billing-1/"},"frontmatter":{"date":"February 15, 2024","title":"AWS 과금 (RDS)","tags":["AWS","RDS","프로젝트 삽질"]},"rawMarkdownBody":"\r\n\r\n![AWS 과금 목록표](img.png)\r\n\r\n회사 직원과 토이프로젝트를 AWS를 사용하여 배포할려고 하였다. (feat. 프리티어)\r\n\r\n하지만 과금되어서 이처럼 글로 적어본다.\r\n\r\n## 1. USD 0.095 per GB-month of backup storage exceeding free allocation\r\n\r\n**‘GB당 0.095달러의 백업 스토리지가 무료 할당을 초과합니다’**라는 말과 함께 과금되었다.\r\n\r\n![USD 0.095 per GB-month of backup storage exceeding free allocation](img_1.png)\r\n\r\n### 이유\r\n\r\n인터넷에서 찾아보니\r\n\r\n![백업스토리지 - 스냅샷](img_2.png)\r\n\r\n지금은 지워서 없지만, RDS의 DB인스턴스를 지우고 나서 **스냅샷**인가 남아있어서 과금되었다…. ㅠㅠ (RDS 백업에 대한 요금이라는데,,)\r\n\r\n다음에는 DB인스턴스 지우고나서 스냅샷에 남아있는지 확인 해야할 것 같다.. ㅠㅠ\r\n\r\n## 2. $0.005 per In-use public IPv4 address per hour\r\n\r\n가장 많이 과금된 **‘$0.005 per In-use public IPv4 address per hour’ → ‘사용 중인 공용 IPv4 주소당 시간당 $0.005’** 이라는 항목으로 과금되었다… 😭\r\n\r\n각종 Velog, 블로그들을 찾아가며, DB인스턴스를 구성했는데 과금이라니;;\r\n\r\n사실 얼마 하지도 않지만,, 그냥 궁금한 마음에 AWS고객센터에 메일을 보내서 확인 해보았다.\r\n\r\n![지원센터 -> 영어 질문](img_3.png)\r\n\r\n### 이유\r\n\r\n일단 2024년 2월 1일부로 요금 정책이 바뀐 것을 확인 할 수 있다.\r\n\r\n해당 내용은 **[https://aws.amazon.com/ko/blogs/korea/new-aws-public-ipv4-address-charge-public-ip-insights/](https://aws.amazon.com/ko/blogs/korea/new-aws-public-ipv4-address-charge-public-ip-insights/)** 여기에서 확인 가능하다.\r\n\r\n![Public IPv4](img_4.png)\r\n\r\n![Public IPv4 비용](img_5.png)\r\n\r\n고객센터 문의 결과는 **EC2에 대해선 750시간 ‘Public IPv4’를 지원하지만, RDS는 지원하지 않는다는 답변이였다!!!!**\r\n\r\n원래는 DB를 datagrip를 연결하여, ‘격자-위경도’ 엑셀 데이터를 DB에 import 할 생각에 퍼블릭으로 설정해놨었다. 대략 아래 같은 아키텍쳐이다.\r\n\r\n![기존 아키텍처](img_6.png)\r\n\r\n하지만 EC2 인스턴스에 대해서는 **‘Public IPv4’**를 지원하기 때문에 아래처럼 아키텍처를 변경하였다.!! 🙉\r\n![바뀐 아키텍처](img_7.png)\r\n\r\n### 결론\r\n> - RDS 인스턴스 삭제 후 스냅샷도 남아있는지 확인\r\n> - EC2를  Bastion Host 처럼 활용 <br> (단, 사용시 RDS, EC2는 같은 VPC안에 소속되어 있지만, EC2가 RDS에 접속하려면 security group을 통해 허용되어야 한다!)\r\n"},{"excerpt":"1. String Java의 String은 불변입니다. 즉, 일단 생성된 값은 변경할 수 없습니다.  \n'String'을 수정하는 것처럼 보이는 작업을 수행할 때마다 실제로는 새로운 'String' 개체를 생성하는 것입니다. 특성 Immutable(불변): String 객체가 생성되면 해당 값을 변경할 수 없습니다. Thread-safe(스레드로부터 안전…","fields":{"slug":"/string-stringBuffer-stringBuilder/"},"frontmatter":{"date":"January 14, 2024","title":"String & StringBuffer & StringBuilder 차이","tags":["JAVA"]},"rawMarkdownBody":"\r\n## 1. String\r\n > **Java의 String은 불변입니다. 즉, 일단 생성된 값은 변경할 수 없습니다.** <br> \r\n > 'String'을 수정하는 것처럼 보이는 작업을 수행할 때마다 실제로는 새로운 'String' 개체를 생성하는 것입니다.\r\n\r\n```java\r\npublic class StringExample {\r\n    public static void main(String[] args) {\r\n        String str1 = \"Hello\";\r\n        String str2 = \"World\";\r\n\r\n        // Concatenation creates a new String object\r\n        String result = str1 + \", \" + str2;\r\n\r\n        System.out.println(result); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class StringExample {\r\n    public static void main(String[] args) {\r\n        \r\n        String str1 = \"Hello\";\r\n        System.out.println(\"str1 address: \" + System.identityHashCode(str1));\r\n        //   str1 address: 81628611\r\n        \r\n        str1=\"World\";\r\n        System.out.println(\"str1 address: \" + System.identityHashCode(str1));\r\n        //   str1 address: 1072408673\r\n        \r\n        String str2 = \"Hello\";\r\n        System.out.println(\"str2 address: \" + System.identityHashCode(str2));\r\n        //    str2 address: 81628611\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 특성\r\n- **Immutable(불변)**: String 객체가 생성되면 해당 값을 변경할 수 없습니다.<br>\r\n- **Thread-safe(스레드로부터 안전함)**: String 객체는 불변이기 때문에 데이터 손상 위험 없이 여러 스레드 간에 안전하게 공유될 수 있습니다.<br>\r\n- **Slower Concatenation(느린 연결)**: '+' 연산자를 사용하여 문자열을 연결하는 것은 비효율적일 수 있습니다. 특히 루프에서는 매번 새 개체가 생성되므로 비효율적일 수 있습니다.<br>\r\n- **사용 사례**: <br>\r\n  - 문자열의 값이 자주 변경되지 않을 것으로 예상되는 경우. 스레드 안전성이 중요한 상황.\r\n\r\n## 2. StringBuffer\r\n   > StringBuffer도 시퀀스의 문자를 나타내도록 설계되었지만 String과 달리 변경할 수 있습니다. \r\n   > 즉, 새 개체를 만들지 않고도 StringBuffer 개체의 내용을 수정할 수 있습니다.\r\n\r\n```java\r\npublic class StringBufferExample {\r\n    public static void main(String[] args) {\r\n        StringBuffer buffer = new StringBuffer(\"Hello\");\r\n\r\n        // Modifying StringBuffer\r\n        buffer.append(\", \").append(\"World\");\r\n\r\n        System.out.println(buffer.toString()); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n\r\n### 특성\r\n- **Mutable(변경 가능)**: 새 객체를 생성하지 않고도 StringBuffer의 내용을 수정할 수 있습니다.\r\n- **Thread-safe(스레드로부터 안전함)**: StringBuffer 메소드가 동기화되어 멀티 스레드 환경에서 사용하기에 안전합니다.<br>\r\n- **Slower performance(느린 성능)**: 동기화로 인해 StringBuffer 작업은 StringBuilder 작업보다 느립니다.<br>\r\n- **사용 사례**:<br>\r\n  - 스레드 안전성이 요구되는 멀티스레드 환경에서. 문자열에 대한 동적 수정이 필요한 경우.\r\n\r\n### Thread 안정성 및 속도 Test\r\n```java\r\npublic class StringBufferThreadUnsafeExample {\r\n    private static StringBuffer stringBuffer = new StringBuffer();\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        Thread thread1 = new Thread(() -> {\r\n            for (int i = 0; i < 10000; i++) {\r\n                stringBuffer.append(\"A\");\r\n            }\r\n        });\r\n\r\n        Thread thread2 = new Thread(() -> {\r\n            for (int i = 0; i < 10000; i++) {\r\n                stringBuffer.append(\"B\");\r\n            }\r\n        });\r\n\r\n        // Start both threads\r\n        thread1.start();\r\n        thread2.start();\r\n\r\n        // Wait for both threads to finish\r\n        thread1.join();\r\n        thread2.join();\r\n\r\n        long endTime = System.currentTimeMillis();\r\n\r\n        // Check if StringBuilder contains only \"A\" and \"B\" characters\r\n        String result = stringBuffer.toString();\r\n        int countA = (int) result.chars().filter(ch -> ch == 'A').count();\r\n        int countB = (int) result.chars().filter(ch -> ch == 'B').count();\r\n        System.out.println(\"'A' count : \" +countA);\r\n        System.out.println(\"'B' count : \" +countB);\r\n        assert countA == 10000 : \"예상되는 10000자의 'A' 문자, 찾은 문자 \" + countA;\r\n        assert countB == 10000 : \"예상되는 10000자의 'A' 문자, 찾은 문자 \" + countB;\r\n\r\n        long executionTime = endTime - startTime;\r\n        System.out.println(\"실행시간 : \" + executionTime);\r\n    }\r\n}\r\n```\r\n#### 결과\r\n![img_3.png](img_3.png)\r\n\r\n## 3. StringBuilder\r\n   > StringBuilder는 변경 가능한 문자 시퀀스를 나타낸다는 점에서 StringBuffer와 유사합니다. \r\n   > 그러나 StringBuffer와는 달리 동기화되지 않으므로 단일 스레드 환경에서 더 빠릅니다.\r\n\r\n```java\r\npublic class StringBuilderExample {\r\n    public static void main(String[] args) {\r\n        StringBuilder builder = new StringBuilder(\"Hello\");\r\n\r\n        // Modifying StringBuilder\r\n        builder.append(\", \").append(\"World\");\r\n\r\n        System.out.println(builder.toString()); // Output: Hello, World\r\n    }\r\n}\r\n```\r\n### 특성\r\n- **Mutable(변경 가능)**: StringBuffer와 마찬가지로 새 객체를 생성하지 않고도 StringBuilder의 내용을 수정할 수 있습니다.\r\n- **Not thread-safe(스레드 안전하지 않음)**: StringBuffer와 달리 StringBuilder 메서드는 동기화되지 않으므로 멀티 스레드 환경에서 사용하기에 적합하지 않습니다.\r\n- **Faster performance(더 빠른 성능)**: 'StringBuilder'는 동기화 부족으로 인해 'StringBuffer'보다 빠릅니다.\r\n- **사용 사례**:\r\n  - 스레드 안전성이 문제가 되지 않는 단일 스레드 환경에서. 문자열에 대한 동적 수정이 필요하고 성능이 중요한 경우.\r\n\r\n### Thread 안정성 및 속도 Test\r\n```java\r\npublic class StringBuilderThreadUnsafeExample {\r\n    private static StringBuilder stringBuilder = new StringBuilder();\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        Thread thread1 = new Thread(() -> {\r\n            for (int i = 0; i < 10000; i++) {\r\n                stringBuilder.append(\"A\");\r\n            }\r\n        });\r\n\r\n        Thread thread2 = new Thread(() -> {\r\n            for (int i = 0; i < 10000; i++) {\r\n                stringBuilder.append(\"B\");\r\n            }\r\n        });\r\n\r\n        // Start both threads\r\n        thread1.start();\r\n        thread2.start();\r\n\r\n        // Wait for both threads to finish\r\n        thread1.join();\r\n        thread2.join();\r\n\r\n        long endTime = System.currentTimeMillis();\r\n\r\n        // Check if StringBuilder contains only \"A\" and \"B\" characters\r\n        String result = stringBuilder.toString();\r\n        int countA = (int) result.chars().filter(ch -> ch == 'A').count();\r\n        int countB = (int) result.chars().filter(ch -> ch == 'B').count();\r\n        System.out.println(\"'A' count : \" +countA);\r\n        System.out.println(\"'B' count : \" +countB);\r\n        assert countA == 10000 : \"예상되는 10000자의 'A' 문자, 찾은 문자 \" + countA;\r\n        assert countB == 10000 : \"예상되는 10000자의 'A' 문자, 찾은 문자 \" + countB;\r\n\r\n        long executionTime = endTime - startTime;\r\n        System.out.println(\"실행시간 : \" + executionTime);\r\n    }\r\n}\r\n```\r\n#### 결과\r\n![img_2.png](img_2.png)\r\n## 결론\r\n![img.png](img.png)\r\n\r\n### String 을 사용해야 할 때 :\r\n- String은 불변성\r\n- 문자열 연산이 적고 변하지 않는 문자열을 자주 사용할 경우\r\n- 멀티쓰레드 환경일 경우 \r\n\r\n\r\n### StringBuilder 를 사용 해야 할 때 :\r\n- StringBuilder는 가변성\r\n- 문자열의 추가, 수정, 삭제 등이 빈번히 발생하는 경우\r\n- 동기화를 지원하지 않아, 단일 쓰레드이거나 동기화를 고려하지 않아도 되는 경우\r\n- 속도면에선 StringBuffer 보다 성능이 좋다.\r\n- 더 나은 성능을 갖춘 단일 스레드 환경에서 변경 가능한 문자열이 필요한 경우 'StringBuilder'를 선택\r\n\r\n### StringBuffer 를 사용해야 할 때 :\r\n- StringBuffer는 가변성\r\n- 문자열의 추가, 수정, 삭제 등이 빈번히 발생하는 경우\r\n-  스레드 안전성이 중요한 경우 'StringBuffer'를 선택\r\n- 동기화를 지원하여, 멀티 스레드 환경에서도 안전하게 동작\r\n<br>\r\n\r\n## 참고사항\r\n![img_1.png](img_1.png)\r\n\r\n 사실 <span style=\"color:orange\"> 자바는 문자열에 + 연산을 사용하면, 컴파일 전 내부적으로 StringBuilder 클래스를 만든 후 다시 문자열로 돌려준다고 한다.</span>\r\n\r\n즉, \"hello\" + \"world\" 문자열 연산이 있다면 이는 new StringBuilder(\"hello\").append(\"world\").toString() 과 같다는 말이다.\r\n\r\n```java\r\n    String a = \"hello\" + \"world\";\r\n\r\n    /* 는 아래와 같다. */\r\n    String a = new StringBuilder(\"hello\").append(\"world\").toString();\r\n// StringBuilder를 통해 \"hello\" 문자열을 생성하고 \"world\"를 추가하고 toString()을 통해 String 객체로 변환하여 반환Copy\r\n```\r\n\r\n이처럼 겉으로는 보기에는 문자열 리터럴로 + 연산하거나, StringBuilder 객체를 사용하거나 어차피 자동 변환해줘서 차이가 없어 보일지도 모른다.<br>\r\n하지만 다음과 같이 문자열을 합치는 일이 많을 경우 단순히 + 연산을 쓰면 성능과 메모리 효율이 떨어지게 된다.\r\n``` java\r\n\r\n    String a = \"\";\r\n    \r\n    for(int i = 0; i < 10000; i++) {\r\n        a = a + i;\r\n    }\r\n    \r\n    /* 위의 문자열 + 연산 식은 결국 아래와 같다. */\r\n    /* 즉, 매번 new StringBuilder() 객체 메모리를 생성하고 다시 변수에 대입하는 멍청한 짓거리를 하고 있는 것이다. */\r\n    \r\n    String a = \"\";\r\n    \r\n    for(int i = 0; i < 10000; i++) {\r\n        a = new StringBuilder(b).append(i).toString();\r\n    }\r\n```\r\n\r\n\r\n#### 📖 참고문헌 📖\r\n- https://inpa.tistory.com/entry/JAVA-☕-String-StringBuffer-StringBuilder-차이점-성능-비교#문자열_자료형_비교_총정리\r\n"},{"excerpt":"REST API란? 💡 REST는 Representational State Transfer의 약자로, 웹에서 데이터를 전송하고 처리하는 방법을 정의한 하나의 인터페이스를 말한다. \nREST API의 개략적인 구조(출처 : cloudinary) REST API 6가지 특징 무상태(Statelessness): 클라이언트에서 서버로의 각 요청은 해당 요청을 이…","fields":{"slug":"/rest-api-url-naming/"},"frontmatter":{"date":"January 14, 2024","title":"REST API 설계 및 명명규칙","tags":["REST API"]},"rawMarkdownBody":"\r\n## REST API란?\r\n\r\n> 💡 REST는 Representational State Transfer의 약자로, 웹에서 데이터를 전송하고 처리하는 방법을 정의한 하나의 인터페이스를 말한다.\r\n\r\n\r\n![img.png](img.png)\r\nREST API의 개략적인 구조(출처 : cloudinary)\r\n\r\n## REST API 6가지 특징\r\n\r\n1. **무상태(Statelessness):** 클라이언트에서 서버로의 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다. 서버는 요청 사이에 클라이언트 상태에 대한 정보를 저장해서는 안 됩니다.\r\n2. **클라이언트-서버 아키텍처:** 클라이언트와 서버는 네트워크를 통해 통신하는 별개의 엔터티입니다. 클라이언트는 사용자 인터페이스와 사용자 경험에 책임을 지고, 서버는 요청을 처리하고 리소스를 관리합니다.\r\n3. **일관된 인터페이스:** 아키텍처를 단순화하고 분리하는 일련의 제약 조건입니다. 일관된 인터페이스는 URI(Uniform Resource Identifier)를 통한 리소스 식별, 표현을 통한 리소스 조작, 표준 HTTP 메서드(GET, POST, PUT, DELETE) 사용 등의 원칙을 포함합니다.\r\n4. **리소스 중심:** 리소스(데이터 객체 또는 서비스와 같은)는 URI에 의해 식별되며 표준 HTTP 메서드를 사용하여 조작됩니다.\r\n5. **표현(Representation):** 리소스는 여러 표현(JSON 또는 XML과 같은)을 가질 수 있으며 클라이언트는 서버와 표현을 협상할 수 있습니다.\r\n6. **무상태 통신(Stateless Communication):** 클라이언트에서 서버로의 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다. 서버는 요청 사이에 클라이언트 상태를 저장하지 않습니다.\r\n7. **무상태 서버(Stateless Server):** 서버는 클라이언트 상태를 저장하지 않습니다. 각 요청은 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함합니다.\r\n8. **캐시 가능성(Cacheability):** 서버에서의 응답은 명시적으로 캐시 가능하거나 캐시 불가능하게 표시될 수 있어 클라이언트가 응답을 캐시하여 성능을 향상시킬 수 있습니다.\r\n9. **계층화된 시스템(Layered System):** 아키텍처는 여러 계층(프록시, 게이트웨이 및 방화벽과 같은)으로 구성될 수 있어 시스템의 확장성과 보안을 향상시킬 수 있습니다.\r\n\r\n## **REST API를 잘 작성하기 위한 15가지 방법**\r\n\r\n### **1. 엔드포인트 경로에는 명사를 사용**\r\n\r\n**검색하거나 조작하는 엔터티를 나타내는 명사를** 항상 경로 이름으로 사용해야 하며 항상 **복수형** 지정을 사용하는 것이 좋다. **HTTP 요청 메서드** 에 이미 동사가 있고 실제로 새 정보를 추가하지 않으므로 엔드포인트 경로에 동사를 지양해야한다.\r\n\r\n작업은 우리가 만들고 있는 HTTP 요청 메서드로 표시되어야 함. \r\n가장 일반적인 방법은 GET, POST, PATCH, PUT 및 DELETE이다.\r\n\r\n![img_1.png](img_1.png)\r\n\r\n\r\n> 💡 **HTTP 요청메소드**\r\n> - GET은 리소스를 검색합니다.\r\n> - POST는 새 데이터를 서버에 제출합니다.\r\n> - PUT/PATCH는 기존 데이터를 업데이트합니다.\r\n> - DELETE는 데이터를 제거합니다.\r\n> - HEAD: GET과 동일하지만 응답 본문이 없습니다. 리소스의 헤더만 검색하는 데 사용됩니다.\r\n> - TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행하는 데 사용됩니다.\r\n> - OPTIONS: 대상 리소스에 대한 통신 옵션을 설명하는 데 사용됩니다.<br/>\r\n>   브라우저는 서버의 CORS 헤더를 확인하기 위해 실행 전 요청\r\n> - CONNECT: 동적으로 터널로 전환할 수 있는 프록시와 함께 사용하도록 예약되어 있습니다. 네트워크 터널을 설정하는 데 사용됩니다.\r\n\r\n\r\n1. GET /members\r\n2. GET /get-members\r\n\r\n위에서 권장한 방법대로라면, 1번이 옳은 것. 이미 GET이라는 HTTP 메소드가 해당 API의 역할을 충분히 설명하고 있기 때문에, 마지막 경로에 동사를 넣게 되면 중복된 설명이 된다.\r\n\r\n해당 방법으로 HTTP 요청 메소드를 보면 아래처럼 예시를 보여줄 수 있다.\r\n\r\n\r\n> 💡 회원 목록 /members -> GET<br/>\r\n> 회원 등록 /members -> POST<br/>\r\n> 회원 조회 /members/{id} -> GET<br/>\r\n> 회원 수정 /members/{id} -> PATCH, PUT, POST<br/>\r\n> 회원 삭제 /members/{id} -> DELETE<br/>\r\n\r\n\r\n\r\n### 2. 데이터 송수신 포멧으로는 JSON을 사용하자.\r\n\r\n예전에는 XML을 이용했지만, 최근에는 JSON(JavaScript Object Notation)가 API 데이터 송수신 표준 형식이 되었다.\r\n\r\nJSON의 장점을 간략하게 설명하면 다음과 같다.\r\n\r\n- 인간이 읽을 수 있는 텍스트로, 사용이 편리함\r\n- 최소한의 정보를 함축적으로 표현(XML에 비해 적은 용량으로 빠르게 통신 가능)\r\n- 언어에 독립적\r\n\r\n일반적으로 제공되는 form-data는 클라이언트가 텍스트 또는 숫자 형식의 데이터를 보낼 때는 적합하지 않고, 어차피 대부분의 프레임워크에서 클라이언트가 데이터를 전송할 때 JSON을 사용할 수 있도록 기능을 제공하고 있다. 간단하게 헤더의 Content-Type 부분을 application/json으로 설정하기만 하면 된다.\r\n\r\n### 3. HTTP 상태코드를 적극적으로 활용하자.\r\n\r\nHTTP에는 이미 수많은 사람들이 사용하고 있는 상태 코드들이 정의되어 있다. API 처리가 정상적으로 이루어졌는지, 혹 아니라면 무슨 이유인지 명확하게 표현하기에 가장 적합하다.\r\n\r\n상태 코드에는 대표적으로 아래와 같은 종류가 있다.\r\n\r\n\r\n> 💡 **대표적인 상태 코드**\r\n> - 200 : 클라이언트의 요청이 정상적으로 수행되었음\r\n> - 201 : 클라이언트가 생성과 관련된 요청을 하였고, 이 요청이 정상적으로 완료됨(POST)\r\n> - 301 : 클라이언트가 요청한 데이터의 URI가 변경되었을 경우\r\n> - 400 : 클라이언트의 요청이 부적절한 경우\r\n> - 401 : 클라이언트가 인증과정(로그인 등)을 거치지 않은 상태에서 보안된 데이터에 접근하려고 하는 경우\r\n> - 403 : 클라이언트가 인증과 관련 없이, 존재는 하지만 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 X)\r\n> - 404 : 클라이언트가 인증과 관련 없이, 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 O)\r\n> - 405 : 클라이언트가 요청한 데이터에 해당 메소드가 존재하지 않거나 사용 불가능 상태인 경우\r\n> - 500 : 서버에 문제가 있을 경우\r\n\r\n\r\n이 외에도 수많은 상태 코드들이 있는데, 중요한 것은 ‘가장 최소한의 개수를 사용’하여 클라이언트가 API 요청 또는 응답에 적절한 상태 코드를 부여할 수 있도록 하는 것이다.\r\n\r\n### 4. 응답 메시지는 표준화 된 내용으로 반환하자.\r\n\r\n어떠한 요청에 대한 데이터라 하더라도, 서버로부터 항상 유사한 형태의 표준화된 응답 구조를 사용해야 한다. 그렇게 해야 클라이언트는 동일한 구조 내에서 원하는 값을 예측해서 가져올 수 있게 된다. 만약 아래와 같은 구조가 존재한다고 하자.\r\n\r\n```json\r\n[\r\n  {\r\n     bookId: 1,\r\n     name: \"The Republic\"\r\n  },\r\n  {\r\n     bookId: 2,\r\n     name: \"Animal Farm\"\r\n  }\r\n]\r\n```\r\n\r\n또는 아래와 같이 조금 더 중첩된 구조를 가질 수도 있다\r\n\r\n```json\r\n{\r\n   \"data\": [ \r\n     {\r\n       \"bookId\": 1,\r\n       \"name\": \"The Republic\"\r\n     },\r\n     {\r\n       \"bookId\": 2,\r\n       \"name\": \"Animal Farm\"\r\n     }\r\n   ],\r\n   \"totalDocs\": 200,\r\n   \"nextPageId\": 3\r\n}\r\n```\r\n\r\n만약 새로운 책을 추가한다고 하자. 성공했을 경우 권장하는 응답 메시지는 아래와 같다.\r\n\r\n```json\r\n// POST /books\r\n{\r\n     \"bookId\": 3,\r\n     \"name\": \"Toy Story\"\r\n}\r\n```\r\n\r\n만약 여기서 ‘책이 성공적으로 등록되었습니다’ 라는 메시지를 추가하면 어떨까? 답은 ‘불필요하다’이다. 우리는 위에서 상태코드를 통해 해당 요청이 정상적으로 완료되었는지 혹은 문제가 생겼는지를 확인하자고 했다. 추가적인 메시지는 중복된 내용을 포함하는 꼴만 만들게 된다.\r\n\r\n오히려 문제가 발생한 경우에 대해서는 무슨 오류가 있었는지에 대한 메시지를 적어주는 것이 좋다. 그렇게 해야 클라이언트가 해당 문제를 빠르게 확인하고 조치를 취할 수 있기 때문이다. 아래와 같은 응답이 적절한 예시가 될 수 있을 것이다.\r\n\r\n```json\r\n{\r\n  \"code\": \"book/not_found\",\r\n  \"message\": \"A book with the ID 6 could not be found\"\r\n}\r\n```\r\n\r\n응답 메시지에 HTTP 상태 코드를 포함할 필요까지는 없지만, 그래도 사용자 또는 클라이언트가 해당 오류에 대해 빠르게 확인할 수 있도록 오류를 매핑한 코드와 이를 간략하게 설명한 메시지 정도는 정의해두는 것이 좋다. 물론 운영환경에서는 불필요한 보안 정보를 노출하게 될 수 있기 때문에, 개발 단계에서만 이를 노출하는 것이 좋다.\r\n\r\n### **5. 페이징 기법을 활용하여 컬렉션으로 받은 많은 데이터를 효율적으로 처리하자.**\r\n\r\n데이터가 많아질수록, 데이터를 어떻게 반환해서 보여줄지가 굉장히 중요해진다. 위에서 정의한 API 중, 등록된 전체 책의 개수를 반환하려고 한다고 가정하자. 책의 개수가 적을 때는 문제가 없겠지만, 수백만권 혹은 수천만권의 책이 있다고 한다면 해당 API를 호출하는 것은 성능이나 대역폭 측면에서 좋지 못한 선택이 될 수 있다.\r\n\r\n페이징 기법(Pagination)을 사용하는 방법으로는 크게 skip, limit 또는 keyset이 있다. 일반적으로 skip, limit을 사용하지만, 페이징 기법을 위해서라도 keyset을 사용하는 것을 권장한다.\r\n\r\n\r\n> - skip : 출력할 데이터의 시작부분을 설정한다. 입력값으로 들어온 값 + 1부터 출력한다.\r\n> - limit : 출력할 데이터의 개수를 제한한다. 입력값으로 들어온 값 만큼만 반환한다.\r\n> - keyset : 식별자 또는 ID를 참조 값으로 받아서 테이블을 별도로 스캔하지 않고 조건에 맞게 페이징하여 반환한다.\r\n\r\n\r\n추가로 API의 결과 값을 필터링 또는 정렬할 수 있는 기능도 필요하다. 성능을 향상시키기 위해 DB 인덱스에 접근(Access) 패턴을 적용하기도 하는데, 결론적으로 API 호출에 필요한 필터와 정렬은 쿼리 파라미터에 정의되어야 한다.\r\n\r\n```json\r\n# romance 범주에 속하는 책 10권을 조회한다고 가정하는 API\r\nGET /books?limit=10&category=romance\r\n```\r\n\r\n### **6. PUT 보다는 PATCH를 사용하자.**\r\n\r\nPUT과 PATCH의 가장 큰 차이는 ‘데이터 내에 변경되는 요소의 범위’이다.\r\n\r\n- PUT : 데이터 내 모든 요소를 수정\r\n- PATCH : 데이터 내 요소 중 일부만 수정\r\n\r\n일반적으로 데이터 내에 있는 모든 요소를 한번에 변경하는 일은 거의 발생하지 않는다. 추가로 의도하지 않게 변경해서는 안되는 요소마저도 변경될 소지가 존재한다. 그렇기 때문에 되도록이면 PATCH를 권장하며, PUT을 절대 사용해서는 안되는 것은 아니다.\r\n\r\n### 7. Extended 옵션을 사용해서 선택적으로 결과 값을 반환하자.\r\n\r\n시스템이 커질수록 데이터 내 요소들도 증가할 수 밖에 없다. 문제는 모든 클라이언트에서도 증가한 요소들을 전부 사용하진 않는다는 것이다.\r\n\r\n이를 해결하기 위해 extended라는 옵션을 사용한다. 아래는 extended 옵션의 유무에 따른 결과 값의 차이를 보여준다.\r\n\r\n```json\r\nGET /books/:id\r\n{\r\n   \"bookId\": 1,\r\n   \"name\": \"Harry Potter\"\r\n}\r\nGET /books/:id?extended=true\r\n{\r\n   \"bookId\": 1,\r\n   \"name\": \"Harry Potter\"\r\n   \"tags\": [\"fantasy\", \"magic\", \"UK\"],\r\n   \"author\": {\r\n      \"id\": 1,\r\n      \"name\": \"J.K.Rowling\"\r\n   }\r\n}\r\n```\r\n\r\n### 8. 적절하게 엔드포인트의 크기를 나눠주자.\r\n\r\nAPI의 기본 사상은 ‘주어진 하나의 일을 잘 수행하자’ 이다. 한번에 여러 작업을 해결할 수 있는 것 보다, 한 눈에 사용 가능한 기능을 확인할 수 있는 작은 단위의 API 설계가 중요하다(어찌보면 books이라는 엔드포인트는 어떻게보면 굉장히 큰 단위일 수 있다). 그리고 이러한 작은 단위의 API를 적절하게 통합하여 클라이언트가 쉽게 기능을 예측하고 이해할 수 있도록 돕는 것이 좋다.\r\n\r\n### 9. 정확한 API 문서를 제공하자.\r\n\r\nAPI의 궁극적인 목적은 ‘클라이언트가 원하는 기능을 한눈에 알아보고 적절하게 프로그램 상에 배치해서 기능을 수행할 수 있도록 하는 것’이다. 이를 위해서는 API에 대해 잘 정리된 문서가 중요하다.\r\n\r\n문서에는 각 엔드포인트의 목적과 이를 실행하기 위한 권한, 호출하였을 때의 응답 예시, 그리고 실패하였을 때의 오류 메시지가 꼭 명시되어야 한다. 그리고 API의 버전이 변경됨에 따라 내부 기능의 변화 과정을 문서에 꼭 작성해야 한다. 기본적으로 Swagger와 같이 API의 개발과 문서 작성을 동시에 해주는 도구가 있다. 혹은 Postman으로 API를 테스트하고, 이를 문서화 된 파일로 저장해주는 도구도 존재한다.\r\n\r\n### 10. 보안을 위한 기능을 꼭 적용하자.\r\n\r\n가장 일반적인 방법으로 SSL을 서버에 적용하면, 클라이언트-서버 간 안전한 통신을 보장하면서 잠재적으로 발생 가능한 공격을 막을 수 있다.\r\n\r\n웹 상에서는 Origin이라는 개념이 존재하는데, 이는 URL 상에서 프로토콜, 도메인, 포트 번호를 합친 부분을 말한다. 접속중인 웹사이트의 Origin은 window.location.origin 명령어를 통해 확인할 수 있다.\r\n\r\n웹 브라우저는 보안 때문에 같은 Origin끼리 통신할 수 있도록 하는 SOP(Same Origin Policy)와 다른 Origin으로도 요청을 보낼 수 있도록 예외를 허용하는 CORS(Cross Origin Resource Sharing) 정책이 존재한다. API의 특성 상 서로 다른 Origin 간 통신은 당연히 발생하기 때문에, CORS를 이용하여 적절하게 HTTP 통신을 제한할 수 있는 기능을 지원해야 한다.\r\n\r\nCORS 프로토콜은 브라우저가 사전 요청(preflight request)을 서버에 보내고, 이를 승인 받은 경우에만 통신할 수 있도록 한다. 이 사전 요청은 HTTP 요청 중 OPTION 메소드를 사용하는데, 이를 위해서는 아래의 사항을 선택적으로 응답 헤더에 넣어야 한다.\r\n\r\n\r\n> 💡 **응답헤더**\r\n>  - Access-Control-Allow-Origin: *\r\n>  - Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE\r\n>  - Access-Control-Allow-Headers: Content-Type, Authorization\r\n\r\n\r\n### 11. API 버전을 명시하자.\r\n\r\n개발 과정이 되었든 운영 중에 API 엔드포인트를 변경하거나 내부 구조를 변경하였든, API와 관련된 어느것이라도 변경이 발생하였다면 이를 버전화해야 한다. 클라이언트가 모르는 상태로 갑자기 API의 엔드포인트를 변경해서는 안된다. API는 어떠한 변경이 발생하더라도, 이전의 통신 상태에까지 영향을 주어서는 안된다. 즉, 기존의 방법대로 통신하는 어플리케이션이 하나라도 존재한다면, 해당 기능을 임의대로 정지해서는 안된다.\r\n\r\n\r\n> 1. 헤더에 추가: \"x-version=v2\"\r\n> 2. 파라미터에 추가: \"?apiVersion=2\"\r\n> 3. URL에 포함:  \"/v2/books/:id\"\r\n\r\n\r\n### 12. 캐시 데이터를 사용해서 성능을 향상시키자.\r\n\r\n빈번하게 사용되면서 동시에 변경이 거의 발생하지 않는 데이터는 캐싱하는 것이 좋다. 인메모리(in-memory) 또는 캐시 데이터베이스(cached-database)를 이용하는 것이 메인 데이터베이스를 접근하는 것보다 훨씬 좋은 성능을 보인다.\r\n\r\n다만 캐싱된 데이터의 경우 만료기간이 존재할 수 있기 때문에, 적절한 시기에 이를 업데이트 할 수 있도록 구현하는 것이 중요하다. 캐시된 데이터를 사용할 때에는 반드시 HTTP 헤더에 Cache-Control를 포함해야 한다.\r\n\r\n### 13. 표준 UTC를 사용하자.\r\n\r\nAPI는 시간 또는 공간에 상관없이 어디에서나 호출될 수 있다. 그렇기 때문에 동일한 날짜 표준 방식을 통해 일관성 있는 출력을 보여줄 필요가 있다. ISO8601은 날짜/시간 데이터의 국제 표준 방식으로, 날짜는 Z 또는 UTC 형식이어야 한다.\r\n\r\n```json\r\n{\r\n    \"createdAt\": \"2022-03-08T19:15:08Z\"\r\n}\r\n```\r\n\r\n### 14. 주기적인 헬스체크를 해주자.\r\n\r\nAPI에 문제가 생겨서 시스템을 정지해야 할 경우, 해당 API는 어쩔 수 없이 복구가 될 때까지는 사용이 불가능하다. 이를 위해 API 호출 시점에 해당 API가 정상적으로 사용 가능한지 확인할 수 있는 헬스체크(Health-check) 시스템이 엔드포인트 상에 적용되어야 한다.\r\n\r\n`GET /health`\r\n\r\n일반적으로 이러한 헬스체크 기능은 로드밸런서 등에서 호출될 수 있으며, API의 동작 여부 뿐만 아니라 유지 보수 기간에 대한 개략적인 기준을 제시할 수도 있다.\r\n\r\n### 15. API Key 인증을 허용하자.\r\n\r\nAPI Key로 인증하게 되면, 3rd party 어플리케이션에서 해당 API를 손쉽게 사용하도록 만들 수 있다. 이를 위해서는 X-Api-Key 또는 Api-Key와 같은 커스텀 HTTP 헤더를 사용해야 한다. 특히 Key의 사용 기한을 정해서 만료일이 있도록 해야 보안상 문제가 발생하였을 경우 이를 무효화할 수 있다는 것을 염두하자.\r\n\r\n\r\n> 💡 참고 문헌\r\n> - https://medium.com/@liams_o/15-fundamental-tips-on-rest-api-design-9a05bcd42920\r\n> - https://restfulapi.net/rest-api-design-tutorial-with-example/\r\n> - https://wnjoon.github.io/2022/11/08/swe-restapi_design/\r\n\r\n"},{"excerpt":"String 재사용(Interning) new 연산자를 이용한 방식\nnew를 통해 String을 생성하면 Heap 영역에 존재하게 된다. 리터럴을 이용한 방식\nstring constant pool이라는 영역에 존재하게 된다. 해당 코드를 실행하면 객체가 3개가 아니라 2개가 만들어진다. 왜 2개일까? 이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모…","fields":{"slug":"/string-pool/"},"frontmatter":{"date":"January 13, 2024","title":"Java String VS new String()","tags":["JAVA"]},"rawMarkdownBody":"\r\n## String 재사용(Interning)\r\n\r\n> - **new 연산자를 이용한 방식**<br>\r\nnew를 통해 String을 생성하면 Heap 영역에 존재하게 된다.<br>\r\n> - **리터럴을 이용한 방식**<br>\r\nstring constant pool이라는 영역에 존재하게 된다.\r\n\r\n```java\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"Hi\");\r\n        String str2 = \"Hi\";\r\n        String str3 = \"Hi\";\r\n    }\r\n}\r\n```\r\n\r\n해당 코드를 실행하면 **객체가 3개가 아니라 2개**가 만들어진다.\r\n\r\n왜 2개일까?\r\n\r\n이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모리 구조상에서 차이가 발생한다.\r\n\r\nString은 다른 객체들에 비해 광범위하고, 빈번하게 사용되므로 String을 사용할 때마다 객체를 생성하는 방식으로 사용하게 된다면, 새로운 객체를 계속 만들어내는 것이기 때문에 **메모리 관리 측면에서 비효율적**이다.\r\n이러한 String을 효율적으로 관리하기 위해, Heap 메모리영역 속에 <span style=\"color:blue\"> **String Constant Pool** </span>을 만들었다.\r\n이곳에는 생성된 문자열의 값을 보관하고 있으며, 리터럴””로 생성된 같은 값을 가지는 객체는 같은 레퍼런스(참조값, 주소)를 가지게 된다.\r\n\r\n![img.png](img.png)\r\n\r\n위 코드에서는 new String 연산자로 생성된 객체(Heap 메모리 영역에 저장), 그리고 리터럴로 생성된 객체(String Pool에 저장), 총 2개의 객체가 생성되는 것이다.\r\n\r\nJava에서 String은 불변(immutable) 객체입니다. 이 덕분에 JVM은 String Constant Pool에 각 문자열 리터럴의 복사본을 하나만 저장하여, 문자열에 할당되는 메모리 양을 최적화할 수 있습니다.\r\n그리고 해당 과정을 재사용(Interning)이라고 합니다.\r\n<br>\r\nString 변수를 만들고 값을 할당할 때 JVM은 String Constant Pool에서 동일한 값의 String을 검색합니다.\r\n만약 동일한 값을 가진 String이 발견된다면 자바 컴파일러는 추가 메모리를 할당하는 것이 아니라, 단순히 해당 String의 주소에 대한 참조를 반환합니다.\r\n<br>\r\n만약 존재하지 않는다면 해당 값은 String Constant Pool에 추가되고(인턴) 해당 값에 대한 참조가 반환됩니다.\r\n\r\n## 가비지 컬렉터\r\n\r\nJava 7 이전에는 JVM이 고정된 크기를 가진 PermGen이라는 공간에 String Constant Pool을 배치했습니다.\r\nPermGen이라는 공간은 크기가 고정되어 있어서 런타임 시 확장이 불가능하며 garbage collection에 적합하지 않습니다.\r\n\r\nPermGen에서 너무 많은 문자열을 재사용(interning)하는 경우 JVM에서 OutOfMemory 오류가 발생할 수 있습니다.\r\n<br>\r\nJava7 이후부터 String Constant Pool은 JVM에 의해 Garbage Colleted되는 Heap 메모리 영역에 배치되었습니다.\r\nHeap 영역에 배치되는 것의 장점은, 참조되지 않은 String은 GC에 의해 String Constant Pool에서 제거되어 메모리가 해제되기 때문에 OutOfMemory 오류의 위험이 감소한다는 점입니다.\r\n(참고로 PermGen은 Java8부터 Metaspace로 대체되었습니다.)\r\n\r\n## 참고 - Compact Strings\r\n\r\nJava 8버전까지는 String은 내부적으로 UTF-16으로 인코딩된 문자 배열인 char[]로 표현되어 대부분의 언어가 1바이트로 표현이 가능했음에도 불구하고 2바이트의 메모리를 사용했습니다.\r\n그러나 Java 9에서는 Compact Strings를 제공함으로써, 저장된 문자열의 내용에 따라 char[]과 byte[] 사이에서 적절한 인코딩을 선택하여 사용합니다.\r\n따라서 Heap 메모리 사용양이 상당히 줄어들었고, JVM에서 GC 오버헤드가 줄어들었습니다.\r\n\r\n## 왜 String Constant Pool은 Heap 영역에 존재할까?\r\n\r\n자바에서는 객체를 생성하거나 변수를 선언할 때마다 메모리에 저장됩니다.\r\n자바에서 메모리는 Stack과 Heap영역, 이렇게 두 가지 영역으로 나눕니다.\r\nStack 영역과 Heap 영역은 서로 저장하는 데이터가 다르며, 데이터를 저장하는 방법과 데이터에 접근하는 방식이 다릅니다.\r\n\r\n위에서도 배웠지만 String 리터럴(literal)을 선언할 때, JVM은 해당 String 객체를 이곳(String Constant Pool)에 저장하고, Stack 메모리 영역에서 이를 참조합니다.\r\n<br>\r\n(추가로 지금부터 설명하는 String 생성은 특별한 언급이 없는 이상 모두 리터럴로 생성되는 String입니다.)\r\n<br>\r\n<br>\r\n각각의 String 객체를 메모리에 생성하기 전에, JVM은 메모리의 오버헤드를 줄이기 위해 몇가지 과정을 수행합니다.\r\n<br>\r\nString constant pool은 HashMap으로 구현되어 있습니다. Hashmap 각각의 bucket(저장공간)은 같은 해시코드를 가진 String list를 저장합니다. (옛날 버전의 자바에서는 String constant pool의 저장공간은 고정된 크기였으며, 종종 \"객체 Heap을 저장하기 위한 충반한 공간이 없습니다\"라는 오류를 발생시켰습니다.)\r\n<br>\r\n<br>\r\n시스템이 클래스를 로드할 때(클래스 로더에 의해 로드될 때) 모든 클래스의 문자열 리터럴은 application-level pool(String constant pool)로 이동하는데, 이는 서로 다른 클래스의 String 리터럴들은 동일한 객체여야 하기 때문입니다.\r\n그리고 현재 상황(String 리터럴들이 String constant pool로 이동한 상황)에서, pool속에 들어있는 데이터들은 어떠한 종속성 없이도 각각의 Class들에서 사용이 가능해야 합니다.\r\n<br>\r\n일반적으로 Stack 메모리 영역에는 수명이 짧은 데이터들이 저장됩니다. 지역변수, (Heap에 저장된 실제 객체의 주소값을 참조하는) 참조변수, 그리고 실행중인 메소드들이 Stack 메모리 영역에 저장되는 데이터들입니다.\r\n<br>\r\nHeap 메모리 영역은 동적인 메모리 할당을 허용하며 런타임 시 Java의 객체 및 JRE 클래스를 저장합니다.\r\n\r\n참고\r\n\r\n- https://ttl-blog.tistory.com/388\r\n- https://coding-factory.tistory.com/536"},{"excerpt":"❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.  git flow 전략  1. Git 커밋 메시지란 무엇인가요? Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. \n이는 프로젝트 이력에 대한 문서…","fields":{"slug":"/git-commit-message-convention/"},"frontmatter":{"date":"January 13, 2024","title":"Git Commit Message Convention","tags":["Convention"]},"rawMarkdownBody":"\r\n> ❗ 각 회사, 프로젝트 마다 git flow 전략을 가지고 브랜치를 관리 하는 것 처럼  commit message 작성하는 규칙도 중요하다고 생각하여 이 글을 작성합니다.\r\n\r\n **git flow 전략** \r\n - \r\n\r\n## 1. Git 커밋 메시지란 무엇인가요?\r\n   - Git의 맥락에서 커밋 메시지는 특정 커밋의 변경 사항을 설명하는 간략한 설명입니다. <br>\r\n   이는 프로젝트 이력에 대한 문서 역할을 하며, 특정 변경이 이루어진 이유에 대한 통찰력을 제공하고 공동 작업자가 시간에 따른 코드베이스의 발전을 더 쉽게 이해하고 추적할 수 있도록 해줍니다.\r\n\r\n## 2. Git 커밋 메시지 규칙의 중요성\r\n### 2.1 Git 커밋 메시지 규칙은 무엇인가요?\r\n   - Git 커밋 메시지 규칙은 커밋 메시지를 작성하는 일관되고 표준화된 방법을 정의하는 일련의 지침 또는 규칙입니다. <br>\r\n   여기에는 변경 내용의 성격에 대한 정보를 전달하기 위한 구조화된 형식과 특정 규칙이 포함됩니다.\r\n\r\n### 2.2 Git 커밋 규칙을 따라야 하는 이유\r\n   - 명확성 및 가독성: 일관된 커밋 메시지를 통해 팀 구성원은 각 커밋의 목적과 영향을 더 쉽게 이해할 수 있습니다.\r\n   - 검색 및 탐색: 체계적으로 구성된 커밋 메시지는 버전 기록 검색 기능을 향상시켜 특정 변경 사항을 신속하게 식별하는 데 도움이 됩니다.\r\n   - 자동화 및 도구: 많은 개발 도구 및 플랫폼은 변경 로그 생성 또는 CI/CD 파이프라인 트리거와 같은 자동화된 프로세스에 대한 커밋 메시지 규칙을 활용합니다.\r\n> ⚠️ 커밋 컨벤션을 적용시키지 않아도 겉보기에는 특정 커밋을 보고 충분히 어떤 내용의 커밋인지 충분히 이해할 수 있다고 생각이 들 수 있습니다.  \r\n>  그러나 Commit Message 가 누적될수록 가독성이 매우 떨어집니다.\r\n\r\n## 3. Git 커밋 메시지 작성 방법\r\n```markdown\r\ntype(옵션): [#issueNumber-]Subject   \r\n\r\nbody(옵션)                          \r\n\r\nfooter(옵션)                        \r\n```\r\n### 3.1 기본 형식(Commit Message 구조)\r\n> 기본적으로 커밋 메시지는 **제목/텍스트/바닥글**로 구성합니다.\r\n\r\n### 3.2 타입, 태그\r\n```markdown\r\ntag(옵션): [#issueNumber-]Subject\r\n\r\n---------:> 예시 <:---------\r\n\r\nFeat: 이진법 변환 함수 기능 추가 \r\n```\r\n\r\n- 어떤 의도로 커밋했는지를 type에 명시해야 합니다.\r\n\r\n> - 제목은 \" 태그(tag) + 제목(subject) \" 으로 구성되며, 태그는 영어로 쓰되, 첫 문자는 대문자 로 합니다.\r\n> - \"tag: subject\" 의 형태이며, \":\" 뒤에 space 가 있음에 유의합니다.\r\n\r\n##### 자주 사용하는 태그 종류\r\n- Feat : 새로운 기능을 추가하는 경우\r\n- Fix : 버그를 고친경우\r\n- Docs : 문서를 수정한 경우\r\n- Style : 코드 포맷 변경, 세미콜론 누락, 코드 수정이 없는경우\r\n- Refactor : 코드 리펙토링\r\n- Test : 테스트 코드. 리펙토링 테스트 코드를 추가했을 때\r\n- Chore : 빌드 업무 수정, 패키지 매니저 수정\r\n- Design : CSS 등 사용자가 UI 디자인을 변경했을 때\r\n- Rename : 파일명(or 폴더명) 을 수정한 경우\r\n- Remove : 코드(파일) 의 삭제가 있을 때. \"Clean\", \"Eliminate\" 를 사용하기도 함\r\n\r\n##### 기타 태그 타입들\r\n- Add : 코드나 테스트, 예제, 문서등의 추가 생성이 있는경우\r\n- Improve : 향상이 있는 경우. 호환성, 검증 기능, 접근성 등이 될수 있습니다.\r\n- Implement : 코드가 추가된 정도보다 더 주목할만한 구현체를 완성시켰을 때\r\n- Move : 코드의 이동이 있는경우\r\n- Updated : 계정이나 버전 업데이트가 있을 때 사용. 주로 코드보다는 문서나, 리소스, 라이브러리등에 사용합니다.\r\n- Comment : 필요한 주석 추가 및 변경\r\n\r\n### 3.3 제목\r\n- 제목은 코드의 변경 사항에 대해 짧은 요약을 나타냅니다.<br>\r\n\r\n**영어로 제목을 작성하는 경우**<br>\r\n\r\n```markdown\r\n1. 제목은 50자를 넘기지 않고, 대문자로 작성하며 마침표를 붙이지 않습니다.\r\n2. 제목은 과거형을 사용하지 않고, 명령조로 시작합니다.\r\n   ex) 제목을 Fixed 가 아닌, Fix 로 작성합시다.\r\n( 커밋메시지를 예를들어 Fix : \"Modify album buy bug\" 로 작성하기 )\r\n```\r\n \r\n**한글로 제목을 작성하는 경우**<br>\r\n- \"고침\", \"추가\", \"변경\" 등의 명령조 로 시작합니다.<br>\r\n- ex) Feat: \"추가 get data api 함수\r\n\r\n### 3.4 텍스트(본문)  \r\n- 선택사항이지만 복잡한 변경에는 권장됩니다.\r\n- 부연 설명이 필요하거나 커밋한 이유를 설명할 경우 작성해주면 됩니다.\r\n- 본문 내용은 어떻게 변경했는지 보다, 무엇을 변경했는지 또는 왜 변경했는지를 설명하도록 합시다.\r\n- 텍스트는 추가 세부 정보를 제공하고 컨텍스트를 제공하며 변경이 필요한 이유를 설명합니다. \r\n- 제목은 변경 사항을 간략하게 요약한 것입니다. 50자 이내로 작성해야 하며 명령형으로 작성해야 합니다.\r\n\r\n**예시**\r\n````markdown\r\nFeat: 이진법 변환 함수 기능 추가\r\n\r\n외부 API를 통해 받아온 코드를 16진법에서 2진법을 변환하기 위해 유틸 클래스 생성 및 진법 변환 함수 기능 추가 \r\n\r\n````\r\n\r\n### 3.5 바닥글\r\n- 바닥글에는 문제에 대한 참조나 주요 변경 사항과 같은 모든 메타데이터가 포함됩니다. 또한 선택 사항입니다.<br>\r\n- issue tracker id 를 작성할 때 사용합니다.<br>\r\n- 형식 : 꼬리말은 \"유형: #이슈 번호\" 형식으로 사용합니다.<br>\r\n- 해결된 이슈도 추가하여 줘야합니다.\r\n\r\n\r\n**바닥글에 사용되는 태그들**<br>\r\n\r\n- Closes:<br>\r\n    Example: Closes #123 <br>\r\n    커밋이 특정 문제 번호를 종료. <br>\r\n\r\n- Resolves:<br>\r\n  Example: Resolves #789 <br>\r\n  'Closes' 및 'Fixes'와 마찬가지로 커밋으로 특정 문제가 해결되었음을 나타냅니다.<br>\r\n  \r\n- Fixes:<br>\r\n    Example: Fixes #456<br>\r\n    'Closes'와 유사하며 커밋이 특정 문제를 해결했음을 나타냅니다(아직 해결이 되지 않는 경우)<br>\r\n  \r\n- Breaking Change:<br>\r\n    Example: BREAKING CHANGE: The API endpoint has been deprecated. Update your calls accordingly.<br>\r\n    커밋이 주요 변경 사항을 도입하고 세부 정보를 제공하도록 지정합니다.<br>\r\n\r\n- Signed-off-by:<br>\r\n    Example: Signed-off-by: John Doe <john@example.com><br>\r\n    작성자가 커밋을 승인했음을 나타냅니다. 이는 오픈 소스 프로젝트에서 기여자 동의를 확인하기 위해 자주 사용됩니다.<br>\r\n  \r\n- Reviewed-by:<br>\r\n    Example: Reviewed-by: Reviewer Name <reviewer@example.com><br>\r\n    특정인이 커밋을 검토했음을 나타냅니다.<br>\r\n  \r\n- See also:<br>\r\n    Example: See also: #987<br>\r\n    관련 문제 또는 풀 요청에 대한 참조를 제공합니다.<br>\r\n\r\n- Related:<br>\r\n    Example: Related to: #654<br>\r\n    해당 커밋에 관련된 이슈번호 (아직 해결되지 않은 경우)입니다.<br>\r\n\r\n\r\n## 4. Git 커밋 메시지 자동화 방법\r\n### 4.1. 서버 훅: Git의 push rule 기능 사용하기\r\n> - Git 서버 후크는 특정 이벤트에 대한 응답으로 서버에서 실행되는 스크립트입니다. <br>\r\n> - 특히 'pre-receive' 후크는 업데이트가 저장소에 승인되기 전에 호출됩니다. Git의 푸시 규칙 기능을 활용하면 특정 커밋 메시지 규칙을 적용할 수 있습니다.<br>\r\n\r\n- 도구: Commitizen, Husky<br>\r\n- 위치: 이 도구는 개발자의 로컬 컴퓨터(클라이언트 측)에서 작동합니다.<br>\r\n- 목적: 개발자의 로컬 작업 흐름과 환경을 향상시키는 데 사용됩니다.<br>\r\n- 예: Commitizen은 개발자가 로컬 컴퓨터에서 표준화된 커밋 메시지를 생성하는 데 도움이 됩니다. Husky는 Git 후크를 로컬에서 관리하는 데 도움을 줍니다.<br>\r\n\r\n### 4.2. 클라이언트 훅: 푸시하기 전 미리 검사하기\r\n> - 클라이언트 후크는 개발자가 변경하는 로컬 시스템에서 실행됩니다. <br>\r\n> - 'pre-push' 후크는 'git push' 명령이 실행되기 전에 트리거되어 개발자가 사전 확인을 수행할 수 있도록 합니다.<br>\r\n\r\n- 훅: 예에는 'pre-receive', 'update', 'post-receive'이 포함됩니다.<br> \r\n- 위치: 이 후크는 Git 서버에 설치됩니다.<br>\r\n- 목적: 특정 Git 작업(예: 변경 사항 푸시)이 수행될 때 정책을 시행하고, 작업을 수행하거나, 서버에서 이벤트를 트리거하는 데 사용됩니다.<br>\r\n- 예: '사전 수신' 서버 측 후크는 커밋 메시지 규칙을 적용하거나 푸시를 수락하기 전에 특정 조건을 확인할 수 있습니다.<br>\r\n\r\n\r\n\r\n## 5. Git emojis 사용\r\n- Git emojis는 이모티콘을 사용하여 커밋 메시지를 시각적으로 표현하고 분류하는 방법입니다.<br>\r\n- https://gitmoji.dev/ 에서 참고하여 작성.<br>\r\n- 인텔리제이는 Gitmoji, VS CODE는 Gitmoji Plug-in 지원<br>\r\n- gitmoji-cli를 활용하여 Gitmoji를 터미널에서 바로 적용가능\r\n- 이모티콘은 추가 컨텍스트를 제공하기 위해 기존 커밋 메시지와 함께 사용되는 경우가 많습니다.<br>\r\n\r\n#### 예시\r\n````markdown\r\n   🚀: 새로운 기능\r\n   🐛: 버그 수정\r\n   📚: 문서 업데이트\r\n   ⚙️: 코드 리팩토링\r\n   🚨: 획기적인 변화\r\n````\r\n\r\n## 결론\r\nGit 커밋 메시지 규칙을 따르고 자동화를 활용함으로써 팀은 협업을 간소화하고 깨끗한 버전 기록을 유지하며 전체 프로젝트 문서를 향상시킬 수 있습니다.\r\n\r\n참고 문헌\r\n- https://velog.io/@msung99/Git-Commit-Message-Convension"},{"excerpt":"💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야…","fields":{"slug":"/critical-sections/"},"frontmatter":{"date":"January 11, 2024","title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n> 💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \r\n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 한다. \r\n동기화 도구에는 대표적으로 **뮤텍스(Mutex)**와 **세마포어(Semaphore)**가 있다. 이들은 모두 공유된 자원의 데이터를 여러 스레드/프로세스가 접근하는 것을 막는 역할을 함\r\n\r\n\r\n\r\n# 임계영역(**Critical Section**)\r\n\r\n\r\n> 💡 **임계 영역**이란 한 순간 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미한다. 임계 구역은 지정된 시간이 지난 후 종료된다.\r\n\r\n\r\n\r\n## 📌 임계 영역을 해결하기 위한 방법\r\n\r\n- 뮤텍스, 세마포어, 모니터 등이 있다.\r\n- 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.\r\n1. 상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음.\r\n2. 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨.\r\n3. 진행 : 임계 구역에 들어간 프로세스가 없는 상태에서, 들어가려고 하는 프로세스가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해주어야 한다.\r\n\r\n4. 융통성 : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 됨.\r\n\r\n## 특징\r\n\r\n- 커널 객체를 사용하지 않는다.\r\n- 서로 다른 프로세스간에 접근이 불가하다**.**\r\n- 내부적으로 인터락 함수를 사용하고 있다.\r\n- 커널 오브젝트를 사용하지 않기 때문에 핸들을 사용하지 않고, CRITICAL_SECTION 이라는 타입을 정의하여 사용한다.\r\n\r\n# 뮤텍스(mutex)\r\n\r\n> 💡 뮤텍스는 Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나)\r\n\r\n\r\n![img.png](img.png)\r\n\r\n\r\n## 과정\r\n\r\n- 1번 프로세스가 자원을 접근하기 위해 Key를점유한다.\r\n- 1번 프로세스는 키를 점유했기 때문에 공유 자원을 사용한다.\r\n- 2번 프로세스가 공유 자원을 사용하기를 원한다.\r\n- 2번 프로세스는 키를 점유하기 위해 대기한다.\r\n- 3번 프로세스 또한 공유 자원을 사용하기 위해 2번 프로세스 다음 순번으로 대기한다.\r\n- 1번 프로세스가 공유 자원을 다 사용하고 Key를 반환한다.\r\n- 2번 프로세스는 대기하고 있다가 반환된 Key를 점유하고 공유 자원을 사용한다.\r\n\r\n## 예시\r\n\r\n뮤텍스는 화장실이 하나 밖에 없는 식당과 비슷합니다. 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야 하며 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다고 가정합니다.\r\n\r\n![img_1.png](img_1.png)\r\n\r\n카운터에 열쇠가 없기 때문에 화장실에 사람이 있다는 뜻이며 화장실을 사용할 수 없습니다. 여자가 나올 때 까지 기다려야 합니다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n곧이어 다른 사람도 화장실에 가려고 카운터에 대기하고 있습니다. 앞사람이 화장실에서 나와 카운터에 키를 돌려놓았습니다. 이제 기다리던 사람들 중 맨 앞에 있던 사람이 키를 받아 화장실에 갈 수 있습니다.\r\n\r\n이것이 뮤텍스가 동작하는 방식입니다. 화장실을 이용하는 사람은 프로세스 혹은 쓰레드이며 화장실은 공유자원, 화장실 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트입니다. 즉, 뮤텍스는 Key에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있습니다.\r\n\r\n# 세마포어(Semaphore)\r\n\r\n\r\n> 💡 공유 리소스에 접근할 수 있는 최대 허용치 만큼 동시 사용자(쓰레드, 프로세스) 접근을 허용하게 한다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)\r\n\r\n\r\n![img_3.png](img_3.png)\r\n\r\n\r\n## 과정\r\n\r\n- 공유 자원에 대한 최대 허용치를 정의한다. 우선, 3으로 해보겠다.\r\n- 1번 프로세스가 공유 자원에 접근한다. 허용치는 2로 감소하였다.\r\n- 2번 프로세스가 공유 자원에 접근한다. 허용치는 1로 감소하였다.\r\n- 3번 프로세스가 공유 자원에 접근한다. 허용치는 0로 감소하였다.\r\n- 4번 프로세스가 공유 자원에 접근한다. 허용치가 0이므로 대기한다.\r\n- 2번 프로세스가 공유 자원을 다 사용하였다. 허용치는 1로 증가하였다.\r\n- 4번 프로세스는 대기 하다 허용치가 1로 증가되어 공유 자원에 접근한다. 허용치는 다시 0으로 감소하였다.\r\n\r\n## 예시\r\n\r\n세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑입니다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다고 가정합니다.\r\n![img_4.png](img_4.png)\r\n\r\n만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 하며 나올 때 빈 칸의 개수를 하나 더해줍니다.\r\n![img_5.png](img_5.png)\r\n\r\n모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1 혹은 양수로 바뀔 때까지 기다려야 합니다.\r\n\r\n이처럼 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성합니다. 세마포어도 아까와 똑같이 화장실이 공유자원이며 사람들이 쓰레드, 프로세스이다. 그리고 화장실 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드,프로세스의 개수를 나타냅니다.\r\n\r\n# 뮤텍스와 세마포어의 차이\r\n\r\n- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.\r\n- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그에 대한 책임을 가진다.\r\n- 세마포어는 동기화 대상이 여러개 일 때 사용하고, 뮤텍스는 동기화 대상이 오로지 하나 일 때 사용된다\r\n\r\n가장 큰 차이점은 동기화 대상의 개수 즉, 위에서 예시든 화장실의 갯수 입니다.\r\n\r\nMutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.\r\nMutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.\r\nMutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.\r\nSemaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다."},{"excerpt":"1. 교착상태(Dead Lock)란?  두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황 1.1 교착상태 발생 경우 Process1 이 Resource1 을 점유하고 있다. Process2 …","fields":{"slug":"/deadlock/"},"frontmatter":{"date":"January 09, 2024","title":"🤔 교착상태 vs 기아상태 vs 경합상태","tags":["OS"]},"rawMarkdownBody":"\r\n##  1. 교착상태(Dead Lock)란?\r\n\r\n![img.png](img.png)\r\n\r\n> - 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태\r\n> - 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황\r\n\r\n\r\n### 1.1 교착상태 발생 경우\r\n\r\n\r\n\r\n- Process1 이 Resource1 을 점유하고 있다.\r\n- Process2 가 Resource2 를 점유하고 있다.\r\n- 여기까지는 괜찮다.\r\n- Process1 이 Resource2의 자원을 사용하기 위해 기다린다.\r\n- Process2 가 Resource1의 자원을 사용하기 위해 기다린다.\r\n- 이렇게 자원 해제가 안되어있고 무한정 기다리고 있는 상태이다.\r\n\r\n### 1.2 교착상태 발생 조건\r\n\r\n![img_1.png](img_1.png)\r\n\r\n- **상호 배제 :** 하나의 프로세스가 자원을 사용중일 때 다른 프로세스는 그를 사용할 수 없다.\r\n- **점유 대기 :** 최소 하나의 자원을 점유하고 있으면서 다른 프로세스가 사용중인 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다.\r\n- **비선점 :** 다른 프로세스가 자원을 사용중인 경우 그 사용이 끝날 때 까지 강제로 뺏을 수 없다.\r\n- **순환 대기 :** 프로세스의 집합에서 순환형태로 자원을 대기하고 있어야 한다.\r\n\r\n### 1.3 교착상태 해결 방법\r\n\r\n#### **1.3.1 교착 상태 예방 및 회피**\r\n\r\n\r\n> 💡 교착 상태가 되지 않도록 하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법이다.\r\n\r\n\r\n\r\n**예방**\r\n\r\n교착상태의 발생 조건 중 하나를 제거하면서 예방.\r\n\r\n- **상호 배제 부정 :** 여러 프로세스가 공유 자원 사용\r\n- **점유 대기 부정 :** 프로세스 실행 전 모든 자원 할당\r\n- **비선점 부정 :** 점유중인 자원을 다른 프로세스가 요구하는 경우 그를 반납\r\n- **순환 대기 부정 :** 자원에 고유 번호를 할당한 후 순서대로 자원 요구\r\n\r\n**회피**\r\n\r\n**은행원 알고리즘**\r\n\r\n- 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 미리 검사하여 교착 상태를 회피한다. 안정 상태인 경우만 자원을 할당하고 그렇지 않은 경우 다른 프로세스들의 자원 해지시 까지 대기한다.\r\n- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법으로 병렬 수행 프로세스 간의 교착 상태를 방지하기 위한 방법이다. 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후에도 안정한 상태인지 사전에 검사하여 교착 상태를 회피하는 기법이다. 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장한다.\r\n\r\n#### **1.3.2 교착 상태 탐지(발견) 및 회복**\r\n\r\n\r\n> - 교착 상태가 발생했는지 점검하고 교착 상태에 있는 프로세스와 자원을 발견하고 교착 상태를 일으킨 프로세스를 종료하거나 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.\r\n> - **교착 상태 탐지(발견)**에는 **교착 상태 발견 알고리즘**과 **자원 할당 그래프** 등을 사용할 수 있다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n**교착 상태 회복**\r\n\r\n교착 상태 회복 기법에는 프로세스 종료, 자원 선점 방법이 있다.\r\n\r\n- **프로세스 종료 :** 교착 상태에 있는 프로세스를 종료하는 방법으로 교착 상태에 있는 모든 프로세스를 종료하는 방법과 프로세스들을 하나씩 종료하면서 교착 상태를 해결하는 방법이 있다.\r\n- **자원 선점 :** 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당하여 해당 프로세스를 일시적으로 멈추는 방법이다. 우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점한다.\r\n\r\n#### **1.3.3 교착 상태 무시**\r\n\r\n대부분 교착 상태가 잘 발생하지 않기에 교착 상태 예방, 회피, 탐지, 복구는 비용이 많이 든다. 또 예방 또는 회피를 프로그래밍해서 넣으면 성능이 큰 영향을 미칠 수 있다. 때문에 교착 상태의 발생 확률이 비교적 낮으면 별 다른 조치를 취하지 않는다.\r\n\r\n## 2. 기아상태(Starvation)란?\r\n\r\n> 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태를 말함 <br>\r\n> 여러 프로세스가 자원을 점유 할때 특정 프로세스에게 자원이 아예 할당 안되는 경우\r\n\r\n\r\n### 2.1 기아상태 해결 방법\r\n\r\n- 프로세스 우선순위 수시 변경을 통해 각 프로세스 높은 우선순위를 가지도록 기회 부여\r\n- 오래 기다린 프로세스의 우선순위 높이기\r\n- 우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용\r\n\r\n## 3. 경합 조건란?\r\n\r\n\r\n> 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 `공유자원에 동시에 접근`하여 결과값에 영향을 줄 수 있는 상태\r\n\r\n\r\n\r\n### 3.1 경합 조건의 예시\r\n\r\n아들은 은행에 10000원의 잔고가 있었고, 현금 인출기를 통해 잔고 10000원을 출금하고 있다. 그 사이 엄마는 아들에게 용돈을 5000원 입금 해주었다. 그렇다면 잔고는 얼마일까?<br>\r\n아들은 10000원을 인출했기 때문에 잔고는 0원이 되고, 이후 엄마가 5000원을 입금해주신 덕분에 잔고는 5000원이 되리라 기대할 것이다.<br>\r\n하지만 경쟁상태일 때<br>\r\n동시에 출금과 입금이 이루어지는 경우<br>\r\n아들의 입장 : 현재잔고 10000원 – 10000원 출금 = 기대잔고 0원<br>\r\n엄마의 입장 : 현재잔고 10000원 – 5000원 입금 = 기대잔고 15000원<br>\r\n\r\n이처럼 경쟁 조건는 `공유 데이터(잔고)에 최종값을 보장할 수 없는 상황`을 말한다.\r\n\r\n이 경쟁 조건로 생기는 영역이`임계구역(Critical Section)`이다.\r\n\r\n- **정의:** 경쟁 조건은 시스템의 동작이 스레드가 실행되도록 예약된 순서와 같은 이벤트의 상대적 타이밍에 따라 달라질 때 발생\r\n- **원인:** 여러 스레드나 프로세스의 실행 순서가 비결정적이기 때문에 발생\r\n\r\n#### 임계구역(critical section)\r\n\r\n공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역이다.<br>\r\n이 임계구역을 해결하는 방법이 `동기화 메커니즘(ex. 세마포어)`을 사용하는 것이다.<br>\r\n동기화 메커니즘의 근간이 바로 `락(Lock)`을 사용하는 것이다.<br>\r\n\r\n경쟁 조건와 교착상태에서는 다양한 동기화 기술과 알고리즘이 사용됨\r\n\r\n## 4. 기타\r\n\r\n### 4.1 **교착 상태 vs 기아 상태**\r\n\r\n교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태이다. 즉 교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생하고 기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다.\r\n\r\n- **교착상태** : 여러 프로세스가 동일 자원 점유를 요청할 때 발생\r\n- **기아상태** : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생\r\n\r\n### 4.2 교착 상태 vs 경쟁 조건\r\n\r\n교착 상태와 경쟁 조건은 모두 동시성 문제인 반면, 교착 상태는 리소스에 대한 순환 종속성을 포함하여 완전한 정지를 초래하는 반면, 경쟁 조건은 예측할 수 없는 작업 인터리빙과 관련되어 동시 리소스 액세스로 인해 예상치 못한 결과를 초래\r\n\r\n- **교착 상태:** 교착 상태는 두 개 이상의 프로세스가 서로의 리소스 해제를 기다리고 있기 때문에 진행할 수 없는 상황. 이로 인해 순환 대기 시나리오가 발생하고 관련 프로세스가 무기한 차단됨\r\n- **경쟁 조건:** 경쟁 조건은 시스템의 동작이 이벤트의 상대적인 타이밍, 특히 스레드나 프로세스가 실행되도록 예약된 순서에 따라 달라질 때 발생함. 비결정적인 실행 순서로 인해 예측할 수 없는 결과가 발생함\r\n\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}