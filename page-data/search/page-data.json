{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"String 재사용(Interning) 해당 코드를 실행하면 객체가 3개가 아니라 2개가 만들어진다. 왜 2개일까? 이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모리 구조상에서 차이가 발생한다. String은 다른 객체들에 비해 광범위하고, 빈번하게 사용되므로 String을 사용할 때마다 객체를 생성하는 방식으로 사용하게 된다면, 새로운 객체를 계…","fields":{"slug":"/stringPool/"},"frontmatter":{"date":"January 13, 2024","title":"Java String VS new String()","tags":["JAVA"]},"rawMarkdownBody":"\r\n## String 재사용(Interning)\r\n\r\n```java\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"Hi\");\r\n        String str2 = \"Hi\";\r\n        String str3 = \"Hi\";\r\n    }\r\n}\r\n```\r\n\r\n해당 코드를 실행하면 **객체가 3개가 아니라 2개**가 만들어진다.\r\n\r\n왜 2개일까?\r\n\r\n이 두가지의 문자열 생성 방식은 JVM이 관리하는 메모리 구조상에서 차이가 발생한다.\r\n\r\nString은 다른 객체들에 비해 광범위하고, 빈번하게 사용되므로 String을 사용할 때마다 객체를 생성하는 방식으로 사용하게 된다면, 새로운 객체를 계속 만들어내는 것이기 때문에 **메모리 관리 측면에서 비효율적**이다.\r\n이러한 String을 효율적으로 관리하기 위해, Heap 메모리영역 속에 <span style=\"color:blue\"> **String Constant Pool** </span>을 만들었다.\r\n이곳에는 생성된 문자열의 값을 보관하고 있으며, 리터럴””로 생성된 같은 값을 가지는 객체는 같은 레퍼런스(참조값, 주소)를 가지게 된다.\r\n\r\n![img.png](img.png)\r\n\r\n위 코드에서는 new String 연산자로 생성된 객체(Heap 메모리 영역에 저장), 그리고 리터럴로 생성된 객체(String Pool에 저장), 총 2개의 객체가 생성되는 것이다.\r\n\r\nJava에서 String은 불변(immutable) 객체입니다. 이 덕분에 JVM은 String Constant Pool에 각 문자열 리터럴의 복사본을 하나만 저장하여, 문자열에 할당되는 메모리 양을 최적화할 수 있습니다.\r\n그리고 해당 과정을 재사용(Interning)이라고 합니다.\r\n<br>\r\nString 변수를 만들고 값을 할당할 때 JVM은 String Constant Pool에서 동일한 값의 String을 검색합니다.\r\n만약 동일한 값을 가진 String이 발견된다면 자바 컴파일러는 추가 메모리를 할당하는 것이 아니라, 단순히 해당 String의 주소에 대한 참조를 반환합니다.\r\n<br>\r\n만약 존재하지 않는다면 해당 값은 String Constant Pool에 추가되고(인턴) 해당 값에 대한 참조가 반환됩니다.\r\n\r\n## 가비지 컬렉터\r\n\r\nJava 7 이전에는 JVM이 고정된 크기를 가진 PermGen이라는 공간에 String Constant Pool을 배치했습니다.\r\nPermGen이라는 공간은 크기가 고정되어 있어서 런타임 시 확장이 불가능하며 garbage collection에 적합하지 않습니다.\r\n\r\nPermGen에서 너무 많은 문자열을 재사용(interning)하는 경우 JVM에서 OutOfMemory 오류가 발생할 수 있습니다.\r\n<br>\r\nJava7 이후부터 String Constant Pool은 JVM에 의해 Garbage Colleted되는 Heap 메모리 영역에 배치되었습니다.\r\nHeap 영역에 배치되는 것의 장점은, 참조되지 않은 String은 GC에 의해 String Constant Pool에서 제거되어 메모리가 해제되기 때문에 OutOfMemory 오류의 위험이 감소한다는 점입니다.\r\n(참고로 PermGen은 Java8부터 Metaspace로 대체되었습니다.)\r\n\r\n## 참고 - Compact Strings\r\n\r\nJava 8버전까지는 String은 내부적으로 UTF-16으로 인코딩된 문자 배열인 char[]로 표현되어 대부분의 언어가 1바이트로 표현이 가능했음에도 불구하고 2바이트의 메모리를 사용했습니다.\r\n그러나 Java 9에서는 Compact Strings를 제공함으로써, 저장된 문자열의 내용에 따라 char[]과 byte[] 사이에서 적절한 인코딩을 선택하여 사용합니다.\r\n따라서 Heap 메모리 사용양이 상당히 줄어들었고, JVM에서 GC 오버헤드가 줄어들었습니다.\r\n\r\n## 왜 String Constant Pool은 Heap 영역에 존재할까?\r\n\r\n자바에서는 객체를 생성하거나 변수를 선언할 때마다 메모리에 저장됩니다.\r\n자바에서 메모리는 Stack과 Heap영역, 이렇게 두 가지 영역으로 나눕니다.\r\nStack 영역과 Heap 영역은 서로 저장하는 데이터가 다르며, 데이터를 저장하는 방법과 데이터에 접근하는 방식이 다릅니다.\r\n\r\n위에서도 배웠지만 String 리터럴(literal)을 선언할 때, JVM은 해당 String 객체를 이곳(String Constant Pool)에 저장하고, Stack 메모리 영역에서 이를 참조합니다.\r\n<br>\r\n(추가로 지금부터 설명하는 String 생성은 특별한 언급이 없는 이상 모두 리터럴로 생성되는 String입니다.)\r\n<br>\r\n<br>\r\n각각의 String 객체를 메모리에 생성하기 전에, JVM은 메모리의 오버헤드를 줄이기 위해 몇가지 과정을 수행합니다.\r\n<br>\r\nString constant pool은 HashMap으로 구현되어 있습니다. Hashmap 각각의 bucket(저장공간)은 같은 해시코드를 가진 String list를 저장합니다. (옛날 버전의 자바에서는 String constant pool의 저장공간은 고정된 크기였으며, 종종 \"객체 Heap을 저장하기 위한 충반한 공간이 없습니다\"라는 오류를 발생시켰습니다.)\r\n<br>\r\n<br>\r\n시스템이 클래스를 로드할 때(클래스 로더에 의해 로드될 때) 모든 클래스의 문자열 리터럴은 application-level pool(String constant pool)로 이동하는데, 이는 서로 다른 클래스의 String 리터럴들은 동일한 객체여야 하기 때문입니다.\r\n그리고 현재 상황(String 리터럴들이 String constant pool로 이동한 상황)에서, pool속에 들어있는 데이터들은 어떠한 종속성 없이도 각각의 Class들에서 사용이 가능해야 합니다.\r\n<br>\r\n일반적으로 Stack 메모리 영역에는 수명이 짧은 데이터들이 저장됩니다. 지역변수, (Heap에 저장된 실제 객체의 주소값을 참조하는) 참조변수, 그리고 실행중인 메소드들이 Stack 메모리 영역에 저장되는 데이터들입니다.\r\n<br>\r\nHeap 메모리 영역은 동적인 메모리 할당을 허용하며 런타임 시 Java의 객체 및 JRE 클래스를 저장합니다.\r\n\r\n참고\r\n\r\n- https://ttl-blog.tistory.com/388\r\n- https://coding-factory.tistory.com/536"},{"excerpt":"💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야…","fields":{"slug":"/criticalSections/"},"frontmatter":{"date":"January 11, 2024","title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n> 💡 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 임계영역(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) 문제가 발생할 수 있다. \r\n이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 한다. \r\n동기화 도구에는 대표적으로 **뮤텍스(Mutex)**와 **세마포어(Semaphore)**가 있다. 이들은 모두 공유된 자원의 데이터를 여러 스레드/프로세스가 접근하는 것을 막는 역할을 함\r\n\r\n\r\n\r\n# 임계영역(**Critical Section**)\r\n\r\n\r\n> 💡 **임계 영역**이란 한 순간 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미한다. 임계 구역은 지정된 시간이 지난 후 종료된다.\r\n\r\n\r\n\r\n## 📌 임계 영역을 해결하기 위한 방법\r\n\r\n- 뮤텍스, 세마포어, 모니터 등이 있다.\r\n- 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.\r\n1. 상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음.\r\n2. 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨.\r\n3. 진행 : 임계 구역에 들어간 프로세스가 없는 상태에서, 들어가려고 하는 프로세스가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해주어야 한다.\r\n\r\n4. 융통성 : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 됨.\r\n\r\n## 특징\r\n\r\n- 커널 객체를 사용하지 않는다.\r\n- 서로 다른 프로세스간에 접근이 불가하다**.**\r\n- 내부적으로 인터락 함수를 사용하고 있다.\r\n- 커널 오브젝트를 사용하지 않기 때문에 핸들을 사용하지 않고, CRITICAL_SECTION 이라는 타입을 정의하여 사용한다.\r\n\r\n# 뮤텍스(mutex)\r\n\r\n> 💡 뮤텍스는 Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나)\r\n\r\n\r\n![img.png](img.png)\r\n\r\n\r\n## 과정\r\n\r\n- 1번 프로세스가 자원을 접근하기 위해 Key를점유한다.\r\n- 1번 프로세스는 키를 점유했기 때문에 공유 자원을 사용한다.\r\n- 2번 프로세스가 공유 자원을 사용하기를 원한다.\r\n- 2번 프로세스는 키를 점유하기 위해 대기한다.\r\n- 3번 프로세스 또한 공유 자원을 사용하기 위해 2번 프로세스 다음 순번으로 대기한다.\r\n- 1번 프로세스가 공유 자원을 다 사용하고 Key를 반환한다.\r\n- 2번 프로세스는 대기하고 있다가 반환된 Key를 점유하고 공유 자원을 사용한다.\r\n\r\n## 예시\r\n\r\n뮤텍스는 화장실이 하나 밖에 없는 식당과 비슷합니다. 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야 하며 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다고 가정합니다.\r\n\r\n![img_1.png](img_1.png)\r\n\r\n카운터에 열쇠가 없기 때문에 화장실에 사람이 있다는 뜻이며 화장실을 사용할 수 없습니다. 여자가 나올 때 까지 기다려야 합니다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n곧이어 다른 사람도 화장실에 가려고 카운터에 대기하고 있습니다. 앞사람이 화장실에서 나와 카운터에 키를 돌려놓았습니다. 이제 기다리던 사람들 중 맨 앞에 있던 사람이 키를 받아 화장실에 갈 수 있습니다.\r\n\r\n이것이 뮤텍스가 동작하는 방식입니다. 화장실을 이용하는 사람은 프로세스 혹은 쓰레드이며 화장실은 공유자원, 화장실 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트입니다. 즉, 뮤텍스는 Key에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있습니다.\r\n\r\n# 세마포어(Semaphore)\r\n\r\n\r\n> 💡 공유 리소스에 접근할 수 있는 최대 허용치 만큼 동시 사용자(쓰레드, 프로세스) 접근을 허용하게 한다.\r\n\r\n: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)\r\n\r\n\r\n![img_3.png](img_3.png)\r\n\r\n\r\n## 과정\r\n\r\n- 공유 자원에 대한 최대 허용치를 정의한다. 우선, 3으로 해보겠다.\r\n- 1번 프로세스가 공유 자원에 접근한다. 허용치는 2로 감소하였다.\r\n- 2번 프로세스가 공유 자원에 접근한다. 허용치는 1로 감소하였다.\r\n- 3번 프로세스가 공유 자원에 접근한다. 허용치는 0로 감소하였다.\r\n- 4번 프로세스가 공유 자원에 접근한다. 허용치가 0이므로 대기한다.\r\n- 2번 프로세스가 공유 자원을 다 사용하였다. 허용치는 1로 증가하였다.\r\n- 4번 프로세스는 대기 하다 허용치가 1로 증가되어 공유 자원에 접근한다. 허용치는 다시 0으로 감소하였다.\r\n\r\n## 예시\r\n\r\n세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑입니다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다고 가정합니다.\r\n![img_4.png](img_4.png)\r\n\r\n만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 하며 나올 때 빈 칸의 개수를 하나 더해줍니다.\r\n![img_5.png](img_5.png)\r\n\r\n모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1 혹은 양수로 바뀔 때까지 기다려야 합니다.\r\n\r\n이처럼 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성합니다. 세마포어도 아까와 똑같이 화장실이 공유자원이며 사람들이 쓰레드, 프로세스이다. 그리고 화장실 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드,프로세스의 개수를 나타냅니다.\r\n\r\n# 뮤텍스와 세마포어의 차이\r\n\r\n- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.\r\n- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그에 대한 책임을 가진다.\r\n- 세마포어는 동기화 대상이 여러개 일 때 사용하고, 뮤텍스는 동기화 대상이 오로지 하나 일 때 사용된다\r\n\r\n가장 큰 차이점은 동기화 대상의 개수 즉, 위에서 예시든 화장실의 갯수 입니다.\r\n\r\nMutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.\r\nMutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.\r\nMutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.\r\nSemaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다."},{"excerpt":"1. 교착상태(Dead Lock)란?  두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황 1.1 교착상태 발생 경우 Process1 이 Resource1 을 점유하고 있다. Process2 …","fields":{"slug":"/deadlock/"},"frontmatter":{"date":"January 09, 2024","title":"🤔 교착상태 vs 기아상태 vs 경합상태","tags":["OS"]},"rawMarkdownBody":"\r\n##  1. 교착상태(Dead Lock)란?\r\n\r\n![img.png](img.png)\r\n\r\n> - 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태\r\n> - 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황\r\n\r\n\r\n### 1.1 교착상태 발생 경우\r\n\r\n\r\n\r\n- Process1 이 Resource1 을 점유하고 있다.\r\n- Process2 가 Resource2 를 점유하고 있다.\r\n- 여기까지는 괜찮다.\r\n- Process1 이 Resource2의 자원을 사용하기 위해 기다린다.\r\n- Process2 가 Resource1의 자원을 사용하기 위해 기다린다.\r\n- 이렇게 자원 해제가 안되어있고 무한정 기다리고 있는 상태이다.\r\n\r\n### 1.2 교착상태 발생 조건\r\n\r\n![img_1.png](img_1.png)\r\n\r\n- **상호 배제 :** 하나의 프로세스가 자원을 사용중일 때 다른 프로세스는 그를 사용할 수 없다.\r\n- **점유 대기 :** 최소 하나의 자원을 점유하고 있으면서 다른 프로세스가 사용중인 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다.\r\n- **비선점 :** 다른 프로세스가 자원을 사용중인 경우 그 사용이 끝날 때 까지 강제로 뺏을 수 없다.\r\n- **순환 대기 :** 프로세스의 집합에서 순환형태로 자원을 대기하고 있어야 한다.\r\n\r\n### 1.3 교착상태 해결 방법\r\n\r\n#### **1.3.1 교착 상태 예방 및 회피**\r\n\r\n\r\n> 💡 교착 상태가 되지 않도록 하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법이다.\r\n\r\n\r\n\r\n**예방**\r\n\r\n교착상태의 발생 조건 중 하나를 제거하면서 예방.\r\n\r\n- **상호 배제 부정 :** 여러 프로세스가 공유 자원 사용\r\n- **점유 대기 부정 :** 프로세스 실행 전 모든 자원 할당\r\n- **비선점 부정 :** 점유중인 자원을 다른 프로세스가 요구하는 경우 그를 반납\r\n- **순환 대기 부정 :** 자원에 고유 번호를 할당한 후 순서대로 자원 요구\r\n\r\n**회피**\r\n\r\n**은행원 알고리즘**\r\n\r\n- 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 미리 검사하여 교착 상태를 회피한다. 안정 상태인 경우만 자원을 할당하고 그렇지 않은 경우 다른 프로세스들의 자원 해지시 까지 대기한다.\r\n- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법으로 병렬 수행 프로세스 간의 교착 상태를 방지하기 위한 방법이다. 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후에도 안정한 상태인지 사전에 검사하여 교착 상태를 회피하는 기법이다. 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장한다.\r\n\r\n#### **1.3.2 교착 상태 탐지(발견) 및 회복**\r\n\r\n\r\n> - 교착 상태가 발생했는지 점검하고 교착 상태에 있는 프로세스와 자원을 발견하고 교착 상태를 일으킨 프로세스를 종료하거나 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.\r\n> - **교착 상태 탐지(발견)**에는 **교착 상태 발견 알고리즘**과 **자원 할당 그래프** 등을 사용할 수 있다.\r\n\r\n![img_2.png](img_2.png)\r\n\r\n**교착 상태 회복**\r\n\r\n교착 상태 회복 기법에는 프로세스 종료, 자원 선점 방법이 있다.\r\n\r\n- **프로세스 종료 :** 교착 상태에 있는 프로세스를 종료하는 방법으로 교착 상태에 있는 모든 프로세스를 종료하는 방법과 프로세스들을 하나씩 종료하면서 교착 상태를 해결하는 방법이 있다.\r\n- **자원 선점 :** 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당하여 해당 프로세스를 일시적으로 멈추는 방법이다. 우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점한다.\r\n\r\n#### **1.3.3 교착 상태 무시**\r\n\r\n대부분 교착 상태가 잘 발생하지 않기에 교착 상태 예방, 회피, 탐지, 복구는 비용이 많이 든다. 또 예방 또는 회피를 프로그래밍해서 넣으면 성능이 큰 영향을 미칠 수 있다. 때문에 교착 상태의 발생 확률이 비교적 낮으면 별 다른 조치를 취하지 않는다.\r\n\r\n## 2. 기아상태(Starvation)란?\r\n\r\n> 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태를 말함 <br>\r\n> 여러 프로세스가 자원을 점유 할때 특정 프로세스에게 자원이 아예 할당 안되는 경우\r\n\r\n\r\n### 2.1 기아상태 해결 방법\r\n\r\n- 프로세스 우선순위 수시 변경을 통해 각 프로세스 높은 우선순위를 가지도록 기회 부여\r\n- 오래 기다린 프로세스의 우선순위 높이기\r\n- 우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용\r\n\r\n## 3. 경합 조건란?\r\n\r\n\r\n> 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 `공유자원에 동시에 접근`하여 결과값에 영향을 줄 수 있는 상태\r\n\r\n\r\n\r\n### 3.1 경합 조건의 예시\r\n\r\n아들은 은행에 10000원의 잔고가 있었고, 현금 인출기를 통해 잔고 10000원을 출금하고 있다. 그 사이 엄마는 아들에게 용돈을 5000원 입금 해주었다. 그렇다면 잔고는 얼마일까?<br>\r\n아들은 10000원을 인출했기 때문에 잔고는 0원이 되고, 이후 엄마가 5000원을 입금해주신 덕분에 잔고는 5000원이 되리라 기대할 것이다.<br>\r\n하지만 경쟁상태일 때<br>\r\n동시에 출금과 입금이 이루어지는 경우<br>\r\n아들의 입장 : 현재잔고 10000원 – 10000원 출금 = 기대잔고 0원<br>\r\n엄마의 입장 : 현재잔고 10000원 – 5000원 입금 = 기대잔고 15000원<br>\r\n\r\n이처럼 경쟁 조건는 `공유 데이터(잔고)에 최종값을 보장할 수 없는 상황`을 말한다.\r\n\r\n이 경쟁 조건로 생기는 영역이`임계구역(Critical Section)`이다.\r\n\r\n- **정의:** 경쟁 조건은 시스템의 동작이 스레드가 실행되도록 예약된 순서와 같은 이벤트의 상대적 타이밍에 따라 달라질 때 발생\r\n- **원인:** 여러 스레드나 프로세스의 실행 순서가 비결정적이기 때문에 발생\r\n\r\n#### 임계구역(critical section)\r\n\r\n공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역이다.<br>\r\n이 임계구역을 해결하는 방법이 `동기화 메커니즘(ex. 세마포어)`을 사용하는 것이다.<br>\r\n동기화 메커니즘의 근간이 바로 `락(Lock)`을 사용하는 것이다.<br>\r\n\r\n경쟁 조건와 교착상태에서는 다양한 동기화 기술과 알고리즘이 사용됨\r\n\r\n## 4. 기타\r\n\r\n### 4.1 **교착 상태 vs 기아 상태**\r\n\r\n교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태이다. 즉 교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생하고 기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다.\r\n\r\n- **교착상태** : 여러 프로세스가 동일 자원 점유를 요청할 때 발생\r\n- **기아상태** : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생\r\n\r\n### 4.2 교착 상태 vs 경쟁 조건\r\n\r\n교착 상태와 경쟁 조건은 모두 동시성 문제인 반면, 교착 상태는 리소스에 대한 순환 종속성을 포함하여 완전한 정지를 초래하는 반면, 경쟁 조건은 예측할 수 없는 작업 인터리빙과 관련되어 동시 리소스 액세스로 인해 예상치 못한 결과를 초래\r\n\r\n- **교착 상태:** 교착 상태는 두 개 이상의 프로세스가 서로의 리소스 해제를 기다리고 있기 때문에 진행할 수 없는 상황. 이로 인해 순환 대기 시나리오가 발생하고 관련 프로세스가 무기한 차단됨\r\n- **경쟁 조건:** 경쟁 조건은 시스템의 동작이 이벤트의 상대적인 타이밍, 특히 스레드나 프로세스가 실행되도록 예약된 순서에 따라 달라질 때 발생함. 비결정적인 실행 순서로 인해 예측할 수 없는 결과가 발생함\r\n\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}