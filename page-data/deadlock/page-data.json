{"componentChunkName":"component---src-templates-post-jsx","path":"/deadlock/","result":{"data":{"site":{"siteMetadata":{"title":"east-woo"}},"markdownRemark":{"id":"4e9d052d-d623-5622-a4ef-9748723c1861","excerpt":"1. 교착상태(Dead Lock)란?  두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태 둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황 1.1 교착상태 발생 경우 Process1 이 Resource1 을 점유하고 있다. Process2 …","html":"<h2>1. 교착상태(Dead Lock)란?</h2>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/1c05c5694c4ca7750b99791cf01224a9/80132/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 70.58823529411764%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACNklEQVQ4y41U247aQAzN/39MX/qIELRCQLcEVlxDFgKEe8ISck+4nR4HskJ0t6qlSWbssefYxzPKKAwwTiIYacJ/jLcohE7dKI4w9D1onovabIqSPkRjvcSA65s95N6AfnG21+BoUK/M4hip58Far+Hu98DlApEkDBEHARKOeqWCcrGIYb8P/3DIbOckAc5nOLsdIu4B4xRXSygtfvrdLtqdDkbjMd5GI9i2jYgbrrjJ8XSCT6czA4iceais3wnAmEygtloY9nooLBdQJkzRcxy0222YpgmH8yiKMsfr9ZqNR3lcxzx0R4RdBjM0Db+JnAGjjw0Xnuy67l+OeeBc9zgXAOnxmM1fAv+GMJcjDZZlfYrmK5SCMCTSLKCQMiE7Uly12USpVEKj0UCPKSRS9C+QikhZyuUyCoUCqrUa+q+vqLqHe0Cmqut6FqxPJqfTKdI0/WdAyWY2m6FFQoTI/XaLOttMMQgzl4DMRQ81fa7Z4zoXqeHpzn6WshGGH61wYnvspRefgnw2cpQeeziXX/4TKXltwjDE/4gEE4QHdsaVJVJ505Sp9BKZ7Q0GWG02WK5W2Fo2PKYv7ZBwOHSYL5eZo2Qiuj0DmfM5uqy5xvqbxgTfdQ2KKaQwVZ3MDtjcc8O491CKE5EmRNFRVZTJpkZ7yrRELz5kDuZ4hC6JcRYLVKwNlA4L2eAlLyzm+NZp4yeVTbno1Kl8AJp8OKqHfWavvNt8APxML3ax1b0DfthbvPBfpu4PgxgpXiumAZcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img.png' title='img.png' src='/static/1c05c5694c4ca7750b99791cf01224a9/ca1dc/img.png' srcset='/static/1c05c5694c4ca7750b99791cf01224a9/e7570/img.png 170w,\n/static/1c05c5694c4ca7750b99791cf01224a9/f46e7/img.png 340w,\n/static/1c05c5694c4ca7750b99791cf01224a9/ca1dc/img.png 680w,\n/static/1c05c5694c4ca7750b99791cf01224a9/02d09/img.png 1020w,\n/static/1c05c5694c4ca7750b99791cf01224a9/80132/img.png 1294w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img.png</figcaption>\n  </figure></p>\n<blockquote>\n<ul>\n<li>두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태</li>\n<li>둘 이상의 프로세스가 각각의 프로세스가 점유 하고 있는 자원을 서로 기다릴때 무한대기에 빠지는 상황</li>\n</ul>\n</blockquote>\n<h3>1.1 교착상태 발생 경우</h3>\n<ul>\n<li>Process1 이 Resource1 을 점유하고 있다.</li>\n<li>Process2 가 Resource2 를 점유하고 있다.</li>\n<li>여기까지는 괜찮다.</li>\n<li>Process1 이 Resource2의 자원을 사용하기 위해 기다린다.</li>\n<li>Process2 가 Resource1의 자원을 사용하기 위해 기다린다.</li>\n<li>이렇게 자원 해제가 안되어있고 무한정 기다리고 있는 상태이다.</li>\n</ul>\n<h3>1.2 교착상태 발생 조건</h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/b8d403bf79a768e4008093bce7e579b8/7d136/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 58.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/ElEQVQoz32T627aQBBG/f6v06YpjRopjdIfrWhCQwjYEAzGGMfY+I69vpyuzSXQRl1p5PXom/k0u2cV9quua/5eTa5JlyKUEbX7qqre1R2WsivaJbIsI0kS0jRF5PlOkVuQdCGWUbzudVviOG61QogT87pp+OZg2zaapjEej5lOp7jrNfpzB/3pA4vRJ176FxiGga7rDIej9rvZ+GfTKHLb/FIWQjqnBIGP565Zy2ZJuiVxB0TmV2Lrmsjp4wchruvieS6+v6EQOXVVcuij2L7AjkAzNtx1R4zNEC/MTk6o2o3dBG9n1WjURUBPXWKsMyy/4jUoUJ4XW7qaz+Ms5WmR8WjkLDdFW3wYoz74H4+nxvQK7l8i+vOU33rMwzRmtMxQBvOYzt2Az7d9Lm4euLmfYZ01PLY7GjT7xvT654Qv35+4vH1sY7hIUCa2YOyAahXSLWFklTjhDo1KVlctKkUbpxf4GpRtXW8a8mzK8VcVEztHyURJkpUE0ZbZwkI3LDx5c0LssakDicyDjJ4EMmhTDSqut5H6FYOhhuP6bEVN00s5BbQqS+IoxHEcTNNs8VF7H1lNOljjS+zptxat+XzeapI4OsX7X7BXKxtVVVsGPc8jzwXe8gfe7ApvfkWw+kVRVFjW8shqY3AG9v+e3v6pQKrtos7fVZzW/gFWa5XEPmkQYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img_1.png' title='img_1.png' src='/static/b8d403bf79a768e4008093bce7e579b8/ca1dc/img_1.png' srcset='/static/b8d403bf79a768e4008093bce7e579b8/e7570/img_1.png 170w,\n/static/b8d403bf79a768e4008093bce7e579b8/f46e7/img_1.png 340w,\n/static/b8d403bf79a768e4008093bce7e579b8/ca1dc/img_1.png 680w,\n/static/b8d403bf79a768e4008093bce7e579b8/02d09/img_1.png 1020w,\n/static/b8d403bf79a768e4008093bce7e579b8/9d567/img_1.png 1360w,\n/static/b8d403bf79a768e4008093bce7e579b8/7d136/img_1.png 1445w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img_1.png</figcaption>\n  </figure></p>\n<ul>\n<li><strong>상호 배제 :</strong> 하나의 프로세스가 자원을 사용중일 때 다른 프로세스는 그를 사용할 수 없다.</li>\n<li><strong>점유 대기 :</strong> 최소 하나의 자원을 점유하고 있으면서 다른 프로세스가 사용중인 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다.</li>\n<li><strong>비선점 :</strong> 다른 프로세스가 자원을 사용중인 경우 그 사용이 끝날 때 까지 강제로 뺏을 수 없다.</li>\n<li><strong>순환 대기 :</strong> 프로세스의 집합에서 순환형태로 자원을 대기하고 있어야 한다.</li>\n</ul>\n<h3>1.3 교착상태 해결 방법</h3>\n<h4><strong>1.3.1 교착 상태 예방 및 회피</strong></h4>\n<blockquote>\n<p>💡 교착 상태가 되지 않도록 하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법이다.</p>\n</blockquote>\n<p><strong>예방</strong></p>\n<p>교착상태의 발생 조건 중 하나를 제거하면서 예방.</p>\n<ul>\n<li><strong>상호 배제 부정 :</strong> 여러 프로세스가 공유 자원 사용</li>\n<li><strong>점유 대기 부정 :</strong> 프로세스 실행 전 모든 자원 할당</li>\n<li><strong>비선점 부정 :</strong> 점유중인 자원을 다른 프로세스가 요구하는 경우 그를 반납</li>\n<li><strong>순환 대기 부정 :</strong> 자원에 고유 번호를 할당한 후 순서대로 자원 요구</li>\n</ul>\n<p><strong>회피</strong></p>\n<p><strong>은행원 알고리즘</strong></p>\n<ul>\n<li>프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 미리 검사하여 교착 상태를 회피한다. 안정 상태인 경우만 자원을 할당하고 그렇지 않은 경우 다른 프로세스들의 자원 해지시 까지 대기한다.</li>\n<li>은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법으로 병렬 수행 프로세스 간의 교착 상태를 방지하기 위한 방법이다. 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후에도 안정한 상태인지 사전에 검사하여 교착 상태를 회피하는 기법이다. 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장한다.</li>\n</ul>\n<h4><strong>1.3.2 교착 상태 탐지(발견) 및 회복</strong></h4>\n<blockquote>\n<ul>\n<li>교착 상태가 발생했는지 점검하고 교착 상태에 있는 프로세스와 자원을 발견하고 교착 상태를 일으킨 프로세스를 종료하거나 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.</li>\n<li><strong>교착 상태 탐지(발견)</strong>에는 <strong>교착 상태 발견 알고리즘</strong>과 <strong>자원 할당 그래프</strong> 등을 사용할 수 있다.</li>\n</ul>\n</blockquote>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/cf7a2c50573534fc3af396f1286568df/a6c2c/img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 108.8235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAACrElEQVQ4y31UaU8iQRDl/3/X/eR+UZEVDEuynGuEiAyn4KJDPAOCcniBGrnh7bzSngzMYJkO9lT361dVr8qFL5vP57JorVYLT09PcPLRGo06er3egl+Zy/phNpthNBrh8vISun6GwWAge2XT6VS+6bqOk5MSPj4+MB6PF0AXALvGq/F4HPlCHsmjJNKZtHHxxAQk84P4AXL5HI5SR9DSGiqVyieZ+cwOyDAJdpg8xMbPDZQMFrys7O7uDoXjAmJ/Y9jc2hQ/l4pOAK35eX19xfqPdWEViUaw7d7Gzc2N6b+/v8fa+hr0io5AIIBd766Rz8ZCngVwNv1Ev729lYPKSqXSQnGYu2g0au5zuZzkUeVXAM1KGX/ZbBZW44FQKCTMp7Op6VeMWaBgMCi/ZpUZOyVQPC7i6urKzAdfpBUKBSQSCZT/lSWCZX8ymYSW0iQSVtzVarYQ/BOEz+tDKpWy6a7T6SASjsCz48Gx8ajVz1Wv1xH4HRD/6ekpXM/Pz0jEE3C7d6Cf6TbARr2BPd8ePJ5fuL6+tvlr1RrCobDh94gKzBz6fD55wSmkWCxm6wprd/T7fbMBXMrB+DVNEzD17f39HZlM5luw5f9dVlEy6efn5+aBfD6Pt7c3k7U1d07LJmzS9nq9ImZKhKE+PDzYmCzbyuFANgTy+/2iP/au6lWlu3a7jW63K1KjAlQEjsPh5eUFtVoN+/v7CIfDsmcKlL/ZbKJcLqNYLIrEWHX14EpAthe1xbZj7/KC8pMdH+QZ5pdiVs3gCDgcDuUCi8OmJzDDUkZA5pfyYvW55+y0AS4nloVIG7POOnjVPKxWqxI2Jfb4+IiLi4vVDGXyfMmD4aumV4AMkewUe7LjA44MV0nDKisCswGYFhaLMptMJt8DOol1GZiyYbGWwWj/AWK2fHB8oa9vAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img_2.png' title='img_2.png' src='/static/cf7a2c50573534fc3af396f1286568df/ca1dc/img_2.png' srcset='/static/cf7a2c50573534fc3af396f1286568df/e7570/img_2.png 170w,\n/static/cf7a2c50573534fc3af396f1286568df/f46e7/img_2.png 340w,\n/static/cf7a2c50573534fc3af396f1286568df/ca1dc/img_2.png 680w,\n/static/cf7a2c50573534fc3af396f1286568df/a6c2c/img_2.png 822w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img_2.png</figcaption>\n  </figure></p>\n<p><strong>교착 상태 회복</strong></p>\n<p>교착 상태 회복 기법에는 프로세스 종료, 자원 선점 방법이 있다.</p>\n<ul>\n<li><strong>프로세스 종료 :</strong> 교착 상태에 있는 프로세스를 종료하는 방법으로 교착 상태에 있는 모든 프로세스를 종료하는 방법과 프로세스들을 하나씩 종료하면서 교착 상태를 해결하는 방법이 있다.</li>\n<li><strong>자원 선점 :</strong> 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당하여 해당 프로세스를 일시적으로 멈추는 방법이다. 우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점한다.</li>\n</ul>\n<h4><strong>1.3.3 교착 상태 무시</strong></h4>\n<p>대부분 교착 상태가 잘 발생하지 않기에 교착 상태 예방, 회피, 탐지, 복구는 비용이 많이 든다. 또 예방 또는 회피를 프로그래밍해서 넣으면 성능이 큰 영향을 미칠 수 있다. 때문에 교착 상태의 발생 확률이 비교적 낮으면 별 다른 조치를 취하지 않는다.</p>\n<h2>2. 기아상태(Starvation)란?</h2>\n<blockquote>\n<p>특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태를 말함 <br>\n여러 프로세스가 자원을 점유 할때 특정 프로세스에게 자원이 아예 할당 안되는 경우</p>\n</blockquote>\n<h3>2.1 기아상태 해결 방법</h3>\n<ul>\n<li>프로세스 우선순위 수시 변경을 통해 각 프로세스 높은 우선순위를 가지도록 기회 부여</li>\n<li>오래 기다린 프로세스의 우선순위 높이기</li>\n<li>우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용</li>\n</ul>\n<h2>3. 경합 조건란?</h2>\n<blockquote>\n<p>둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 <code class=\"language-text\">공유자원에 동시에 접근</code>하여 결과값에 영향을 줄 수 있는 상태</p>\n</blockquote>\n<h3>3.1 경합 조건의 예시</h3>\n<p>아들은 은행에 10000원의 잔고가 있었고, 현금 인출기를 통해 잔고 10000원을 출금하고 있다. 그 사이 엄마는 아들에게 용돈을 5000원 입금 해주었다. 그렇다면 잔고는 얼마일까?<br>\n아들은 10000원을 인출했기 때문에 잔고는 0원이 되고, 이후 엄마가 5000원을 입금해주신 덕분에 잔고는 5000원이 되리라 기대할 것이다.<br>\n하지만 경쟁상태일 때<br>\n동시에 출금과 입금이 이루어지는 경우<br>\n아들의 입장 : 현재잔고 10000원 – 10000원 출금 = 기대잔고 0원<br>\n엄마의 입장 : 현재잔고 10000원 – 5000원 입금 = 기대잔고 15000원<br></p>\n<p>이처럼 경쟁 조건는 <code class=\"language-text\">공유 데이터(잔고)에 최종값을 보장할 수 없는 상황</code>을 말한다.</p>\n<p>이 경쟁 조건로 생기는 영역이<code class=\"language-text\">임계구역(Critical Section)</code>이다.</p>\n<ul>\n<li><strong>정의:</strong> 경쟁 조건은 시스템의 동작이 스레드가 실행되도록 예약된 순서와 같은 이벤트의 상대적 타이밍에 따라 달라질 때 발생</li>\n<li><strong>원인:</strong> 여러 스레드나 프로세스의 실행 순서가 비결정적이기 때문에 발생</li>\n</ul>\n<h4>임계구역(critical section)</h4>\n<p>공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역이다.<br>\n이 임계구역을 해결하는 방법이 <code class=\"language-text\">동기화 메커니즘(ex. 세마포어)</code>을 사용하는 것이다.<br>\n동기화 메커니즘의 근간이 바로 <code class=\"language-text\">락(Lock)</code>을 사용하는 것이다.<br></p>\n<p>경쟁 조건와 교착상태에서는 다양한 동기화 기술과 알고리즘이 사용됨</p>\n<h2>4. 기타</h2>\n<h3>4.1 <strong>교착 상태 vs 기아 상태</strong></h3>\n<p>교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태이다. 즉 교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생하고 기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다.</p>\n<ul>\n<li><strong>교착상태</strong> : 여러 프로세스가 동일 자원 점유를 요청할 때 발생</li>\n<li><strong>기아상태</strong> : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생</li>\n</ul>\n<h3>4.2 교착 상태 vs 경쟁 조건</h3>\n<p>교착 상태와 경쟁 조건은 모두 동시성 문제인 반면, 교착 상태는 리소스에 대한 순환 종속성을 포함하여 완전한 정지를 초래하는 반면, 경쟁 조건은 예측할 수 없는 작업 인터리빙과 관련되어 동시 리소스 액세스로 인해 예상치 못한 결과를 초래</p>\n<ul>\n<li><strong>교착 상태:</strong> 교착 상태는 두 개 이상의 프로세스가 서로의 리소스 해제를 기다리고 있기 때문에 진행할 수 없는 상황. 이로 인해 순환 대기 시나리오가 발생하고 관련 프로세스가 무기한 차단됨</li>\n<li><strong>경쟁 조건:</strong> 경쟁 조건은 시스템의 동작이 이벤트의 상대적인 타이밍, 특히 스레드나 프로세스가 실행되도록 예약된 순서에 따라 달라질 때 발생함. 비결정적인 실행 순서로 인해 예측할 수 없는 결과가 발생함</li>\n</ul>","frontmatter":{"title":"🤔 교착상태 vs 기아상태 vs 경합상태","date":"January 09, 2024","update":"January 09, 2024","tags":["OS"],"series":"OS"},"fields":{"slug":"/deadlock/","readingTime":{"minutes":11.975}}},"seriesList":{"edges":[{"node":{"id":"4e9d052d-d623-5622-a4ef-9748723c1861","fields":{"slug":"/deadlock/"},"frontmatter":{"title":"🤔 교착상태 vs 기아상태 vs 경합상태"}}},{"node":{"id":"5b170048-19c5-52bc-a04f-ee873065efe3","fields":{"slug":"/critical-sections/"},"frontmatter":{"title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)"}}}]},"previous":null,"next":{"fields":{"slug":"/critical-sections/"},"frontmatter":{"title":"임계영역(Critical Section), 세마포어(Semaphore) vs 뮤텍스(Mutex)"}}},"pageContext":{"id":"4e9d052d-d623-5622-a4ef-9748723c1861","series":"OS","previousPostId":null,"nextPostId":"5b170048-19c5-52bc-a04f-ee873065efe3"}},"staticQueryHashes":[]}